# Cè¯­è¨€é«˜çº§ç‰¹æ€§ä¸ç³»ç»Ÿç¼–ç¨‹

## 1. Cè¯­è¨€å†…å­˜æ¨¡å‹æ·±åº¦è§£æ

### 1.1 æŠ½è±¡æœºå™¨æ¨¡å‹ä¸å†…å­˜æ¶æ„

Cè¯­è¨€çš„æŠ½è±¡æœºå™¨æ¨¡å‹æ˜¯ç†è§£ç¨‹åºè¡Œä¸ºçš„ç†è®ºåŸºç¡€ï¼Œå®ƒå®šä¹‰äº†ç¨‹åºæ‰§è¡Œçš„è¯­ä¹‰æ¡†æ¶ã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

// å†…å­˜å¸ƒå±€åˆ†æå™¨
typedef struct {
    const char* name;
    void* address;
    size_t size;
    const char* segment;
} memory_info_t;

// å…¨å±€å˜é‡ - æ•°æ®æ®µ
int global_initialized = 42;
int global_uninitialized;
static int static_global = 100;

// å¸¸é‡ - åªè¯»æ•°æ®æ®µ
const char* const_string = "Hello, World!";
const int const_array[] = {1, 2, 3, 4, 5};

// å†…å­˜å¸ƒå±€åˆ†æå™¨å®ç°
void analyze_memory_layout() {
    // å±€éƒ¨å˜é‡ - æ ˆ
    int local_var = 10;
    char local_array[100];
    
    // åŠ¨æ€åˆ†é… - å †
    void* heap_ptr = malloc(1024);
    
    memory_info_t memory_map[] = {
        {"å…¨å±€å·²åˆå§‹åŒ–å˜é‡", &global_initialized, sizeof(global_initialized), "æ•°æ®æ®µ"},
        {"å…¨å±€æœªåˆå§‹åŒ–å˜é‡", &global_uninitialized, sizeof(global_uninitialized), "BSSæ®µ"},
        {"é™æ€å…¨å±€å˜é‡", &static_global, sizeof(static_global), "æ•°æ®æ®µ"},
        {"å­—ç¬¦ä¸²å¸¸é‡", (void*)const_string, strlen(const_string), "åªè¯»æ•°æ®æ®µ"},
        {"å¸¸é‡æ•°ç»„", (void*)const_array, sizeof(const_array), "åªè¯»æ•°æ®æ®µ"},
        {"å±€éƒ¨å˜é‡", &local_var, sizeof(local_var), "æ ˆ"},
        {"å±€éƒ¨æ•°ç»„", local_array, sizeof(local_array), "æ ˆ"},
        {"å †åˆ†é…å†…å­˜", heap_ptr, 1024, "å †"},
        {"å‡½æ•°åœ°å€", (void*)analyze_memory_layout, 0, "ä»£ç æ®µ"}
    };
    
    printf("=== Cè¯­è¨€å†…å­˜å¸ƒå±€åˆ†æ ===\n");
    printf("%-20s %-18s %-10s %s\n", "å˜é‡å", "å†…å­˜åœ°å€", "å¤§å°", "å†…å­˜æ®µ");
    printf("%-20s %-18s %-10s %s\n", "----", "--------", "----", "----");
    
    for (size_t i = 0; i < sizeof(memory_map) / sizeof(memory_map[0]); i++) {
        printf("%-20s %p %-10zu %s\n", 
               memory_map[i].name, 
               memory_map[i].address,
               memory_map[i].size,
               memory_map[i].segment);
    }
    
    // åˆ†ææ ˆå¢é•¿æ–¹å‘
    int stack_var1 = 1;
    int stack_var2 = 2;
    printf("\næ ˆå¢é•¿æ–¹å‘: %s\n", 
           (&stack_var2 < &stack_var1) ? "å‘ä¸‹å¢é•¿" : "å‘ä¸Šå¢é•¿");
    
    free(heap_ptr);
}
```

### 1.2 å†…å­˜å¯¹é½ä¸æ•°æ®ç»“æ„ä¼˜åŒ–

å†…å­˜å¯¹é½æ˜¯å½±å“ç¨‹åºæ€§èƒ½çš„é‡è¦å› ç´ ï¼Œç†è§£å¯¹é½è§„åˆ™æœ‰åŠ©äºä¼˜åŒ–æ•°æ®ç»“æ„ã€‚

```c
#include <stddef.h>
#include <stdalign.h>

// æ¼”ç¤ºå†…å­˜å¯¹é½çš„å½±å“
typedef struct {
    char a;      // 1å­—èŠ‚
    int b;       // 4å­—èŠ‚ï¼Œéœ€è¦å¯¹é½
    char c;      // 1å­—èŠ‚
    double d;    // 8å­—èŠ‚ï¼Œéœ€è¦å¯¹é½
} unoptimized_struct_t;

typedef struct {
    double d;    // 8å­—èŠ‚
    int b;       // 4å­—èŠ‚
    char a;      // 1å­—èŠ‚
    char c;      // 1å­—èŠ‚
    // ç¼–è¯‘å™¨ä¼šæ·»åŠ 2å­—èŠ‚å¡«å……
} optimized_struct_t;

// ä½¿ç”¨packedå±æ€§æ¶ˆé™¤å¡«å……
typedef struct __attribute__((packed)) {
    char a;
    int b;
    char c;
    double d;
} packed_struct_t;

// å†…å­˜å¯¹é½åˆ†æå™¨
void analyze_memory_alignment() {
    printf("=== å†…å­˜å¯¹é½åˆ†æ ===\n");
    
    printf("æœªä¼˜åŒ–ç»“æ„ä½“:\n");
    printf("  å¤§å°: %zu å­—èŠ‚\n", sizeof(unoptimized_struct_t));
    printf("  å¯¹é½: %zu å­—èŠ‚\n", alignof(unoptimized_struct_t));
    
    unoptimized_struct_t unopt;
    printf("  æˆå‘˜åç§»:\n");
    printf("    a: %zu\n", offsetof(unoptimized_struct_t, a));
    printf("    b: %zu\n", offsetof(unoptimized_struct_t, b));
    printf("    c: %zu\n", offsetof(unoptimized_struct_t, c));
    printf("    d: %zu\n", offsetof(unoptimized_struct_t, d));
    
    printf("\nä¼˜åŒ–åç»“æ„ä½“:\n");
    printf("  å¤§å°: %zu å­—èŠ‚\n", sizeof(optimized_struct_t));
    printf("  å¯¹é½: %zu å­—èŠ‚\n", alignof(optimized_struct_t));
    
    printf("\nç´§å‡‘ç»“æ„ä½“:\n");
    printf("  å¤§å°: %zu å­—èŠ‚\n", sizeof(packed_struct_t));
    printf("  å¯¹é½: %zu å­—èŠ‚\n", alignof(packed_struct_t));
    
    // è®¡ç®—å†…å­˜æµªè´¹
    size_t waste_unopt = sizeof(unoptimized_struct_t) - (sizeof(char) * 2 + sizeof(int) + sizeof(double));
    size_t waste_opt = sizeof(optimized_struct_t) - (sizeof(char) * 2 + sizeof(int) + sizeof(double));
    
    printf("\nå†…å­˜æµªè´¹åˆ†æ:\n");
    printf("  æœªä¼˜åŒ–: %zu å­—èŠ‚æµªè´¹\n", waste_unopt);
    printf("  ä¼˜åŒ–å: %zu å­—èŠ‚æµªè´¹\n", waste_opt);
    printf("  èŠ‚çœ: %.1f%%\n", (double)(waste_unopt - waste_opt) / sizeof(unoptimized_struct_t) * 100);
}
```

### 1.3 é«˜çº§å†…å­˜ç®¡ç†æŠ€æœ¯

å®ç°è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨ï¼Œæä¾›æ›´å¥½çš„æ€§èƒ½å’Œæ§åˆ¶ã€‚

```c
#include <sys/mman.h>
#include <unistd.h>

// å†…å­˜æ± åˆ†é…å™¨
typedef struct memory_block {
    size_t size;
    int is_free;
    struct memory_block* next;
    struct memory_block* prev;
} memory_block_t;

typedef struct {
    void* pool_start;
    size_t pool_size;
    memory_block_t* free_list;
    size_t allocated_bytes;
    size_t free_bytes;
    size_t allocation_count;
} memory_pool_t;

// åˆ›å»ºå†…å­˜æ± 
memory_pool_t* create_memory_pool(size_t size) {
    memory_pool_t* pool = malloc(sizeof(memory_pool_t));
    if (!pool) return NULL;
    
    // ä½¿ç”¨mmapåˆ†é…å¤§å—å†…å­˜
    pool->pool_start = mmap(NULL, size, PROT_READ | PROT_WRITE, 
                           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (pool->pool_start == MAP_FAILED) {
        free(pool);
        return NULL;
    }
    
    pool->pool_size = size;
    pool->allocated_bytes = 0;
    pool->free_bytes = size - sizeof(memory_block_t);
    pool->allocation_count = 0;
    
    // åˆå§‹åŒ–ç©ºé—²å—é“¾è¡¨
    pool->free_list = (memory_block_t*)pool->pool_start;
    pool->free_list->size = size - sizeof(memory_block_t);
    pool->free_list->is_free = 1;
    pool->free_list->next = NULL;
    pool->free_list->prev = NULL;
    
    return pool;
}

// ä»å†…å­˜æ± åˆ†é…å†…å­˜
void* pool_malloc(memory_pool_t* pool, size_t size) {
    if (!pool || size == 0) return NULL;
    
    // å¯¹é½åˆ°8å­—èŠ‚è¾¹ç•Œ
    size = (size + 7) & ~7;
    
    memory_block_t* current = pool->free_list;
    while (current) {
        if (current->is_free && current->size >= size) {
            // æ‰¾åˆ°åˆé€‚çš„å—
            if (current->size > size + sizeof(memory_block_t)) {
                // åˆ†å‰²å—
                memory_block_t* new_block = (memory_block_t*)((char*)current + sizeof(memory_block_t) + size);
                new_block->size = current->size - size - sizeof(memory_block_t);
                new_block->is_free = 1;
                new_block->next = current->next;
                new_block->prev = current;
                
                if (current->next) {
                    current->next->prev = new_block;
                }
                current->next = new_block;
                current->size = size;
            }
            
            current->is_free = 0;
            pool->allocated_bytes += current->size;
            pool->free_bytes -= current->size;
            pool->allocation_count++;
            
            return (char*)current + sizeof(memory_block_t);
        }
        current = current->next;
    }
    
    return NULL; // æ²¡æœ‰è¶³å¤Ÿçš„ç©ºé—´
}

// é‡Šæ”¾å†…å­˜åˆ°å†…å­˜æ± 
void pool_free(memory_pool_t* pool, void* ptr) {
    if (!pool || !ptr) return;
    
    memory_block_t* block = (memory_block_t*)((char*)ptr - sizeof(memory_block_t));
    block->is_free = 1;
    
    pool->allocated_bytes -= block->size;
    pool->free_bytes += block->size;
    pool->allocation_count--;
    
    // åˆå¹¶ç›¸é‚»çš„ç©ºé—²å—
    if (block->next && block->next->is_free) {
        block->size += block->next->size + sizeof(memory_block_t);
        if (block->next->next) {
            block->next->next->prev = block;
        }
        block->next = block->next->next;
    }
    
    if (block->prev && block->prev->is_free) {
        block->prev->size += block->size + sizeof(memory_block_t);
        if (block->next) {
            block->next->prev = block->prev;
        }
        block->prev->next = block->next;
    }
}

// å†…å­˜æ± ç»Ÿè®¡ä¿¡æ¯
void print_pool_stats(memory_pool_t* pool) {
    printf("=== å†…å­˜æ± ç»Ÿè®¡ ===\n");
    printf("æ€»å¤§å°: %zu å­—èŠ‚\n", pool->pool_size);
    printf("å·²åˆ†é…: %zu å­—èŠ‚\n", pool->allocated_bytes);
    printf("ç©ºé—²: %zu å­—èŠ‚\n", pool->free_bytes);
    printf("åˆ†é…æ¬¡æ•°: %zu\n", pool->allocation_count);
    printf("åˆ©ç”¨ç‡: %.2f%%\n", (double)pool->allocated_bytes / pool->pool_size * 100);
}

// é”€æ¯å†…å­˜æ± 
void destroy_memory_pool(memory_pool_t* pool) {
    if (pool) {
        munmap(pool->pool_start, pool->pool_size);
        free(pool);
    }
}
```

---

## 2. æœªå®šä¹‰è¡Œä¸ºæ·±åº¦åˆ†æä¸é¢„é˜²

### 2.1 æœªå®šä¹‰è¡Œä¸ºçš„åˆ†ç±»ä¸æ£€æµ‹

æœªå®šä¹‰è¡Œä¸ºæ˜¯Cè¯­è¨€ä¸­æœ€å±é™©çš„é™·é˜±ä¹‹ä¸€ï¼Œç†è§£å’Œé¢„é˜²å®ƒä»¬è‡³å…³é‡è¦ã€‚

```c
#include <limits.h>
#include <stdint.h>

// æœªå®šä¹‰è¡Œä¸ºæ£€æµ‹å™¨
typedef enum {
    UB_NONE,
    UB_BUFFER_OVERFLOW,
    UB_INTEGER_OVERFLOW,
    UB_NULL_POINTER_DEREFERENCE,
    UB_USE_AFTER_FREE,
    UB_DOUBLE_FREE,
    UB_UNINITIALIZED_VARIABLE,
    UB_SIGNED_INTEGER_OVERFLOW
} ub_type_t;

typedef struct {
    ub_type_t type;
    const char* description;
    const char* location;
    int severity; // 1-10
} ub_report_t;

// å®‰å…¨çš„æ•´æ•°è¿ç®—
int safe_add(int a, int b, int* result) {
    // æ£€æŸ¥åŠ æ³•æº¢å‡º
    if (a > 0 && b > 0 && a > INT_MAX - b) {
        return 0; // æº¢å‡º
    }
    if (a < 0 && b < 0 && a < INT_MIN - b) {
        return 0; // ä¸‹æº¢
    }
    *result = a + b;
    return 1; // æˆåŠŸ
}

int safe_multiply(int a, int b, int* result) {
    // æ£€æŸ¥ä¹˜æ³•æº¢å‡º
    if (a == 0 || b == 0) {
        *result = 0;
        return 1;
    }
    
    if (a > 0) {
        if (b > 0) {
            if (a > INT_MAX / b) return 0;
        } else {
            if (b < INT_MIN / a) return 0;
        }
    } else {
        if (b > 0) {
            if (a < INT_MIN / b) return 0;
        } else {
            if (a != 0 && b < INT_MAX / a) return 0;
        }
    }
    
    *result = a * b;
    return 1;
}

// å®‰å…¨çš„å­—ç¬¦ä¸²æ“ä½œ
char* safe_strcpy(char* dest, const char* src, size_t dest_size) {
    if (!dest || !src || dest_size == 0) {
        return NULL;
    }
    
    size_t src_len = strlen(src);
    if (src_len >= dest_size) {
        // æˆªæ–­å­—ç¬¦ä¸²
        strncpy(dest, src, dest_size - 1);
        dest[dest_size - 1] = '\0';
    } else {
        strcpy(dest, src);
    }
    
    return dest;
}

// å®‰å…¨çš„å†…å­˜æ“ä½œ
void* safe_malloc(size_t size) {
    if (size == 0 || size > SIZE_MAX / 2) {
        return NULL; // é˜²æ­¢æ•´æ•°æº¢å‡º
    }
    
    void* ptr = malloc(size);
    if (ptr) {
        memset(ptr, 0, size); // åˆå§‹åŒ–ä¸ºé›¶
    }
    
    return ptr;
}

// å†…å­˜æ³„æ¼æ£€æµ‹å™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰
typedef struct allocation {
    void* ptr;
    size_t size;
    const char* file;
    int line;
    struct allocation* next;
} allocation_t;

static allocation_t* allocations = NULL;
static size_t total_allocated = 0;
static size_t allocation_count = 0;

#define SAFE_MALLOC(size) debug_malloc(size, __FILE__, __LINE__)
#define SAFE_FREE(ptr) debug_free(ptr, __FILE__, __LINE__)

void* debug_malloc(size_t size, const char* file, int line) {
    void* ptr = safe_malloc(size);
    if (ptr) {
        allocation_t* alloc = malloc(sizeof(allocation_t));
        if (alloc) {
            alloc->ptr = ptr;
            alloc->size = size;
            alloc->file = file;
            alloc->line = line;
            alloc->next = allocations;
            allocations = alloc;
            total_allocated += size;
            allocation_count++;
        }
    }
    return ptr;
}

void debug_free(void* ptr, const char* file, int line) {
    if (!ptr) return;
    
    allocation_t** current = &allocations;
    while (*current) {
        if ((*current)->ptr == ptr) {
            allocation_t* to_remove = *current;
            *current = (*current)->next;
            total_allocated -= to_remove->size;
            allocation_count--;
            free(to_remove);
            free(ptr);
            return;
        }
        current = &(*current)->next;
    }
    
    printf("è­¦å‘Š: è¯•å›¾é‡Šæ”¾æœªè·Ÿè¸ªçš„å†…å­˜ %p (åœ¨ %s:%d)\n", ptr, file, line);
}

void check_memory_leaks() {
    printf("=== å†…å­˜æ³„æ¼æ£€æµ‹æŠ¥å‘Š ===\n");
    if (allocations == NULL) {
        printf("æ²¡æœ‰æ£€æµ‹åˆ°å†…å­˜æ³„æ¼\n");
        return;
    }
    
    printf("æ£€æµ‹åˆ° %zu ä¸ªå†…å­˜æ³„æ¼ï¼Œæ€»è®¡ %zu å­—èŠ‚:\n", allocation_count, total_allocated);
    allocation_t* current = allocations;
    while (current) {
        printf("  %p: %zu å­—èŠ‚ (åˆ†é…äº %s:%d)\n", 
               current->ptr, current->size, current->file, current->line);
        current = current->next;
    }
}
```

### 2.2 ç¼–è¯‘æ—¶å’Œè¿è¡Œæ—¶æ£€æµ‹å·¥å…·

```c
// ç¼–è¯‘æ—¶æ–­è¨€å®
#define STATIC_ASSERT(condition, message) \
    _Static_assert(condition, message)

// è¿è¡Œæ—¶æ–­è¨€å®
#ifdef DEBUG
#define ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            fprintf(stderr, "æ–­è¨€å¤±è´¥: %s\næ–‡ä»¶: %s, è¡Œ: %d\n", \
                    message, __FILE__, __LINE__); \
            abort(); \
        } \
    } while(0)
#else
#define ASSERT(condition, message) ((void)0)
#endif

// è¾¹ç•Œæ£€æŸ¥æ•°ç»„
typedef struct {
    void* data;
    size_t size;
    size_t element_size;
    size_t capacity;
} safe_array_t;

safe_array_t* create_safe_array(size_t element_size, size_t initial_capacity) {
    safe_array_t* arr = malloc(sizeof(safe_array_t));
    if (!arr) return NULL;
    
    arr->data = malloc(element_size * initial_capacity);
    if (!arr->data) {
        free(arr);
        return NULL;
    }
    
    arr->element_size = element_size;
    arr->size = 0;
    arr->capacity = initial_capacity;
    
    return arr;
}

void* safe_array_get(safe_array_t* arr, size_t index) {
    ASSERT(arr != NULL, "æ•°ç»„æŒ‡é’ˆä¸ºç©º");
    ASSERT(index < arr->size, "æ•°ç»„ç´¢å¼•è¶Šç•Œ");
    
    return (char*)arr->data + (index * arr->element_size);
}

int safe_array_set(safe_array_t* arr, size_t index, const void* value) {
    ASSERT(arr != NULL, "æ•°ç»„æŒ‡é’ˆä¸ºç©º");
    ASSERT(value != NULL, "å€¼æŒ‡é’ˆä¸ºç©º");
    ASSERT(index < arr->size, "æ•°ç»„ç´¢å¼•è¶Šç•Œ");
    
    memcpy((char*)arr->data + (index * arr->element_size), value, arr->element_size);
    return 1;
}

void destroy_safe_array(safe_array_t* arr) {
    if (arr) {
        free(arr->data);
        free(arr);
    }
}
```

---

## 3. å¤šçº¿ç¨‹ç¼–ç¨‹ä¸åŒæ­¥æœºåˆ¶

### 3.1 C11åŸå­æ“ä½œä¸å†…å­˜åº

C11æ ‡å‡†å¼•å…¥äº†åŸå­æ“ä½œå’Œå†…å­˜åºï¼Œä¸ºå¤šçº¿ç¨‹ç¼–ç¨‹æä¾›äº†æ ‡å‡†åŒ–çš„æ”¯æŒã€‚

```c
#include <stdatomic.h>
#include <threads.h>
#include <time.h>

// åŸå­æ“ä½œæ¼”ç¤º
typedef struct {
    atomic_int counter;
    atomic_bool running;
    atomic_ulong total_operations;
} atomic_counter_t;

// æ— é”è®¡æ•°å™¨
void atomic_counter_init(atomic_counter_t* counter) {
    atomic_init(&counter->counter, 0);
    atomic_init(&counter->running, true);
    atomic_init(&counter->total_operations, 0);
}

void atomic_counter_increment(atomic_counter_t* counter) {
    atomic_fetch_add_explicit(&counter->counter, 1, memory_order_relaxed);
    atomic_fetch_add_explicit(&counter->total_operations, 1, memory_order_relaxed);
}

int atomic_counter_get(atomic_counter_t* counter) {
    return atomic_load_explicit(&counter->counter, memory_order_acquire);
}

void atomic_counter_stop(atomic_counter_t* counter) {
    atomic_store_explicit(&counter->running, false, memory_order_release);
}

bool atomic_counter_is_running(atomic_counter_t* counter) {
    return atomic_load_explicit(&counter->running, memory_order_acquire);
}

// å·¥ä½œçº¿ç¨‹å‡½æ•°
int worker_thread(void* arg) {
    atomic_counter_t* counter = (atomic_counter_t*)arg;
    
    while (atomic_counter_is_running(counter)) {
        atomic_counter_increment(counter);
        
        // æ¨¡æ‹Ÿä¸€äº›å·¥ä½œ
        struct timespec ts = {0, 1000000}; // 1ms
        thrd_sleep(&ts, NULL);
    }
    
    return 0;
}

// å¤šçº¿ç¨‹åŸå­æ“ä½œæµ‹è¯•
void test_atomic_operations() {
    printf("=== åŸå­æ“ä½œæµ‹è¯• ===\n");
    
    atomic_counter_t counter;
    atomic_counter_init(&counter);
    
    const int num_threads = 4;
    thrd_t threads[num_threads];
    
    // åˆ›å»ºå·¥ä½œçº¿ç¨‹
    for (int i = 0; i < num_threads; i++) {
        if (thrd_create(&threads[i], worker_thread, &counter) != thrd_success) {
            printf("åˆ›å»ºçº¿ç¨‹ %d å¤±è´¥\n", i);
            return;
        }
    }
    
    // è¿è¡Œ5ç§’
    struct timespec sleep_time = {5, 0};
    thrd_sleep(&sleep_time, NULL);
    
    // åœæ­¢æ‰€æœ‰çº¿ç¨‹
    atomic_counter_stop(&counter);
    
    // ç­‰å¾…çº¿ç¨‹ç»“æŸ
    for (int i = 0; i < num_threads; i++) {
        thrd_join(threads[i], NULL);
    }
    
    printf("æœ€ç»ˆè®¡æ•°: %d\n", atomic_counter_get(&counter));
    printf("æ€»æ“ä½œæ•°: %lu\n", atomic_load(&counter.total_operations));
}
```

### 3.2 é«˜çº§åŒæ­¥åŸè¯­å®ç°

```c
// è¯»å†™é”å®ç°
typedef struct {
    atomic_int readers;
    atomic_bool writer;
    mtx_t mutex;
    cnd_t read_cond;
    cnd_t write_cond;
} rwlock_t;

int rwlock_init(rwlock_t* lock) {
    atomic_init(&lock->readers, 0);
    atomic_init(&lock->writer, false);
    
    if (mtx_init(&lock->mutex, mtx_plain) != thrd_success) {
        return -1;
    }
    
    if (cnd_init(&lock->read_cond) != thrd_success) {
        mtx_destroy(&lock->mutex);
        return -1;
    }
    
    if (cnd_init(&lock->write_cond) != thrd_success) {
        mtx_destroy(&lock->mutex);
        cnd_destroy(&lock->read_cond);
        return -1;
    }
    
    return 0;
}

int rwlock_rdlock(rwlock_t* lock) {
    mtx_lock(&lock->mutex);
    
    // ç­‰å¾…å†™è€…å®Œæˆ
    while (atomic_load(&lock->writer)) {
        cnd_wait(&lock->read_cond, &lock->mutex);
    }
    
    atomic_fetch_add(&lock->readers, 1);
    mtx_unlock(&lock->mutex);
    
    return 0;
}

int rwlock_wrlock(rwlock_t* lock) {
    mtx_lock(&lock->mutex);
    
    // ç­‰å¾…æ‰€æœ‰è¯»è€…å’Œå†™è€…å®Œæˆ
    while (atomic_load(&lock->readers) > 0 || atomic_load(&lock->writer)) {
        cnd_wait(&lock->write_cond, &lock->mutex);
    }
    
    atomic_store(&lock->writer, true);
    mtx_unlock(&lock->mutex);
    
    return 0;
}

int rwlock_unlock(rwlock_t* lock) {
    mtx_lock(&lock->mutex);
    
    if (atomic_load(&lock->writer)) {
        // é‡Šæ”¾å†™é”
        atomic_store(&lock->writer, false);
        cnd_broadcast(&lock->read_cond);
        cnd_broadcast(&lock->write_cond);
    } else {
        // é‡Šæ”¾è¯»é”
        if (atomic_fetch_sub(&lock->readers, 1) == 1) {
            // æœ€åä¸€ä¸ªè¯»è€…
            cnd_broadcast(&lock->write_cond);
        }
    }
    
    mtx_unlock(&lock->mutex);
    return 0;
}

void rwlock_destroy(rwlock_t* lock) {
    mtx_destroy(&lock->mutex);
    cnd_destroy(&lock->read_cond);
    cnd_destroy(&lock->write_cond);
}

// æ— é”é˜Ÿåˆ—å®ç°
typedef struct queue_node {
    atomic_uintptr_t data;
    atomic_uintptr_t next;
} queue_node_t;

typedef struct {
    atomic_uintptr_t head;
    atomic_uintptr_t tail;
} lockfree_queue_t;

void queue_init(lockfree_queue_t* queue) {
    queue_node_t* dummy = malloc(sizeof(queue_node_t));
    atomic_init(&dummy->data, 0);
    atomic_init(&dummy->next, 0);
    
    atomic_init(&queue->head, (uintptr_t)dummy);
    atomic_init(&queue->tail, (uintptr_t)dummy);
}

void queue_enqueue(lockfree_queue_t* queue, void* data) {
    queue_node_t* new_node = malloc(sizeof(queue_node_t));
    atomic_init(&new_node->data, (uintptr_t)data);
    atomic_init(&new_node->next, 0);
    
    while (true) {
        queue_node_t* tail = (queue_node_t*)atomic_load(&queue->tail);
        queue_node_t* next = (queue_node_t*)atomic_load(&tail->next);
        
        if (tail == (queue_node_t*)atomic_load(&queue->tail)) {
            if (next == NULL) {
                if (atomic_compare_exchange_weak(&tail->next, (uintptr_t*)&next, (uintptr_t)new_node)) {
                    break;
                }
            } else {
                atomic_compare_exchange_weak(&queue->tail, (uintptr_t*)&tail, (uintptr_t)next);
            }
        }
    }
    
    queue_node_t* tail = (queue_node_t*)atomic_load(&queue->tail);
    atomic_compare_exchange_weak(&queue->tail, (uintptr_t*)&tail, (uintptr_t)new_node);
}

void* queue_dequeue(lockfree_queue_t* queue) {
    while (true) {
        queue_node_t* head = (queue_node_t*)atomic_load(&queue->head);
        queue_node_t* tail = (queue_node_t*)atomic_load(&queue->tail);
        queue_node_t* next = (queue_node_t*)atomic_load(&head->next);
        
        if (head == (queue_node_t*)atomic_load(&queue->head)) {
            if (head == tail) {
                if (next == NULL) {
                    return NULL; // é˜Ÿåˆ—ä¸ºç©º
                }
                atomic_compare_exchange_weak(&queue->tail, (uintptr_t*)&tail, (uintptr_t)next);
            } else {
                void* data = (void*)atomic_load(&next->data);
                if (atomic_compare_exchange_weak(&queue->head, (uintptr_t*)&head, (uintptr_t)next)) {
                    free(head);
                    return data;
                }
            }
        }
    }
}
```

---

## 4. ç¼–è¯‘å™¨ä¼˜åŒ–ä¸æ€§èƒ½è°ƒä¼˜

### 4.1 ç¼–è¯‘å™¨ä¼˜åŒ–åŸç†ä¸æ§åˆ¶

```c
// ç¼–è¯‘å™¨ä¼˜åŒ–æ§åˆ¶ç¤ºä¾‹
#include <immintrin.h>

// é˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–çš„å†…å­˜å±éšœ
#define COMPILER_BARRIER() __asm__ __volatile__("" ::: "memory")

// é¢„å–æŒ‡ä»¤
#define PREFETCH(addr) __builtin_prefetch(addr, 0, 3)

// åˆ†æ”¯é¢„æµ‹æç¤º
#define LIKELY(x)   __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)

// å¼ºåˆ¶å†…è”
#define FORCE_INLINE __attribute__((always_inline)) inline

// ç¦æ­¢å†…è”
#define NO_INLINE __attribute__((noinline))

// çƒ­ç‚¹å‡½æ•°æ ‡è®°
#define HOT_FUNCTION __attribute__((hot))

// å†·å‡½æ•°æ ‡è®°
#define COLD_FUNCTION __attribute__((cold))

// æ€§èƒ½å…³é”®çš„å¾ªç¯ä¼˜åŒ–
FORCE_INLINE void optimized_memcpy(void* dest, const void* src, size_t n) {
    char* d = (char*)dest;
    const char* s = (const char*)src;
    
    // å¯¹é½æ£€æŸ¥
    if (((uintptr_t)d | (uintptr_t)s) & 7) {
        // æœªå¯¹é½ï¼Œä½¿ç”¨å­—èŠ‚å¤åˆ¶
        while (n--) {
            *d++ = *s++;
        }
        return;
    }
    
    // 8å­—èŠ‚å¯¹é½å¤åˆ¶
    size_t chunks = n / 8;
    uint64_t* d64 = (uint64_t*)d;
    const uint64_t* s64 = (const uint64_t*)s;
    
    // å¾ªç¯å±•å¼€
    while (chunks >= 4) {
        PREFETCH(s64 + 8); // é¢„å–ä¸‹ä¸€ä¸ªç¼“å­˜è¡Œ
        
        d64[0] = s64[0];
        d64[1] = s64[1];
        d64[2] = s64[2];
        d64[3] = s64[3];
        
        d64 += 4;
        s64 += 4;
        chunks -= 4;
    }
    
    // å¤„ç†å‰©ä½™çš„8å­—èŠ‚å—
    while (chunks--) {
        *d64++ = *s64++;
    }
    
    // å¤„ç†å‰©ä½™å­—èŠ‚
    d = (char*)d64;
    s = (const char*)s64;
    n &= 7;
    while (n--) {
        *d++ = *s++;
    }
}

// ç¼“å­˜å‹å¥½çš„çŸ©é˜µä¹˜æ³•
void cache_friendly_matrix_multiply(double** A, double** B, double** C, int n) {
    const int BLOCK_SIZE = 64; // æ ¹æ®ç¼“å­˜å¤§å°è°ƒæ•´
    
    for (int ii = 0; ii < n; ii += BLOCK_SIZE) {
        for (int jj = 0; jj < n; jj += BLOCK_SIZE) {
            for (int kk = 0; kk < n; kk += BLOCK_SIZE) {
                // å—å†…è®¡ç®—
                int i_max = (ii + BLOCK_SIZE < n) ? ii + BLOCK_SIZE : n;
                int j_max = (jj + BLOCK_SIZE < n) ? jj + BLOCK_SIZE : n;
                int k_max = (kk + BLOCK_SIZE < n) ? kk + BLOCK_SIZE : n;
                
                for (int i = ii; i < i_max; i++) {
                    for (int j = jj; j < j_max; j++) {
                        double sum = C[i][j];
                        for (int k = kk; k < k_max; k++) {
                            sum += A[i][k] * B[k][j];
                        }
                        C[i][j] = sum;
                    }
                }
            }
        }
    }
}
```

### 4.2 SIMDæŒ‡ä»¤ä¼˜åŒ–

```c
// SIMDä¼˜åŒ–çš„å‘é‡è¿ç®—
void simd_vector_add(const float* a, const float* b, float* result, size_t n) {
    size_t simd_end = n - (n % 8);
    
    // SIMDå¤„ç†ï¼ˆæ¯æ¬¡å¤„ç†8ä¸ªfloatï¼‰
    for (size_t i = 0; i < simd_end; i += 8) {
        __m256 va = _mm256_load_ps(&a[i]);
        __m256 vb = _mm256_load_ps(&b[i]);
        __m256 vr = _mm256_add_ps(va, vb);
        _mm256_store_ps(&result[i], vr);
    }
    
    // å¤„ç†å‰©ä½™å…ƒç´ 
    for (size_t i = simd_end; i < n; i++) {
        result[i] = a[i] + b[i];
    }
}

// SIMDä¼˜åŒ–çš„å­—ç¬¦ä¸²é•¿åº¦è®¡ç®—
size_t simd_strlen(const char* str) {
    const char* start = str;
    
    // å¯¹é½åˆ°16å­—èŠ‚è¾¹ç•Œ
    while ((uintptr_t)str & 15) {
        if (*str == '\0') return str - start;
        str++;
    }
    
    // SIMDæœç´¢
    __m128i zero = _mm_setzero_si128();
    
    while (1) {
        __m128i data = _mm_load_si128((__m128i*)str);
        __m128i cmp = _mm_cmpeq_epi8(data, zero);
        int mask = _mm_movemask_epi8(cmp);
        
        if (mask != 0) {
            // æ‰¾åˆ°é›¶å­—èŠ‚
            return str - start + __builtin_ctz(mask);
        }
        
        str += 16;
    }
}
```

---

## 5. ç³»ç»Ÿçº§ç¼–ç¨‹å®è·µ

### 5.1 ä¿¡å·å¤„ç†ä¸å¼‚æ­¥ç¼–ç¨‹

```c
#include <signal.h>
#include <setjmp.h>

// ä¿¡å·å®‰å…¨çš„æ—¥å¿—ç³»ç»Ÿ
static volatile sig_atomic_t signal_received = 0;
static volatile sig_atomic_t shutdown_requested = 0;

// ä¿¡å·å¤„ç†å‡½æ•°
void signal_handler(int sig) {
    signal_received = sig;
    
    switch (sig) {
        case SIGINT:
        case SIGTERM:
            shutdown_requested = 1;
            break;
        case SIGUSR1:
            // ç”¨æˆ·å®šä¹‰ä¿¡å·1 - é‡æ–°åŠ è½½é…ç½®
            break;
        case SIGUSR2:
            // ç”¨æˆ·å®šä¹‰ä¿¡å·2 - è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
            break;
    }
}

// å®‰è£…ä¿¡å·å¤„ç†å™¨
void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART; // è‡ªåŠ¨é‡å¯è¢«ä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨
    
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGUSR2, &sa, NULL);
    
    // å¿½ç•¥SIGPIPE
    signal(SIGPIPE, SIG_IGN);
}

// å¼‚æ­¥å®‰å…¨çš„æ—¥å¿—å†™å…¥
void async_safe_log(const char* message) {
    // åªä½¿ç”¨å¼‚æ­¥ä¿¡å·å®‰å…¨çš„å‡½æ•°
    write(STDERR_FILENO, message, strlen(message));
    write(STDERR_FILENO, "\n", 1);
}

// ä¸»äº‹ä»¶å¾ªç¯
void event_loop() {
    setup_signal_handlers();
    
    while (!shutdown_requested) {
        // æ£€æŸ¥ä¿¡å·
        if (signal_received) {
            switch (signal_received) {
                case SIGUSR1:
                    async_safe_log("æ”¶åˆ°é‡æ–°åŠ è½½ä¿¡å·");
                    // é‡æ–°åŠ è½½é…ç½®
                    break;
                case SIGUSR2:
                    async_safe_log("æ”¶åˆ°ç»Ÿè®¡ä¿¡å·");
                    // è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
                    break;
            }
            signal_received = 0;
        }
        
        // æ‰§è¡Œä¸»è¦å·¥ä½œ
        // ...
        
        // çŸ­æš‚ä¼‘çœ 
        usleep(10000); // 10ms
    }
    
    async_safe_log("ç¨‹åºæ­£å¸¸é€€å‡º");
}
```

### 5.2 é«˜æ€§èƒ½I/Oä¸äº‹ä»¶é©±åŠ¨ç¼–ç¨‹

```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>

#define MAX_EVENTS 1000
#define BUFFER_SIZE 4096

// è¿æ¥çŠ¶æ€
typedef struct {
    int fd;
    char* read_buffer;
    size_t read_pos;
    char* write_buffer;
    size_t write_pos;
    size_t write_len;
} connection_t;

// äº‹ä»¶é©±åŠ¨æœåŠ¡å™¨
typedef struct {
    int listen_fd;
    int epoll_fd;
    connection_t* connections;
    size_t max_connections;
    size_t active_connections;
} event_server_t;

// è®¾ç½®éé˜»å¡æ¨¡å¼
int set_nonblocking(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) return -1;
    
    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

// åˆ›å»ºäº‹ä»¶æœåŠ¡å™¨
event_server_t* create_event_server(int port, size_t max_connections) {
    event_server_t* server = malloc(sizeof(event_server_t));
    if (!server) return NULL;
    
    // åˆ›å»ºç›‘å¬å¥—æ¥å­—
    server->listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server->listen_fd == -1) {
        free(server);
        return NULL;
    }
    
    // è®¾ç½®å¥—æ¥å­—é€‰é¡¹
    int opt = 1;
    setsockopt(server->listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // ç»‘å®šåœ°å€
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);
    
    if (bind(server->listen_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        close(server->listen_fd);
        free(server);
        return NULL;
    }
    
    // å¼€å§‹ç›‘å¬
    if (listen(server->listen_fd, SOMAXCONN) == -1) {
        close(server->listen_fd);
        free(server);
        return NULL;
    }
    
    // è®¾ç½®éé˜»å¡
    set_nonblocking(server->listen_fd);
    
    // åˆ›å»ºepollå®ä¾‹
    server->epoll_fd = epoll_create1(EPOLL_CLOEXEC);
    if (server->epoll_fd == -1) {
        close(server->listen_fd);
        free(server);
        return NULL;
    }
    
    // æ·»åŠ ç›‘å¬å¥—æ¥å­—åˆ°epoll
    struct epoll_event ev;
    ev.events = EPOLLIN;
    ev.data.fd = server->listen_fd;
    epoll_ctl(server->epoll_fd, EPOLL_CTL_ADD, server->listen_fd, &ev);
    
    // åˆå§‹åŒ–è¿æ¥æ± 
    server->connections = calloc(max_connections, sizeof(connection_t));
    server->max_connections = max_connections;
    server->active_connections = 0;
    
    return server;
}

// æ¥å—æ–°è¿æ¥
void handle_new_connection(event_server_t* server) {
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    
    int client_fd = accept(server->listen_fd, (struct sockaddr*)&client_addr, &client_len);
    if (client_fd == -1) return;
    
    if (server->active_connections >= server->max_connections) {
        close(client_fd);
        return;
    }
    
    // è®¾ç½®éé˜»å¡
    set_nonblocking(client_fd);
    
    // æ‰¾åˆ°ç©ºé—²è¿æ¥æ§½
    connection_t* conn = NULL;
    for (size_t i = 0; i < server->max_connections; i++) {
        if (server->connections[i].fd == 0) {
            conn = &server->connections[i];
            break;
        }
    }
    
    if (!conn) {
        close(client_fd);
        return;
    }
    
    // åˆå§‹åŒ–è¿æ¥
    conn->fd = client_fd;
    conn->read_buffer = malloc(BUFFER_SIZE);
    conn->write_buffer = malloc(BUFFER_SIZE);
    conn->read_pos = 0;
    conn->write_pos = 0;
    conn->write_len = 0;
    
    // æ·»åŠ åˆ°epoll
    struct epoll_event ev;
    ev.events = EPOLLIN | EPOLLET; // è¾¹ç¼˜è§¦å‘
    ev.data.ptr = conn;
    epoll_ctl(server->epoll_fd, EPOLL_CTL_ADD, client_fd, &ev);
    
    server->active_connections++;
}

// å¤„ç†è¯»äº‹ä»¶
void handle_read(connection_t* conn) {
    while (1) {
        ssize_t bytes = read(conn->fd, conn->read_buffer + conn->read_pos, 
                           BUFFER_SIZE - conn->read_pos - 1);
        
        if (bytes > 0) {
            conn->read_pos += bytes;
            conn->read_buffer[conn->read_pos] = '\0';
            
            // å¤„ç†å®Œæ•´çš„æ¶ˆæ¯
            // è¿™é‡Œç®€å•åœ°å›æ˜¾æ¶ˆæ¯
            if (conn->write_len == 0) {
                memcpy(conn->write_buffer, conn->read_buffer, conn->read_pos);
                conn->write_len = conn->read_pos;
                conn->write_pos = 0;
                conn->read_pos = 0;
                
                // ä¿®æ”¹epolläº‹ä»¶ä¸ºå†™
                struct epoll_event ev;
                ev.events = EPOLLOUT | EPOLLET;
                ev.data.ptr = conn;
                epoll_ctl(epoll_fd, EPOLL_CTL_MOD, conn->fd, &ev);
            }
        } else if (bytes == 0) {
            // è¿æ¥å…³é—­
            break;
        } else {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // æ²¡æœ‰æ›´å¤šæ•°æ®
                break;
            } else {
                // é”™è¯¯
                break;
            }
        }
    }
}

// å¤„ç†å†™äº‹ä»¶
void handle_write(connection_t* conn) {
    while (conn->write_pos < conn->write_len) {
        ssize_t bytes = write(conn->fd, conn->write_buffer + conn->write_pos,
                            conn->write_len - conn->write_pos);
        
        if (bytes > 0) {
            conn->write_pos += bytes;
        } else {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // å†™ç¼“å†²åŒºæ»¡
                break;
            } else {
                // é”™è¯¯
                return;
            }
        }
    }
    
    if (conn->write_pos >= conn->write_len) {
        // å†™å®Œæˆï¼Œåˆ‡æ¢å›è¯»æ¨¡å¼
        conn->write_len = 0;
        conn->write_pos = 0;
        
        struct epoll_event ev;
        ev.events = EPOLLIN | EPOLLET;
        ev.data.ptr = conn;
        epoll_ctl(epoll_fd, EPOLL_CTL_MOD, conn->fd, &ev);
    }
}

// äº‹ä»¶å¾ªç¯
void run_event_server(event_server_t* server) {
    struct epoll_event events[MAX_EVENTS];
    
    while (!shutdown_requested) {
        int nfds = epoll_wait(server->epoll_fd, events, MAX_EVENTS, 1000);
        
        for (int i = 0; i < nfds; i++) {
            if (events[i].data.fd == server->listen_fd) {
                // æ–°è¿æ¥
                handle_new_connection(server);
            } else {
                connection_t* conn = (connection_t*)events[i].data.ptr;
                
                if (events[i].events & EPOLLIN) {
                    handle_read(conn);
                } else if (events[i].events & EPOLLOUT) {
                    handle_write(conn);
                }
            }
        }
    }
}
```

---

## 6. å®é™…é¡¹ç›®ï¼šé«˜æ€§èƒ½ç³»ç»Ÿç›‘æ§å·¥å…·

### 6.1 ç³»ç»Ÿèµ„æºç›‘æ§

```c
// ç³»ç»Ÿç›‘æ§å·¥å…·çš„å®Œæ•´å®ç°
#include <sys/sysinfo.h>
#include <sys/statvfs.h>
#include <dirent.h>

typedef struct {
    double cpu_usage;
    unsigned long memory_total;
    unsigned long memory_used;
    unsigned long memory_free;
    double memory_usage_percent;
    unsigned long disk_total;
    unsigned long disk_used;
    unsigned long disk_free;
    double disk_usage_percent;
    int process_count;
    double load_average[3];
    time_t timestamp;
} system_stats_t;

// CPUä½¿ç”¨ç‡è®¡ç®—
typedef struct {
    unsigned long user, nice, system, idle, iowait, irq, softirq, steal;
} cpu_times_t;

static cpu_times_t prev_cpu_times = {0};

double get_cpu_usage() {
    FILE* fp = fopen("/proc/stat", "r");
    if (!fp) return -1.0;
    
    cpu_times_t current;
    fscanf(fp, "cpu %lu %lu %lu %lu %lu %lu %lu %lu",
           &current.user, &current.nice, &current.system, &current.idle,
           &current.iowait, &current.irq, &current.softirq, &current.steal);
    fclose(fp);
    
    unsigned long prev_total = prev_cpu_times.user + prev_cpu_times.nice + 
                              prev_cpu_times.system + prev_cpu_times.idle +
                              prev_cpu_times.iowait + prev_cpu_times.irq + 
                              prev_cpu_times.softirq + prev_cpu_times.steal;
    
    unsigned long current_total = current.user + current.nice + current.system + 
                                 current.idle + current.iowait + current.irq + 
                                 current.softirq + current.steal;
    
    unsigned long total_diff = current_total - prev_total;
    unsigned long idle_diff = current.idle - prev_cpu_times.idle;
    
    double cpu_usage = 0.0;
    if (total_diff > 0) {
        cpu_usage = 100.0 * (total_diff - idle_diff) / total_diff;
    }
    
    prev_cpu_times = current;
    return cpu_usage;
}

// å†…å­˜ä¿¡æ¯è·å–
void get_memory_info(system_stats_t* stats) {
    struct sysinfo si;
    if (sysinfo(&si) == 0) {
        stats->memory_total = si.totalram * si.mem_unit;
        stats->memory_free = si.freeram * si.mem_unit;
        stats->memory_used = stats->memory_total - stats->memory_free;
        stats->memory_usage_percent = 100.0 * stats->memory_used / stats->memory_total;
        
        stats->load_average[0] = si.loads[0] / 65536.0;
        stats->load_average[1] = si.loads[1] / 65536.0;
        stats->load_average[2] = si.loads[2] / 65536.0;
    }
}

// ç£ç›˜ä¿¡æ¯è·å–
void get_disk_info(system_stats_t* stats, const char* path) {
    struct statvfs vfs;
    if (statvfs(path, &vfs) == 0) {
        stats->disk_total = vfs.f_blocks * vfs.f_frsize;
        stats->disk_free = vfs.f_bavail * vfs.f_frsize;
        stats->disk_used = stats->disk_total - stats->disk_free;
        stats->disk_usage_percent = 100.0 * stats->disk_used / stats->disk_total;
    }
}

// è¿›ç¨‹è®¡æ•°
int count_processes() {
    DIR* proc_dir = opendir("/proc");
    if (!proc_dir) return -1;
    
    int count = 0;
    struct dirent* entry;
    
    while ((entry = readdir(proc_dir)) != NULL) {
        if (strspn(entry->d_name, "0123456789") == strlen(entry->d_name)) {
            count++;
        }
    }
    
    closedir(proc_dir);
    return count;
}

// æ”¶é›†ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯
void collect_system_stats(system_stats_t* stats) {
    stats->timestamp = time(NULL);
    stats->cpu_usage = get_cpu_usage();
    get_memory_info(stats);
    get_disk_info(stats, "/");
    stats->process_count = count_processes();
}

// æ ¼å¼åŒ–è¾“å‡ºç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯
void print_system_stats(const system_stats_t* stats) {
    printf("\n=== ç³»ç»Ÿç›‘æ§æŠ¥å‘Š ===\n");
    printf("æ—¶é—´: %s", ctime(&stats->timestamp));
    printf("CPUä½¿ç”¨ç‡: %.2f%%\n", stats->cpu_usage);
    printf("å†…å­˜ä½¿ç”¨: %.2f%% (%lu MB / %lu MB)\n", 
           stats->memory_usage_percent,
           stats->memory_used / (1024 * 1024),
           stats->memory_total / (1024 * 1024));
    printf("ç£ç›˜ä½¿ç”¨: %.2f%% (%lu GB / %lu GB)\n",
           stats->disk_usage_percent,
           stats->disk_used / (1024 * 1024 * 1024),
           stats->disk_total / (1024 * 1024 * 1024));
    printf("è¿›ç¨‹æ•°é‡: %d\n", stats->process_count);
    printf("è´Ÿè½½å¹³å‡: %.2f %.2f %.2f\n", 
           stats->load_average[0], stats->load_average[1], stats->load_average[2]);
    printf("========================\n");
}
```

### 6.2 æ€§èƒ½åˆ†æä¸å‘Šè­¦ç³»ç»Ÿ

```c
// å‘Šè­¦ç³»ç»Ÿ
typedef struct {
    double cpu_threshold;
    double memory_threshold;
    double disk_threshold;
    double load_threshold;
    int consecutive_alerts;
    int max_consecutive_alerts;
} alert_config_t;

typedef struct {
    int cpu_alert_count;
    int memory_alert_count;
    int disk_alert_count;
    int load_alert_count;
    time_t last_alert_time;
} alert_state_t;

// æ£€æŸ¥å‘Šè­¦æ¡ä»¶
void check_alerts(const system_stats_t* stats, alert_config_t* config, alert_state_t* state) {
    time_t current_time = time(NULL);
    int alerts_triggered = 0;
    
    // CPUå‘Šè­¦
    if (stats->cpu_usage > config->cpu_threshold) {
        state->cpu_alert_count++;
        if (state->cpu_alert_count >= config->max_consecutive_alerts) {
            printf("ğŸš¨ CPUå‘Šè­¦: ä½¿ç”¨ç‡ %.2f%% è¶…è¿‡é˜ˆå€¼ %.2f%%\n", 
                   stats->cpu_usage, config->cpu_threshold);
            alerts_triggered++;
        }
    } else {
        state->cpu_alert_count = 0;
    }
    
    // å†…å­˜å‘Šè­¦
    if (stats->memory_usage_percent > config->memory_threshold) {
        state->memory_alert_count++;
        if (state->memory_alert_count >= config->max_consecutive_alerts) {
            printf("ğŸš¨ å†…å­˜å‘Šè­¦: ä½¿ç”¨ç‡ %.2f%% è¶…è¿‡é˜ˆå€¼ %.2f%%\n", 
                   stats->memory_usage_percent, config->memory_threshold);
            alerts_triggered++;
        }
    } else {
        state->memory_alert_count = 0;
    }
    
    // ç£ç›˜å‘Šè­¦
    if (stats->disk_usage_percent > config->disk_threshold) {
        state->disk_alert_count++;
        if (state->disk_alert_count >= config->max_consecutive_alerts) {
            printf("ğŸš¨ ç£ç›˜å‘Šè­¦: ä½¿ç”¨ç‡ %.2f%% è¶…è¿‡é˜ˆå€¼ %.2f%%\n", 
                   stats->disk_usage_percent, config->disk_threshold);
            alerts_triggered++;
        }
    } else {
        state->disk_alert_count = 0;
    }
    
    // è´Ÿè½½å‘Šè­¦
    if (stats->load_average[0] > config->load_threshold) {
        state->load_alert_count++;
        if (state->load_alert_count >= config->max_consecutive_alerts) {
            printf("ğŸš¨ è´Ÿè½½å‘Šè­¦: 1åˆ†é’Ÿè´Ÿè½½ %.2f è¶…è¿‡é˜ˆå€¼ %.2f\n", 
                   stats->load_average[0], config->load_threshold);
            alerts_triggered++;
        }
    } else {
        state->load_alert_count = 0;
    }
    
    if (alerts_triggered > 0) {
        state->last_alert_time = current_time;
    }
}

// å†å²æ•°æ®è®°å½•
#define MAX_HISTORY 1440 // 24å°æ—¶ï¼Œæ¯åˆ†é’Ÿä¸€ä¸ªæ•°æ®ç‚¹

typedef struct {
    system_stats_t data[MAX_HISTORY];
    int current_index;
    int count;
} history_buffer_t;

void add_to_history(history_buffer_t* history, const system_stats_t* stats) {
    history->data[history->current_index] = *stats;
    history->current_index = (history->current_index + 1) % MAX_HISTORY;
    if (history->count < MAX_HISTORY) {
        history->count++;
    }
}

// è®¡ç®—ç»Ÿè®¡æ‘˜è¦
void calculate_summary(const history_buffer_t* history, int minutes) {
    if (history->count == 0) return;
    
    int samples = (minutes < history->count) ? minutes : history->count;
    double cpu_sum = 0, memory_sum = 0, disk_sum = 0;
    double cpu_max = 0, memory_max = 0, disk_max = 0;
    
    for (int i = 0; i < samples; i++) {
        int index = (history->current_index - 1 - i + MAX_HISTORY) % MAX_HISTORY;
        const system_stats_t* stats = &history->data[index];
        
        cpu_sum += stats->cpu_usage;
        memory_sum += stats->memory_usage_percent;
        disk_sum += stats->disk_usage_percent;
        
        if (stats->cpu_usage > cpu_max) cpu_max = stats->cpu_usage;
        if (stats->memory_usage_percent > memory_max) memory_max = stats->memory_usage_percent;
        if (stats->disk_usage_percent > disk_max) disk_max = stats->disk_usage_percent;
    }
    
    printf("\n=== %dåˆ†é’Ÿç»Ÿè®¡æ‘˜è¦ ===\n", minutes);
    printf("CPU: å¹³å‡ %.2f%%, å³°å€¼ %.2f%%\n", cpu_sum / samples, cpu_max);
    printf("å†…å­˜: å¹³å‡ %.2f%%, å³°å€¼ %.2f%%\n", memory_sum / samples, memory_max);
    printf("ç£ç›˜: å¹³å‡ %.2f%%, å³°å€¼ %.2f%%\n", disk_sum / samples, disk_max);
    printf("====================\n");
}
```

---

## 7. ä¸»å‡½æ•°ä¸ç»¼åˆæ¼”ç¤º

```c
// ä¸»å‡½æ•° - ç»¼åˆæ¼”ç¤ºæ‰€æœ‰åŠŸèƒ½
int main() {
    printf("=== Cè¯­è¨€é«˜çº§ç‰¹æ€§ä¸ç³»ç»Ÿç¼–ç¨‹ç»¼åˆæ¼”ç¤º ===\n\n");
    
    // 1. å†…å­˜å¸ƒå±€åˆ†æ
    printf("1. å†…å­˜å¸ƒå±€åˆ†æ:\n");
    analyze_memory_layout();
    
    // 2. å†…å­˜å¯¹é½åˆ†æ
    printf("\n2. å†…å­˜å¯¹é½åˆ†æ:\n");
    analyze_memory_alignment();
    
    // 3. å†…å­˜æ± æµ‹è¯•
    printf("\n3. å†…å­˜æ± æµ‹è¯•:\n");
    memory_pool_t* pool = create_memory_pool(1024 * 1024); // 1MB
    if (pool) {
        void* ptr1 = pool_malloc(pool, 100);
        void* ptr2 = pool_malloc(pool, 200);
        void* ptr3 = pool_malloc(pool, 300);
        
        print_pool_stats(pool);
        
        pool_free(pool, ptr2);
        print_pool_stats(pool);
        
        destroy_memory_pool(pool);
    }
    
    // 4. æœªå®šä¹‰è¡Œä¸ºæ£€æµ‹
    printf("\n4. æœªå®šä¹‰è¡Œä¸ºæ£€æµ‹:\n");
    int result;
    if (safe_add(INT_MAX, 1, &result)) {
        printf("å®‰å…¨åŠ æ³•æˆåŠŸ: %d\n", result);
    } else {
        printf("æ£€æµ‹åˆ°æ•´æ•°æº¢å‡º\n");
    }
    
    // 5. åŸå­æ“ä½œæµ‹è¯•
     printf("\n5. åŸå­æ“ä½œæµ‹è¯•:\n");
     test_atomic_operations();
     
     // 6. ç³»ç»Ÿç›‘æ§æ¼”ç¤º
     printf("\n6. ç³»ç»Ÿç›‘æ§æ¼”ç¤º:\n");
     system_stats_t stats;
     collect_system_stats(&stats);
     print_system_stats(&stats);
     
     // 7. å‘Šè­¦ç³»ç»Ÿæµ‹è¯•
     printf("\n7. å‘Šè­¦ç³»ç»Ÿæµ‹è¯•:\n");
     alert_config_t alert_config = {
         .cpu_threshold = 80.0,
         .memory_threshold = 85.0,
         .disk_threshold = 90.0,
         .load_threshold = 2.0,
         .max_consecutive_alerts = 3
     };
     
     alert_state_t alert_state = {0};
     check_alerts(&stats, &alert_config, &alert_state);
     
     // 8. å†å²æ•°æ®åˆ†æ
     printf("\n8. å†å²æ•°æ®åˆ†æ:\n");
     history_buffer_t history = {0};
     add_to_history(&history, &stats);
     calculate_summary(&history, 1);
     
     // 9. å†…å­˜æ³„æ¼æ£€æµ‹
     printf("\n9. å†…å­˜æ³„æ¼æ£€æµ‹:\n");
     void* test_ptr1 = SAFE_MALLOC(100);
     void* test_ptr2 = SAFE_MALLOC(200);
     SAFE_FREE(test_ptr1);
     // æ•…æ„ä¸é‡Šæ”¾test_ptr2æ¥æ¼”ç¤ºå†…å­˜æ³„æ¼æ£€æµ‹
     check_memory_leaks();
     
     // 10. æ€§èƒ½ä¼˜åŒ–æ¼”ç¤º
     printf("\n10. æ€§èƒ½ä¼˜åŒ–æ¼”ç¤º:\n");
     const size_t array_size = 1000000;
     float* a = aligned_alloc(32, array_size * sizeof(float));
     float* b = aligned_alloc(32, array_size * sizeof(float));
     float* result = aligned_alloc(32, array_size * sizeof(float));
     
     // åˆå§‹åŒ–æ•°ç»„
     for (size_t i = 0; i < array_size; i++) {
         a[i] = (float)i;
         b[i] = (float)(i + 1);
     }
     
     // æµ‹é‡SIMDä¼˜åŒ–çš„æ€§èƒ½
     clock_t start = clock();
     simd_vector_add(a, b, result, array_size);
     clock_t end = clock();
     
     double simd_time = ((double)(end - start)) / CLOCKS_PER_SEC;
     printf("SIMDå‘é‡åŠ æ³•æ—¶é—´: %.6f ç§’\n", simd_time);
     
     // éªŒè¯ç»“æœ
     printf("å‰10ä¸ªç»“æœ: ");
     for (int i = 0; i < 10; i++) {
         printf("%.1f ", result[i]);
     }
     printf("\n");
     
     free(a);
     free(b);
     free(result);
     
     printf("\n=== æ¼”ç¤ºå®Œæˆ ===\n");
     printf("æœ¬ç« å±•ç¤ºäº†Cè¯­è¨€é«˜çº§ç‰¹æ€§çš„å®é™…åº”ç”¨ï¼ŒåŒ…æ‹¬:\n");
     printf("- å†…å­˜æ¨¡å‹æ·±åº¦åˆ†æä¸ä¼˜åŒ–æŠ€æœ¯\n");
     printf("- æœªå®šä¹‰è¡Œä¸ºæ£€æµ‹ä¸é¢„é˜²ç­–ç•¥\n");
     printf("- å¤šçº¿ç¨‹ç¼–ç¨‹ä¸åŒæ­¥æœºåˆ¶\n");
     printf("- ç¼–è¯‘å™¨ä¼˜åŒ–ä¸æ€§èƒ½è°ƒä¼˜\n");
     printf("- ç³»ç»Ÿçº§ç¼–ç¨‹å®è·µ\n");
     printf("- é«˜æ€§èƒ½ç³»ç»Ÿç›‘æ§å·¥å…·å¼€å‘\n");
     
     return 0;
 }
```

---

## æ€»ç»“ä¸è¿›é˜¶æŒ‡å—

### æ ¸å¿ƒçŸ¥è¯†ç‚¹å›é¡¾

1. **å†…å­˜æ¨¡å‹æŒæ¡**
   - æ·±å…¥ç†è§£Cè¯­è¨€æŠ½è±¡æœºå™¨æ¨¡å‹
   - æŒæ¡å†…å­˜å¯¹é½ä¸æ•°æ®ç»“æ„ä¼˜åŒ–
   - å®ç°é«˜æ•ˆçš„å†…å­˜ç®¡ç†ç­–ç•¥

2. **æœªå®šä¹‰è¡Œä¸ºé˜²èŒƒ**
   - è¯†åˆ«å¸¸è§çš„æœªå®šä¹‰è¡Œä¸ºæ¨¡å¼
   - ä½¿ç”¨é™æ€å’ŒåŠ¨æ€æ£€æµ‹å·¥å…·
   - å»ºç«‹é˜²å¾¡æ€§ç¼–ç¨‹ä¹ æƒ¯

3. **å¤šçº¿ç¨‹ç¼–ç¨‹ç²¾é€š**
   - ç†è§£åŸå­æ“ä½œä¸å†…å­˜åº
   - å®ç°é«˜çº§åŒæ­¥åŸè¯­
   - æŒæ¡æ— é”ç¼–ç¨‹æŠ€æœ¯

4. **æ€§èƒ½ä¼˜åŒ–å®è·µ**
   - ç†è§£ç¼–è¯‘å™¨ä¼˜åŒ–åŸç†
   - ä½¿ç”¨SIMDæŒ‡ä»¤ä¼˜åŒ–
   - å®ç°ç¼“å­˜å‹å¥½çš„ç®—æ³•

5. **ç³»ç»Ÿç¼–ç¨‹èƒ½åŠ›**
   - æŒæ¡ä¿¡å·å¤„ç†æœºåˆ¶
   - å®ç°é«˜æ€§èƒ½I/Oç³»ç»Ÿ
   - å¼€å‘ç³»ç»Ÿç›‘æ§å·¥å…·

### å­¦ä¹ å»ºè®®

1. **ç†è®ºä¸å®è·µç»“åˆ**
   - æ·±å…¥ç ”è¯»Cè¯­è¨€æ ‡å‡†æ–‡æ¡£
   - åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨æ‰€å­¦çŸ¥è¯†
   - åˆ†æå¼€æºé¡¹ç›®çš„å®ç°æŠ€å·§

2. **å·¥å…·é“¾æŒæ¡**
   - ç†Ÿç»ƒä½¿ç”¨è°ƒè¯•å’Œåˆ†æå·¥å…·
   - æŒæ¡æ€§èƒ½æµ‹è¯•æ–¹æ³•
   - å­¦ä¼šä½¿ç”¨é™æ€åˆ†æå·¥å…·

3. **æŒç»­å­¦ä¹ **
   - å…³æ³¨è®¡ç®—æœºä½“ç³»ç»“æ„å‘å±•
   - å­¦ä¹ æ“ä½œç³»ç»Ÿå†…æ ¸åŸç†
   - ç ”ç©¶ç¼–è¯‘å™¨å®ç°æŠ€æœ¯

### è¿›é˜¶æ–¹å‘

1. **ç³»ç»Ÿè½¯ä»¶å¼€å‘**
   - æ“ä½œç³»ç»Ÿå†…æ ¸å¼€å‘
   - æ•°æ®åº“å¼•æ“å®ç°
   - ç½‘ç»œåè®®æ ˆå¼€å‘

2. **é«˜æ€§èƒ½è®¡ç®—**
   - å¹¶è¡Œç®—æ³•è®¾è®¡
   - GPUç¼–ç¨‹æŠ€æœ¯
   - åˆ†å¸ƒå¼ç³»ç»Ÿå¼€å‘

3. **åµŒå…¥å¼ç³»ç»Ÿ**
   - å®æ—¶ç³»ç»Ÿç¼–ç¨‹
   - ç¡¬ä»¶æŠ½è±¡å±‚è®¾è®¡
   - ä½åŠŸè€—ä¼˜åŒ–æŠ€æœ¯

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œä½ å·²ç»æŒæ¡äº†Cè¯­è¨€çš„é«˜çº§ç‰¹æ€§å’Œç³»ç»Ÿç¼–ç¨‹æŠ€èƒ½ã€‚è¿™äº›çŸ¥è¯†å°†ä¸ºä½ åœ¨ç³»ç»Ÿè½¯ä»¶å¼€å‘ã€é«˜æ€§èƒ½è®¡ç®—å’ŒåµŒå…¥å¼ç³»ç»Ÿç­‰é¢†åŸŸçš„æ·±å…¥å‘å±•å¥ å®šåšå®åŸºç¡€ã€‚ç»§ç»­å®è·µå’Œæ¢ç´¢ï¼Œä½ å°†èƒ½å¤Ÿå¼€å‘å‡ºæ›´åŠ é«˜æ•ˆã€å¯é çš„ç³»ç»Ÿçº§è½¯ä»¶ã€‚

