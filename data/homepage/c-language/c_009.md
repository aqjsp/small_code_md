# 高级主题Ⅰ：内存模型、未定义行为与并发基础

目标：理解C的抽象机器与内存模型，识别未定义/未指定/实现定义行为；了解C11原子与线程基础概念。

## 1. 抽象机器与对象模型
- 对象与标量、有效类型（effective type）
- 别名规则（strict aliasing）：不同类型指针别名可能触发未定义行为；char例外
- 对齐要求与未对齐访问风险（实现相关）

## 2. 未定义/未指定/实现定义
- 未定义（UB）：行为不可预测，例如越界访问、未初始化读取、数据竞争
- 未指定：编译器可在若干可能中选择，例如函数参数求值顺序
- 实现定义：由实现规定，如基本类型大小、位域布局

## 3. 序列规则与求值顺序
- C11的序列规则，避免对同一对象在两个序列点之间多次修改与读取依赖

## 4. C11 并发基础（概览）
- 线程：<threads.h>（可选支持），thrd_create/join
- 原子：<stdatomic.h>，atomic_int、内存序（memory order）
- 同步：互斥 mtx_t、条件变量 cnd_t（可选支持）
- 多数项目使用POSIX线程或平台线程库；C11线程在部分实现中缺失

## 5. 实战建议
- 禁止UB：启用编译器警告、地址/未定义行为/线程检查器
- 明确别名与对齐；在优化与性能敏感代码中使用restrict并记录不变量

## 6. 练习
- 编写演示strict aliasing触发问题的代码并用-fno-strict-aliasing对比。
- 使用stdatomic实现无锁计数器（理解顺序一致性与释放-获取）。
- 对未初始化读取进行静态/动态检测（如valgrind/asan）。

## 更多示例

示例A：数据竞争（未定义行为）
```c
#include <stdio.h>
#include <threads.h>
int x = 0; // 非原子
int writer(void* _){ for(int i=0;i<100000;i++) x++; return 0; }
int reader(void* _){ for(int i=0;i<100000;i++) if(x<0) puts("impossible"); return 0; }
int main(void){ thrd_t t1,t2; thrd_create(&t1, writer, 0); thrd_create(&t2, reader, 0);
    thrd_join(t1,0); thrd_join(t2,0); }
// 说明：两个线程并发读写非原子 x，存在数据竞争，行为未定义。
```

示例B：使用原子变量（顺序一致性）
```c
#include <stdatomic.h>
#include <threads.h>
#include <stdio.h>
atomic_int x; // 默认是 _Atomic int
int writer(void* _){ for(int i=0;i<100000;i++) atomic_fetch_add_explicit(&x, 1, memory_order_seq_cst); return 0; }
int reader(void* _){ for(int i=0;i<100000;i++) { int v = atomic_load_explicit(&x, memory_order_seq_cst); if(v<0) puts("impossible"); } return 0; }
int main(void){ atomic_init(&x, 0); thrd_t t1,t2; thrd_create(&t1, writer, 0); thrd_create(&t2, reader, 0); thrd_join(t1,0); thrd_join(t2,0); printf("x=%d\n", atomic_load(&x)); }
```

示例C：发布-订阅（release/acquire）
```c
#include <stdatomic.h>
#include <threads.h>
#include <stdlib.h>
#include <stdio.h>

typedef struct { int data; } Payload;
_Atomic(Payload*) gp = NULL;

int producer(void* _){
    Payload* p = malloc(sizeof *p);
    p->data = 42;                     // 普通写
    atomic_store_explicit(&gp, p, memory_order_release); // 发布
    return 0;
}

int consumer(void* _){
    Payload* p;
    while((p = atomic_load_explicit(&gp, memory_order_acquire)) == NULL) { /* spin */ }
    printf("data=%d\n", p->data);   // 通过acquire观察到发布前的写
    free(p);
    return 0;
}

int main(void){ thrd_t t1,t2; thrd_create(&t1, producer, 0); thrd_create(&t2, consumer, 0); thrd_join(t1,0); thrd_join(t2,0); }
```

示例D：atomic_flag 自旋锁
```c
#include <stdatomic.h>
#include <threads.h>
#include <stdio.h>

atomic_flag lock = ATOMIC_FLAG_INIT;

void lock_acquire(void){ while(atomic_flag_test_and_set_explicit(&lock, memory_order_acquire)) { thrd_yield(); } }
void lock_release(void){ atomic_flag_clear_explicit(&lock, memory_order_release); }
```

示例E：栅栏（fence）
```c
#include <stdatomic.h>
// 用于与非原子或I/O等配合的顺序约束
void publish(){
    // 写共享数据...
    atomic_thread_fence(memory_order_release);
    // 写标志位...
}
```

## 练习参考答案（节选）
- 识别数据竞争：任意两个线程对同一标量对象其中至少一个为写且未使用原子或同步，属于数据竞争，行为未定义；应将该对象改为原子或使用互斥/条件变量保护。
- 选择内存序：默认使用memory_order_seq_cst最安全；在发布-订阅场景使用release/acquire；仅需单向依赖可考虑release/consume（实践中consume支持较差，不建议）。
- 自旋与退避：在自旋锁中加入thrd_yield或指数退避减少总线争用；长临界区使用互斥更合适。

## 参考资料
- C11/C17 标准：内存模型、原子类型、原子操作与内存序章节。
- 《CPP/C Concurrency in Action》相关章节（尽管书名偏C++，概念可借鉴）。
- 编译器文档：GCC/Clang 对 C11 原子与内存序的实现说明与最佳实践。