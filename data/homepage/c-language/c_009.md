# C语言高级主题：内存模型与并发编程

## 学习目标

通过本章学习，你将掌握：
- C语言内存模型的基本概念和实现原理
- 未定义行为的识别和预防方法
- 多线程编程的基础知识和同步机制
- 原子操作和内存序的使用技巧
- 性能优化的策略和实践方法

## 1. C语言内存模型

### 1.1 抽象机器模型

C语言抽象机器模型定义了程序执行的语义框架。 C程序开发并编译完成后，要载入内存才能运行，变量名、函数名都会对应内存中的一块区域。内存中运行着很多程序，我们的程序只占用一部分空间，这部分空间又可以细分为以下的区域：

| 内存分区 | 说明 |
|---------|------|
| 程序代码区(code area) | 存放函数体的二进制代码 |
| 静态数据区(data area) | 也称全局数据区，包含全局变量、静态变量、一般常量、字符串常量 |
| 堆区(heap area) | 一般由程序员分配和释放，malloc()、calloc()、free()等函数操作的就是这块内存 |
| 栈区(stack area) | 由系统自动分配释放，存放函数的参数值、局部变量的值等 |
| 命令行参数区 | 存放命令行参数和环境变量的值，如通过main()函数传递的值 |

```c
#include <stdio.h>
#include <stdatomic.h>

// 内存分区演示
int global_var = 10;        // 静态数据区（已初始化全局变量）
int uninitialized_global;  // 静态数据区（未初始化全局变量，默认为0）
static int static_var = 20; // 静态数据区（静态变量）

void memory_layout_demo() {
    int local_var = 30;     // 栈区（局部变量）
    static int local_static = 40; // 静态数据区（局部静态变量）
    char *str = "Hello";    // str在栈区，"Hello"在常量区
    
    // 堆区分配
    int *heap_ptr = malloc(sizeof(int));
    *heap_ptr = 50;
    
    printf("全局变量: %d (地址: %p)\n", global_var, &global_var);
    printf("未初始化全局变量: %d (地址: %p)\n", uninitialized_global, &uninitialized_global);
    printf("局部变量: %d (地址: %p)\n", local_var, &local_var);
    printf("堆分配: %d (地址: %p)\n", *heap_ptr, heap_ptr);
    
    free(heap_ptr);
}

// 顺序点演示
void sequence_points_demo() {
    int i = 0;
    
    // 明确定义的行为
    i = i + 1;  // 顺序点在赋值操作完成后
    
    // 未定义行为（避免）
    // i = ++i + i++;  // 错误：在顺序点之间多次修改同一对象
    
    // 正确的写法
    i++;
    i = i + i;
    
    printf("顺序点演示：i = %d\n", i);
}
```

### 1.2 内存一致性模型

C11引入了内存模型，支持多线程编程：

```c
#include <threads.h>

// 原子操作和内存序
atomic_int shared_data = ATOMIC_VAR_INIT(0);
atomic_int sync_flag = ATOMIC_VAR_INIT(0);

// 释放-获取同步
void release_acquire_pattern() {
    // 写入线程（释放语义）
    shared_data = 42;
    atomic_store_explicit(&sync_flag, 1, memory_order_release);
    
    // 读取线程（获取语义）
    while (atomic_load_explicit(&sync_flag, memory_order_acquire) == 0) {
        // 等待同步
    }
    int value = shared_data;  // 保证能看到42
    printf("同步读取到的值: %d\n", value);
}
```

## 2. 未定义行为的识别与避免

### 2.1 常见未定义行为

未定义行为是C语言中最危险的陷阱之一，它可能导致程序崩溃、数据损坏或安全漏洞。以下是一些常见的未定义行为及其避免方法：

```c
#include <limits.h>
#include <string.h>

void avoid_undefined_behavior() {
    // 1. 有符号整数溢出
    int max_int = INT_MAX;
    // 错误：int overflow = max_int + 1;  // UB
    
    // 正确：检查溢出
    if (max_int > INT_MAX - 1) {
        printf("溢出检测\n");
    }
    
    // 2. 数组越界
    int array[5] = {1, 2, 3, 4, 5};
    // 错误：int out_of_bounds = array[10];  // UB
    
    // 正确：边界检查
    int index = 3;
    if (index >= 0 && index < 5) {
        printf("安全访问: %d\n", array[index]);
    }
    
    // 3. 空指针解引用
    int *ptr = NULL;
    // 错误：int value = *ptr;  // UB
    
    // 正确：空指针检查
    if (ptr != NULL) {
        printf("安全解引用: %d\n", *ptr);
    }
    
    // 4. 指针没有指向合法内存
    struct student {
        char *name;
        int score;
    } stu;
    
    // 错误：strcpy(stu.name, "Jimy");  // UB：name指针未初始化
    
    // 正确：为name分配内存
    stu.name = malloc(20);
    if (stu.name != NULL) {
        strcpy(stu.name, "Jimy");
        stu.score = 99;
        free(stu.name);
    }
    
    // 5. 内存分配大小不足
    char *p1 = "abcdefg";
    // 错误：char *p2 = malloc(strlen(p1));  // 忘记'\0'
    
    // 正确：包含字符串结束符
    char *p2 = malloc(strlen(p1) + 1);
    if (p2 != NULL) {
        strcpy(p2, p1);
        free(p2);
    }
}
```

### 实现定义行为

```c
void implementation_defined_examples() {
    // char的符号性是实现定义的
    char c = 200;
    printf("char值: %d (可能是有符号或无符号)\n", c);
    
    // 右移负数是实现定义的
    int negative = -8;
    int shifted = negative >> 1;
    printf("负数右移: %d >> 1 = %d\n", negative, shifted);
}
```

## 3. 现代C并发编程

### 线程基础

```c
#include <threads.h>
#include <time.h>

// 线程函数
int worker_thread(void *arg) {
    int *data = (int *)arg;
    printf("工作线程处理数据: %d\n", *data);
    
    // 模拟工作
    struct timespec ts = {0, 100000000};  // 100ms
    thrd_sleep(&ts, NULL);
    
    return 0;
}

void basic_threading() {
    thrd_t thread;
    int data = 42;
    
    // 创建线程
    if (thrd_create(&thread, worker_thread, &data) != thrd_success) {
        printf("线程创建失败\n");
        return;
    }
    
    // 等待线程完成
    int result;
    thrd_join(thread, &result);
    printf("线程完成，返回值: %d\n", result);
}
```

### 互斥锁和条件变量

如果多个线程访问相同的数据，并且它们中至少有一个修改了数据，那么对共享数据的所有访问必须同步以防止数据竞争。互相排斥（mutex exclusion）技术，简称为互斥（mutex），它用于防止多个线程同时访问共享资源。

在C程序中，一个互斥采用类型为`mtx_t`的对象表示，它能在一段时间内被一个线程锁定，而其他线程必须等待，直到它被解锁。最重要的互斥函数有：

- `int mtx_init(mtx_t *mtx, int mutextype)`：创建一个互斥
- `void mtx_destroy(mtx_t *mtx)`：销毁互斥并释放资源
- `int mtx_lock(mtx_t *mtx)`：阻塞调用线程直到获得互斥
- `int mtx_unlock(mtx_t *mtx)`：释放互斥

```c
// 互斥锁和条件变量
typedef struct {
    mtx_t mutex;
    cnd_t condition;
    int ready;
    int data;
} ThreadSafeData;

int init_thread_safe_data(ThreadSafeData *tsd) {
    if (mtx_init(&tsd->mutex, mtx_plain) != thrd_success) {
        return -1;
    }
    if (cnd_init(&tsd->condition) != thrd_success) {
        mtx_destroy(&tsd->mutex);
        return -1;
    }
    tsd->ready = 0;
    tsd->data = 0;
    return 0;
}

// 生产者
int producer(void *arg) {
    ThreadSafeData *tsd = (ThreadSafeData *)arg;
    
    struct timespec ts = {0, 100000000};
    thrd_sleep(&ts, NULL);
    
    mtx_lock(&tsd->mutex);
    tsd->data = 42;
    tsd->ready = 1;
    cnd_signal(&tsd->condition);  // 通知等待的消费者
    mtx_unlock(&tsd->mutex);
    
    return 0;
}

// 消费者
int consumer(void *arg) {
    ThreadSafeData *tsd = (ThreadSafeData *)arg;
    
    mtx_lock(&tsd->mutex);
    while (!tsd->ready) {
        cnd_wait(&tsd->condition, &tsd->mutex);  // 等待生产者通知
    }
    printf("消费者接收到数据: %d\n", tsd->data);
    mtx_unlock(&tsd->mutex);
    
    return 0;
}

// 使用示例
void producer_consumer_demo() {
    ThreadSafeData tsd;
    if (init_thread_safe_data(&tsd) != 0) {
        printf("初始化失败\n");
        return;
    }
    
    thrd_t producer_thread, consumer_thread;
    
    // 创建消费者和生产者线程
    thrd_create(&consumer_thread, consumer, &tsd);
    thrd_create(&producer_thread, producer, &tsd);
    
    // 等待线程完成
    thrd_join(producer_thread, NULL);
    thrd_join(consumer_thread, NULL);
    
    // 清理资源
    mtx_destroy(&tsd.mutex);
    cnd_destroy(&tsd.condition);
}
```

### 原子操作

原子对象（atomic object）是一个可通过原子操作（atomic operation）被读取或修改的对象。原子操作是指不能被并行线程中断的操作。在C11标准下，可以使用类型限定符`_Atomic`声明一个原子对象。

读取或写入一个原子对象是一个原子操作，也就是说它是不能被中断的操作。这意味着：不同的线程可以同时访问一个原子对象而不引起竞态条件。对于每个原子对象，对象的所有修改以一个确定的全局化次序执行，这称为该对象的修改次序（modification order）。

```c
// 无锁编程示例
atomic_int counter = ATOMIC_VAR_INIT(0);

int atomic_increment_thread(void *arg) {
    int iterations = *(int *)arg;
    
    for (int i = 0; i < iterations; i++) {
        // 原子递增操作，线程安全
        atomic_fetch_add(&counter, 1);
    }
    
    return 0;
}

void atomic_operations_demo() {
    const int num_threads = 4;
    const int iterations = 1000;
    thrd_t threads[num_threads];
    
    // 创建多个线程同时递增计数器
    for (int i = 0; i < num_threads; i++) {
        thrd_create(&threads[i], atomic_increment_thread, (void *)&iterations);
    }
    
    // 等待所有线程完成
    for (int i = 0; i < num_threads; i++) {
        thrd_join(threads[i], NULL);
    }
    
    printf("原子计数器最终值: %d (期望: %d)\n", 
           atomic_load(&counter), num_threads * iterations);
}

// 原子操作的内存序
void memory_ordering_demo() {
    atomic_int data = ATOMIC_VAR_INIT(0);
    atomic_int flag = ATOMIC_VAR_INIT(0);
    
    // 写入线程（释放语义）
    atomic_store(&data, 42);
    atomic_store_explicit(&flag, 1, memory_order_release);
    
    // 读取线程（获取语义）
    while (atomic_load_explicit(&flag, memory_order_acquire) == 0) {
        // 等待同步
    }
    int value = atomic_load(&data);  // 保证能看到42
    printf("同步读取到的值: %d\n", value);
}
```

## 4. 性能优化技巧

### 编译器优化

```c
// 内联函数优化
static inline int fast_multiply_by_power_of_2(int x, int power) {
    return x << power;  // 位移比乘法快
}

// 分支预测优化
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)

int optimized_search(int *array, int size, int target) {
    for (int i = 0; i < size; i++) {
        if (unlikely(array[i] == target)) {  // 提示编译器这个分支不太可能
            return i;
        }
    }
    return -1;
}
```

### 内存访问优化

```c
// 缓存友好的数据结构
typedef struct {
    int frequently_used_data[4];  // 经常访问的数据放在一起
    char padding[48];             // 填充到缓存行大小
    int rarely_used_data[4];      // 很少访问的数据
} CacheFriendlyStruct;

// 数据局部性优化
void matrix_multiply_optimized(int n, int a[n][n], int b[n][n], int c[n][n]) {
    // 分块矩阵乘法，提高缓存命中率
    const int block_size = 64;
    
    for (int ii = 0; ii < n; ii += block_size) {
        for (int jj = 0; jj < n; jj += block_size) {
            for (int kk = 0; kk < n; kk += block_size) {
                // 处理块
                int max_i = (ii + block_size < n) ? ii + block_size : n;
                int max_j = (jj + block_size < n) ? jj + block_size : n;
                int max_k = (kk + block_size < n) ? kk + block_size : n;
                
                for (int i = ii; i < max_i; i++) {
                    for (int j = jj; j < max_j; j++) {
                        for (int k = kk; k < max_k; k++) {
                            c[i][j] += a[i][k] * b[k][j];
                        }
                    }
                }
            }
        }
    }
}
```

## 5. 综合示例：线程池

```c
#include <stdlib.h>

#define MAX_THREADS 8
#define MAX_QUEUE_SIZE 100

typedef struct {
    void (*function)(void *);
    void *argument;
} Task;

typedef struct {
    thrd_t threads[MAX_THREADS];
    Task task_queue[MAX_QUEUE_SIZE];
    int queue_front;
    int queue_rear;
    int queue_size;
    mtx_t queue_mutex;
    cnd_t queue_condition;
    int shutdown;
} ThreadPool;

// 工作线程函数
int worker_thread_func(void *arg) {
    ThreadPool *pool = (ThreadPool *)arg;
    
    while (1) {
        mtx_lock(&pool->queue_mutex);
        
        // 等待任务或关闭信号
        while (pool->queue_size == 0 && !pool->shutdown) {
            cnd_wait(&pool->queue_condition, &pool->queue_mutex);
        }
        
        if (pool->shutdown) {
            mtx_unlock(&pool->queue_mutex);
            break;
        }
        
        // 获取任务
        Task task = pool->task_queue[pool->queue_front];
        pool->queue_front = (pool->queue_front + 1) % MAX_QUEUE_SIZE;
        pool->queue_size--;
        
        mtx_unlock(&pool->queue_mutex);
        
        // 执行任务
        task.function(task.argument);
    }
    
    return 0;
}

// 初始化线程池
ThreadPool* create_thread_pool(int num_threads) {
    ThreadPool *pool = malloc(sizeof(ThreadPool));
    if (!pool) return NULL;
    
    pool->queue_front = 0;
    pool->queue_rear = 0;
    pool->queue_size = 0;
    pool->shutdown = 0;
    
    if (mtx_init(&pool->queue_mutex, mtx_plain) != thrd_success) {
        free(pool);
        return NULL;
    }
    
    if (cnd_init(&pool->queue_condition) != thrd_success) {
        mtx_destroy(&pool->queue_mutex);
        free(pool);
        return NULL;
    }
    
    // 创建工作线程
    for (int i = 0; i < num_threads; i++) {
        if (thrd_create(&pool->threads[i], worker_thread_func, pool) != thrd_success) {
            // 清理已创建的线程
            pool->shutdown = 1;
            cnd_broadcast(&pool->queue_condition);
            for (int j = 0; j < i; j++) {
                thrd_join(pool->threads[j], NULL);
            }
            mtx_destroy(&pool->queue_mutex);
            cnd_destroy(&pool->queue_condition);
            free(pool);
            return NULL;
        }
    }
    
    return pool;
}

// 添加任务到线程池
int submit_task(ThreadPool *pool, void (*function)(void *), void *argument) {
    mtx_lock(&pool->queue_mutex);
    
    if (pool->queue_size >= MAX_QUEUE_SIZE) {
        mtx_unlock(&pool->queue_mutex);
        return -1;  // 队列已满
    }
    
    pool->task_queue[pool->queue_rear].function = function;
    pool->task_queue[pool->queue_rear].argument = argument;
    pool->queue_rear = (pool->queue_rear + 1) % MAX_QUEUE_SIZE;
    pool->queue_size++;
    
    cnd_signal(&pool->queue_condition);
    mtx_unlock(&pool->queue_mutex);
    
    return 0;
}
```

## 最佳实践

### 内存安全
- 始终检查指针是否为NULL
- 避免数组越界访问
- 正确管理动态内存的生命周期
- 使用静态分析工具检测潜在问题

### 并发安全
- 最小化共享状态
- 使用适当的同步原语
- 避免死锁和竞态条件
- 优先使用原子操作而非锁

### 性能优化
- 了解目标平台的特性
- 测量before优化
- 关注算法复杂度
- 考虑缓存友好性

## 总结

高级C编程需要深入理解：

1. **内存模型**：抽象机器、顺序点、内存一致性
2. **未定义行为**：识别、避免、替代方案
3. **并发编程**：线程、同步、原子操作
4. **性能优化**：编译器优化、内存访问、算法选择

掌握这些概念是成为高级C程序员的关键，它们不仅影响程序的正确性，也决定了程序的性能和可维护性。

