# C语言输入输出与文件操作

## 学习目标

通过本章学习，你将掌握：
- C语言标准输入输出流的使用方法和核心概念
- 字符和字符串输入输出函数的应用技巧和最佳实践
- 格式化输入输出的高级用法和安全注意事项
- 文件操作的完整流程和健壮的错误处理机制
- 文件定位和缓冲控制的实用技术和性能优化
- 实际项目中文件处理的工程化最佳实践

## 1. 标准输入输出

### 1.1 标准流概述

C语言提供了三个预定义的标准流，它们是程序与外部环境交互的基础接口：

```c
#include <stdio.h>

// 标准流详解
extern FILE *stdin;   // 标准输入流（通常连接到键盘，可重定向）
extern FILE *stdout;  // 标准输出流（通常连接到终端屏幕，可重定向）
extern FILE *stderr;  // 标准错误流（通常连接到终端屏幕，独立于stdout）

void standard_streams_demo() {
    // 向标准输出写入信息
    fprintf(stdout, "这是标准输出信息\n");
    
    // 向标准错误写入错误信息
    fprintf(stderr, "这是错误信息\n");
    
    // 从标准输入读取用户输入
    char buffer[100];
    printf("请输入一些文本: ");
    if (fgets(buffer, sizeof(buffer), stdin)) {
        printf("你输入了: %s", buffer);
    }
    
    // 刷新输出缓冲区
    fflush(stdout);
}

// 标准流的特性演示
void stream_properties_demo() {
    // 检查流的状态
    if (ferror(stdin)) {
        fprintf(stderr, "标准输入流发生错误\n");
        clearerr(stdin);
    }
    
    if (feof(stdin)) {
        printf("标准输入流已到达文件末尾\n");
    }
    
    // 流的缓冲模式
    printf("标准输出通常是行缓冲的\n");
    fprintf(stderr, "标准错误通常是无缓冲的\n");
    
    // 刷新输出缓冲区
    fflush(stdout);
}
```

### 1.2 字符I/O函数

```c
// 字符输入
int getchar(void);                    // 从stdin读取字符
int fgetc(FILE *stream);             // 从指定流读取字符
int getc(FILE *stream);              // 宏版本，可能更快

// 字符输出
int putchar(int c);                  // 向stdout输出字符
int fputc(int c, FILE *stream);      // 向指定流输出字符
int putc(int c, FILE *stream);       // 宏版本，可能更快

// 示例：字符复制程序
#include <stdio.h>

int main() {
    int c;
    while ((c = getchar()) != EOF) {
        putchar(c);
    }
    return 0;
}
```

### 1.3 字符串I/O函数

```c
// 字符串输入
char *gets(char *s);                 // 已废弃，不安全
char *fgets(char *s, int size, FILE *stream);  // 安全版本

// 字符串输出
int puts(const char *s);             // 输出字符串并添加换行
int fputs(const char *s, FILE *stream);  // 输出字符串，不添加换行

// 示例：安全的字符串输入
#include <stdio.h>
#define MAX_LINE 1000

int main() {
    char line[MAX_LINE];
    
    printf("请输入一行文本: ");
    if (fgets(line, sizeof(line), stdin) != NULL) {
        printf("您输入的是: %s", line);
    }
    
    return 0;
}
```

### 1.4 格式化I/O函数

```c
// 格式化输出
int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);  // 安全版本

// 格式化输入
int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);

// 常用格式说明符
/*
%d, %i    - 整数
%u        - 无符号整数
%o        - 八进制
%x, %X    - 十六进制
%f        - 浮点数
%e, %E    - 科学计数法
%g, %G    - 自动选择格式
%c        - 字符
%s        - 字符串
%p        - 指针
%%        - 百分号字面量
*/

// 示例：格式化输出
#include <stdio.h>

int main() {
    int num = 42;
    double pi = 3.14159;
    char name[] = "Alice";
    
    printf("整数: %d\n", num);
    printf("浮点数: %.2f\n", pi);
    printf("字符串: %s\n", name);
    printf("十六进制: 0x%x\n", num);
    printf("科学计数法: %e\n", pi);
    
    return 0;
}
```

## 2. 文件操作

### 2.1 文件打开与关闭

在C语言中，操作文件之前必须先打开文件，这样程序和文件之间才能建立连接。所谓"打开文件"，就是让程序和文件建立连接的过程。

```c
// 文件操作函数
FILE *fopen(const char *filename, const char *mode);
int fclose(FILE *stream);
```

#### fopen() 函数详解

使用 `<stdio.h>` 头文件中的 `fopen()` 函数即可打开文件，它的用法为：

```c
FILE *fopen(char *filename, char *mode);
```

- `filename`为文件名（包括文件路径），`mode`为打开方式，它们都是字符串
- `fopen()` 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，然后将该变量的地址返回
- 如果希望接收 `fopen()` 的返回值，就需要定义一个 FILE 类型的指针

#### 判断文件是否打开成功

打开文件出错时，`fopen()` 将返回一个空指针，也就是 NULL，我们可以利用这一点来判断文件是否打开成功：

```c
FILE *fp;
if( (fp=fopen("D:\\demo.txt","rb")) == NULL ){
    printf("Fail to open file!\n");
    exit(0);
}
```

#### 文件打开模式

不同的操作需要不同的文件权限。调用 `fopen()` 函数时必须指明读写权限，但是可以不指明读写方式（此时默认为"t"）。

| 模式 | 说明 |
|------|------|
| "r" | 以"只读"方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败 |
| "w" | 以"写入"方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容 |
| "a" | 以"追加"方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾 |
| "r+" | 以"读写"方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败 |
| "w+" | 以"写入/更新"方式打开文件，相当于w和r+叠加的效果。既可以读取也可以写入 |
| "a+" | 以"追加/更新"方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入 |
| "t" | 文本文件。如果不写，默认为"t" |
| "b" | 二进制文件 |

#### 关闭文件

文件一旦使用完毕，应该用 `fclose()` 函数把文件关闭，以释放相关资源，避免数据丢失。`fclose()` 的用法为：

```c
int fclose(FILE *fp);
```

文件正常关闭时，`fclose()` 的返回值为0，如果返回非零值则表示有错误发生。

#### 基本文件操作示例

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *fp;
    
    // 打开文件
    fp = fopen("data.txt", "w");
    if (fp == NULL) {
        perror("无法打开文件");
        return EXIT_FAILURE;
    }
    
    // 写入数据
    fprintf(fp, "Hello, File I/O!\n");
    fprintf(fp, "数字: %d\n", 42);
    
    // 关闭文件
    fclose(fp);
    
    return 0;
}
```

### 2.2 文件读写操作

#### fread() 和 fwrite() 函数

`fgets()` 有局限性，每次最多只能从文件中读取一行内容，因为 `fgets()` 遇到换行符就结束读取。如果希望读取多行内容，需要使用 `fread()` 函数；相应地写入函数为 `fwrite()`。这两个函数可以处理任意类型的数据，包括二进制数据。

对于 Windows 系统，使用 `fread()` 和 `fwrite()` 时应该以二进制的形式打开文件。这是因为Windows系统在文本模式下会对换行符进行转换，可能导致数据读写不一致。

```c
// fread() 函数用来从指定文件中读取块数据
size_t fread(void *ptr, size_t size, size_t count, FILE *fp);

// fwrite() 函数用来向文件中写入块数据
size_t fwrite(void *ptr, size_t size, size_t count, FILE *fp);
```

#### 参数说明

- `ptr` 为内存区块的指针，它可以是数组、变量、结构体等。`fread()` 中的 `ptr` 用来存放读取到的数据，`fwrite()` 中的 `ptr` 用来存放要写入的数据
- `size`：表示每个数据块的字节数
- `count`：表示要读写的数据块的块数
- `fp`：表示文件指针

理论上，每次读写 `size*count` 个字节的数据。

#### 返回值

返回成功读写的块数，也即 `count`。如果返回值小于 `count`：
- 对于 `fread()`：可能到达了文件末尾或发生了读取错误
- 对于 `fwrite()`：可能发生了写入错误，如磁盘空间不足

- 对于 `fwrite()` 来说，肯定发生了写入错误，可以用 `ferror()` 函数检测
- 对于 `fread()` 来说，可能读到了文件末尾，可能发生了错误，可以用 `ferror()` 或 `feof()` 检测

#### 示例：数组读写

从键盘输入一个数组，将数组写入文件再读取出来：

```c
#include<stdio.h>
#define N 5

int main(){
    int a[N], b[N];
    int i, size = sizeof(int);
    FILE *fp;
    
    if( (fp=fopen("D:\\demo.txt", "rb+")) == NULL ){
        puts("Fail to open file!");
        exit(0);
    }
    
    // 从键盘输入数据并保存到数组a
    for(i=0; i<N; i++){
        scanf("%d", &a[i]);
    }
    
    // 将数组a的内容写入到文件
    fwrite(a, size, N, fp);
    
    // 将文件中的位置指针重新定位到文件开头
    rewind(fp);
    
    // 从文件读取内容并保存到数组b
    fread(b, size, N, fp);
    
    // 在屏幕上显示数组b的内容
    for(i=0; i<N; i++){
        printf("%d ", b[i]);
    }
    printf("\n");
    
    fclose(fp);
    return 0;
}
```

#### 示例：结构体读写

从键盘输入两个学生数据，写入一个文件中，再读出这两个学生的数据显示在屏幕上：

```c
#include<stdio.h>
#define N 2

struct stu{
    char name[10];  // 姓名
    int num;        // 学号
    int age;        // 年龄
    float score;    // 成绩
}boya[N], boyb[N], *pa, *pb;

int main(){
    FILE *fp;
    int i;
    pa = boya;
    pb = boyb;
    
    if( (fp=fopen("d:\\demo.txt", "wb+")) == NULL ){
        puts("Fail to open file!");
        exit(0);
    }
    
    // 从键盘输入数据
    printf("Input data:\n");
    for(i=0; i<N; i++,pa++){
        scanf("%s %d %d %f",pa->name, &pa->num,&pa->age, &pa->score);
    }
    
    // 将数组 boya 的数据写入文件
    fwrite(boya, sizeof(struct stu), N, fp);
    
    // 将文件指针重置到文件开头
    rewind(fp);
    
    // 从文件读取数据并保存到数据 boyb
    fread(boyb, sizeof(struct stu), N, fp);
    
    // 输出数组 boyb 中的数据
    for(i=0; i<N; i++,pb++){
        printf("%s  %d  %d  %f\n", pb->name, pb->num, pb->age, pb->score);
    }
    
    fclose(fp);
    return 0;
}
```

### 2.3 文件定位

文件定位函数用于控制文件指针的位置，实现随机访问文件内容。文件定位是文件操作中的重要概念，它允许程序在文件中的任意位置进行读写操作，而不必按顺序处理整个文件。

#### fseek() 函数

`fseek()` 函数可以移动文件的读写指针到指定的位置，即移动当前文件的位置指针。这是C语言中最常用的文件定位函数，它提供了灵活的文件访问方式。

```c
int fseek(FILE *stream, long offset, int fromwhere);
```

#### 参数说明

- `stream` 为文件指针
- `offset` 为偏移量
- `fromwhere` 为指针的起始位置

参数 `fromwhere` 为下列其中一种：

- `SEEK_SET`：从距文件开头 offset 位移量为新的读写位置
- `SEEK_CUR`：以目前的读写位置往后增加 offset 个位移量
- `SEEK_END`：将读写位置指向文件尾后再增加 offset 个位移量

当 `fromwhere` 为 `SEEK_CUR` 或 `SEEK_END` 时，参数 `offset` 允许负值的出现。

#### 返回值

成功返回 0，否则返回非 0 值。如果发生读写错误，将会设置设置文件错误标识。

#### 常用定位操作

- 将读写位置移动到文件开头：`fseek(fp, 0, SEEK_SET);`
- 将读写位置移动到文件尾时：`fseek(fp, 0, SEEK_END);`
- 将读写位置动到离文件开头100字节处：`fseek(fp,100L, SEEK_SET);`
- 将读写指针移动到离文件当前位置100字节处：`fseek(fp,100L, SEEK_CUR);`
- 将读写指针退回到离文件结尾100字节处：`fseek(fp, -100L, SEEK_END);`

#### 其他定位函数

```c
// 获取当前文件位置
long ftell(FILE *stream);

// 重置文件指针到开头
void rewind(FILE *stream);

// 获取文件位置（更精确）
int fgetpos(FILE *stream, fpos_t *pos);

// 设置文件位置
int fsetpos(FILE *stream, const fpos_t *pos);
```

#### 示例：文件定位操作

下面的示例演示了如何创建一个文件，写入数据后使用文件定位函数进行读取操作。这个例子展示了 `fseek()` 函数的实际应用，以及如何在写入数据后重新定位到文件开头进行读取：

```c
#include<stdio.h>

int main(void) {
    FILE* stream;
    long l;
    float fp;
    char s[81];
    char c;
    
    stream = fopen("fscanf.txt","w+");
    if(stream == NULL) {
        printf("the file is opeaned error!\n");
    } else {
        // 使用 fprintf() 函数往文件流中写入一些数据
        fprintf(stream,"%s %ld %f %c","a_string",6500,3.1415,'x');
        
        // 使用 fseek() 函数把文件的当前读/写指针定位到文件头
        fseek(stream,0L,SEEK_SET);
        
        // 使用 fscanf() 函数按格式逐个读取写入的数据并显示
        fscanf(stream,"%s",s);
        fscanf(stream,"%ld",&l);
        fscanf(stream,"%f",&fp);
        fscanf(stream," %c",&c);
        
        printf("%s\n",s);
        printf("%ld\n",l);
        printf("%f\n",fp);
        printf("%c\n",c);
        
        fclose(stream);
    }
    return 0;
}
```

## 3. 错误处理与状态检查

### 3.1 错误检查函数

在文件操作中，正确的错误处理是非常重要的。C语言提供了多个函数来检测和处理文件操作中的错误。文件操作可能因为各种原因失败，如文件不存在、权限不足、磁盘空间不足等，因此需要适当的错误检测机制。

#### feof() 函数

在文件操作中，正确判断文件是否结束是非常重要的。`fgetc`（或者`getc`）函数返回 EOF 并不一定就表示文件结束，读取文件出错时也会返回 EOF。即 EOF 宏不但能够表示读到了文件结尾这一状态，而且还能表示 I/O 操作中的读、写错误以及其他一些关联操作的错误状态。很显然，仅凭返回 EOF(-1) 就认为文件结束显然是不正确的。

也正因为如此，我们需要使用 `feof` 函数来替换 EOF 宏检测文件是否结束。

```c
int feof(FILE *fp);
```

**功能**：判断文件是否处于文件结束位置，如文件结束，则返回值为1，否则为0。这个函数提供了一种可靠的方法来检测文件是否已经读取到末尾。

**重要说明**：函数 `feof` 只用于检测流文件，当文件内部位置指针指向文件结束时，并未立即置位 FILE 结构中的文件结束标记，只有再执行一次读文件操作，才会置位结束标志，此后调用 `feof` 才会返回为真。

#### ferror() 函数

在用 `feof` 函数检测文件是否结束的同时，也需要使用 `ferror` 函数来检测文件读取操作是否出错，当 `ferror` 函数返回为真时就表示有错误发生。在实际的程序中，应该每执行一次文件操作，就用 `ferror` 函数检测是否出错。

```c
int ferror(FILE *fp);
```

**功能**：检查文件在用各种输入输出函数进行读写时是否出错。如ferror返回值为0表示未出错，否则表示有错。这个函数是文件错误检测的重要工具，能够帮助程序员及时发现和处理文件操作中的异常情况。

**使用建议**：
- 在每次重要的文件操作后都应该检查错误状态
- 与 `feof()` 函数配合使用，可以准确区分文件结束和读取错误
- 错误状态会一直保持，直到调用 `clearerr()` 函数清除

#### clearerr() 函数

`clearerr` 函数用于清除文件的错误标志和文件结束标志。当文件操作出现错误或到达文件末尾时，相应的标志会被设置，这些标志会影响后续的文件操作。使用 `clearerr` 函数可以重置这些状态标志，使文件流重新可用。

```c
void clearerr(FILE *fp);
```

**功能**：清除由fp指定的文件的错误标志和文件结束标志，使它们复位。这个函数对于需要重复使用同一个文件流进行多次操作的程序特别有用。

**应用场景**：
- 在检测到文件错误后，修复问题并继续操作
- 重置文件结束标志，准备重新读取文件
- 在循环中重复使用同一个文件流时清除状态

**注意事项**：
- 该函数没有返回值
- 清除标志后，需要重新定位文件指针到合适的位置
- 通常与 `fseek()` 或 `rewind()` 函数配合使用

#### perror() 函数

`perror()` 函数用于打印最近的库函数执行出错的消息，消息基于全局变量 errno，很多标准库函数执行出错时都会设置 errno 的值。当系统调用或库函数发生错误时，它们通常会设置全局变量 errno 来指示错误类型，perror() 函数可以将这个错误码转换为可读的错误信息并输出。

```c
void perror(const char *str);
```

参数 `str`: 一个指向字符串的指针，通常用来对函数发生的错误消息做进一步的描述。当 `str` 为 NULL 时，则 `perror()` 函数直接打印函数执行出错的消息。如果 str 不为 NULL，perror() 会先输出 str 的内容，然后输出一个冒号和空格，最后输出错误信息。

#### 正确的文件读取示例

为了解决EOF判断的问题，需要在循环语句中加以判断：

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    FILE *fp = NULL;
    char c;
    
    fp = fopen("myfile.txt", "r");
    if(fp == NULL) {
        perror("Error opening file");
        exit(1);
    }
    
    while(!feof(fp)) {
        if(ferror(fp)) {
            perror("Read error");
            clearerr(fp);
            break;
        }
        c = fgetc(fp);
        if(c != -1) {
            printf("%c", c);
        }
    }
    
    fclose(fp);
    fp = NULL;
    return 0;
}
```

#### 更好的文件读取方式

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    FILE *fp = NULL;
    char c;
    
    fp = fopen("myfile.txt", "r");
    if(fp == NULL) {
        perror("Error opening file");
        exit(1);
    }
    
    // 方式一：先读取再判断
    c = fgetc(fp);
    while(!feof(fp)) {
        printf("%c", c);
        c = fgetc(fp);
    }
    
    // 检查是否有错误发生
    if(ferror(fp)) {
        perror("Read error");
        clearerr(fp);
    }
    
    fclose(fp);
    return 0;
}
```

#### 示例：健壮的文件复制

```c
#include <stdio.h>
#include <stdlib.h>

int safe_file_copy(const char *src, const char *dst) {
    FILE *src_fp, *dst_fp;
    int ch;
    
    src_fp = fopen(src, "rb");
    if (src_fp == NULL) {
        perror("无法打开源文件");
        return -1;
    }
    
    dst_fp = fopen(dst, "wb");
    if (dst_fp == NULL) {
        perror("无法创建目标文件");
        fclose(src_fp);
        return -1;
    }
    
    // 复制文件内容
    while ((ch = fgetc(src_fp)) != EOF) {
        if (fputc(ch, dst_fp) == EOF) {
            perror("写入错误");
            fclose(src_fp);
            fclose(dst_fp);
            return -1;
        }
    }
    
    // 检查读取是否因错误而结束
    if (ferror(src_fp)) {
        perror("读取错误");
        fclose(src_fp);
        fclose(dst_fp);
        return -1;
    }
    
    fclose(src_fp);
    fclose(dst_fp);
    return 0;
}
```

### 3.2 缓冲控制

```c
// 缓冲控制函数
int setvbuf(FILE *stream, char *buffer, int mode, size_t size);
int fflush(FILE *stream);

// 缓冲模式
/*
_IOFBF - 全缓冲
_IOLBF - 行缓冲
_IONBF - 无缓冲
*/

// 示例：缓冲控制
#include <stdio.h>

int main() {
    FILE *fp = fopen("output.txt", "w");
    if (fp == NULL) {
        perror("无法打开文件");
        return 1;
    }
    
    // 设置为行缓冲
    setvbuf(fp, NULL, _IOLBF, BUFSIZ);
    
    fprintf(fp, "这行会被缓冲\n");  // 遇到换行符会刷新缓冲区
    fprintf(fp, "这行也会被缓冲");   // 不会立即写入
    
    fflush(fp);  // 强制刷新缓冲区
    
    fclose(fp);
    return 0;
}
```

## 4. 实践示例：简单日志系统

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef enum {
    LOG_DEBUG,
    LOG_INFO,
    LOG_WARNING,
    LOG_ERROR
} LogLevel;

const char* log_level_strings[] = {
    "DEBUG", "INFO", "WARNING", "ERROR"
};

typedef struct {
    FILE *file;
    LogLevel min_level;
} Logger;

// 初始化日志系统
Logger* logger_init(const char *filename, LogLevel min_level) {
    Logger *logger = malloc(sizeof(Logger));
    if (logger == NULL) {
        return NULL;
    }
    
    logger->file = fopen(filename, "a");
    if (logger->file == NULL) {
        free(logger);
        return NULL;
    }
    
    logger->min_level = min_level;
    
    // 设置行缓冲，确保日志及时写入
    setvbuf(logger->file, NULL, _IOLBF, BUFSIZ);
    
    return logger;
}

// 写入日志
void logger_log(Logger *logger, LogLevel level, const char *message) {
    if (logger == NULL || level < logger->min_level) {
        return;
    }
    
    time_t now = time(NULL);
    char *time_str = ctime(&now);
    time_str[strlen(time_str) - 1] = '\0';  // 移除换行符
    
    fprintf(logger->file, "[%s] %s: %s\n", 
            time_str, log_level_strings[level], message);
}

// 关闭日志系统
void logger_close(Logger *logger) {
    if (logger != NULL) {
        if (logger->file != NULL) {
            fclose(logger->file);
        }
        free(logger);
    }
}

// 使用示例
int main() {
    Logger *logger = logger_init("app.log", LOG_INFO);
    if (logger == NULL) {
        fprintf(stderr, "无法初始化日志系统\n");
        return EXIT_FAILURE;
    }
    
    logger_log(logger, LOG_INFO, "程序启动");
    logger_log(logger, LOG_DEBUG, "这条调试信息不会被记录");
    logger_log(logger, LOG_WARNING, "这是一个警告");
    logger_log(logger, LOG_ERROR, "发生了错误");
    logger_log(logger, LOG_INFO, "程序结束");
    
    logger_close(logger);
    
    printf("日志已写入 app.log 文件\n");
    return 0;
}
```

## 5. 最佳实践

### 5.1 资源管理

```c
// 使用RAII模式管理文件资源
#define SAFE_FCLOSE(fp) do { \
    if ((fp) != NULL) { \
        fclose(fp); \
        (fp) = NULL; \
    } \
} while(0)

// 文件操作包装函数
FILE* safe_fopen(const char *filename, const char *mode) {
    FILE *fp = fopen(filename, mode);
    if (fp == NULL) {
        perror("文件打开失败");
    }
    return fp;
}
```

### 5.2 错误处理模式

```c
// 统一的错误处理模式
int process_file(const char *filename) {
    FILE *fp = NULL;
    char *buffer = NULL;
    int result = -1;
    
    fp = fopen(filename, "r");
    if (fp == NULL) {
        perror("无法打开文件");
        goto cleanup;
    }
    
    buffer = malloc(BUFFER_SIZE);
    if (buffer == NULL) {
        fprintf(stderr, "内存分配失败\n");
        goto cleanup;
    }
    
    // 处理文件内容...
    
    result = 0;  // 成功
    
cleanup:
    free(buffer);
    if (fp != NULL) {
        fclose(fp);
    }
    return result;
}
```

### 5.3 性能优化技巧

```c
// 1. 使用适当的缓冲区大小
#define OPTIMAL_BUFFER_SIZE 8192

// 2. 批量I/O操作
size_t copy_file_optimized(FILE *src, FILE *dst) {
    char buffer[OPTIMAL_BUFFER_SIZE];
    size_t bytes_read, total_bytes = 0;
    
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), src)) > 0) {
        if (fwrite(buffer, 1, bytes_read, dst) != bytes_read) {
            return 0;  // 写入错误
        }
        total_bytes += bytes_read;
    }
    
    return total_bytes;
}

// 3. 避免频繁的fflush调用
// 4. 对于大文件，考虑使用内存映射（mmap）
```

## 总结

C语言的I/O系统提供了丰富而灵活的文件操作功能：

1. **标准I/O**：提供了字符、字符串和格式化I/O函数
2. **文件操作**：支持文本和二进制文件的读写
3. **错误处理**：提供了完善的错误检查和状态管理机制
4. **缓冲控制**：允许优化I/O性能
5. **资源管理**：需要正确管理文件句柄和内存资源

掌握这些概念和技术，能够编写出高效、健壮的文件处理程序。在实际开发中，要特别注意错误处理和资源管理，确保程序的稳定性和可靠性。
