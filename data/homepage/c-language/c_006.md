# C语言输入输出与文件操作

## 1. I/O系统的设计哲学与架构

### 1.1 Unix"一切皆文件"的设计理念

C语言的I/O系统继承了Unix系统"一切皆文件"的设计哲学，这种抽象为程序提供了统一的数据访问接口。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <time.h>

// 演示I/O系统的统一抽象
void io_abstraction_demo() {
    printf("=== I/O系统抽象演示 ===\n");
    
    // 1. 标准输出（屏幕）
    fprintf(stdout, "输出到标准输出流\n");
    
    // 2. 标准错误（通常也是屏幕，但可以重定向）
    fprintf(stderr, "输出到标准错误流\n");
    
    // 3. 文件输出
    FILE* file = fopen("demo_output.txt", "w");
    if (file) {
        fprintf(file, "输出到文件流\n");
        fclose(file);
    }
    
    // 4. 字符串输出（内存中的"文件"）
    char buffer[256];
    sprintf(buffer, "输出到字符串缓冲区，时间：%ld", time(NULL));
    printf("字符串内容：%s\n", buffer);
    
    printf("\n统一的fprintf接口可以操作：\n");
    printf("- 标准流（stdout, stderr, stdin）\n");
    printf("- 文件流（磁盘文件）\n");
    printf("- 内存流（字符串缓冲区）\n");
    printf("- 网络流（套接字，在系统编程中）\n");
}
```

### 1.2 I/O系统的层次架构

```c
// I/O系统层次结构演示
void io_layers_demo() {
    printf("\n=== I/O系统层次架构 ===\n");
    
    printf("C语言I/O系统的层次结构：\n");
    printf("┌─────────────────────────────────────┐\n");
    printf("│  应用层：printf, scanf, fgets等     │\n");
    printf("├─────────────────────────────────────┤\n");
    printf("│  标准I/O库：fopen, fread, fwrite等  │\n");
    printf("├─────────────────────────────────────┤\n");
    printf("│  系统调用层：open, read, write等    │\n");
    printf("├─────────────────────────────────────┤\n");
    printf("│  内核层：设备驱动程序               │\n");
    printf("├─────────────────────────────────────┤\n");
    printf("│  硬件层：磁盘、网卡、键盘等         │\n");
    printf("└─────────────────────────────────────┘\n");
    
    printf("\n各层的特点：\n");
    printf("- 应用层：高级、易用、功能丰富\n");
    printf("- 标准库层：可移植、缓冲优化、错误处理\n");
    printf("- 系统调用层：高效、直接、平台相关\n");
    printf("- 内核层：资源管理、安全控制\n");
    printf("- 硬件层：实际的物理操作\n");
}
```

## 2. 流的深度解析与缓冲机制

### 2.1 流的本质与特性

```c
// 流的特性演示
void stream_characteristics_demo() {
    printf("\n=== 流的特性演示 ===\n");
    
    // 1. 流的方向性
    printf("1. 流的方向性：\n");
    FILE* input_file = fopen("input.txt", "r");   // 只读流
    FILE* output_file = fopen("output.txt", "w"); // 只写流
    FILE* rw_file = fopen("data.txt", "r+");      // 读写流
    
    if (input_file) {
        printf("   - 只读流：只能进行读取操作\n");
        fclose(input_file);
    }
    if (output_file) {
        printf("   - 只写流：只能进行写入操作\n");
        fclose(output_file);
    }
    if (rw_file) {
        printf("   - 读写流：可以进行读写操作\n");
        fclose(rw_file);
    }
    
    // 2. 流的位置指针
    printf("\n2. 流的位置指针：\n");
    FILE* demo_file = fopen("position_demo.txt", "w+");
    if (demo_file) {
        // 写入一些数据
        fprintf(demo_file, "Hello, World!");
        
        // 获取当前位置
        long pos = ftell(demo_file);
        printf("   - 写入后位置：%ld\n", pos);
        
        // 移动到开头
        rewind(demo_file);
        pos = ftell(demo_file);
        printf("   - 重置后位置：%ld\n", pos);
        
        // 移动到特定位置
        fseek(demo_file, 7, SEEK_SET);
        pos = ftell(demo_file);
        printf("   - 移动后位置：%ld\n", pos);
        
        fclose(demo_file);
    }
}
```

### 2.2 缓冲机制的深入理解

```c
#include <unistd.h>  // for sleep (Unix/Linux)
#ifdef _WIN32
#include <windows.h>
#define sleep(x) Sleep((x)*1000)
#endif

// 缓冲机制演示
void buffering_mechanism_demo() {
    printf("\n=== 缓冲机制演示 ===\n");
    
    printf("1. 不同缓冲模式的行为：\n");
    
    // 全缓冲演示（文件）
    printf("   全缓冲（文件输出）：\n");
    FILE* full_buffered = fopen("full_buffer_test.txt", "w");
    if (full_buffered) {
        fprintf(full_buffered, "这是全缓冲的输出");
        printf("     - 数据已写入缓冲区，但可能还未写入磁盘\n");
        
        fflush(full_buffered);  // 强制刷新缓冲区
        printf("     - 调用fflush后，数据被写入磁盘\n");
        fclose(full_buffered);
    }
    
    // 行缓冲演示（标准输出）
    printf("\n   行缓冲（标准输出）：\n");
    printf("     - 这行没有换行符，数据在缓冲区中");
    fflush(stdout);  // 立即输出
    sleep(2);
    printf("\n     - 遇到换行符，自动刷新缓冲区\n");
    
    // 无缓冲演示（标准错误）
    printf("\n   无缓冲（标准错误）：\n");
    fprintf(stderr, "     - 错误信息立即输出，无缓冲\n");
    
    // 自定义缓冲区
    printf("\n2. 自定义缓冲区：\n");
    FILE* custom_file = fopen("custom_buffer_test.txt", "w");
    if (custom_file) {
        char custom_buffer[1024];
        
        // 设置自定义缓冲区
        if (setvbuf(custom_file, custom_buffer, _IOFBF, sizeof(custom_buffer)) == 0) {
            printf("     - 成功设置1024字节的自定义缓冲区\n");
        }
        
        // 设置无缓冲
        if (setvbuf(custom_file, NULL, _IONBF, 0) == 0) {
            printf("     - 成功设置为无缓冲模式\n");
        }
        
        fclose(custom_file);
    }
}
```

## 3. 标准I/O库函数的深度应用

### 3.1 格式化输入输出的高级技巧

```c
// 高级格式化I/O演示
void advanced_formatted_io_demo() {
    printf("\n=== 高级格式化I/O演示 ===\n");
    
    // 1. printf家族的高级用法
    printf("1. printf高级格式化：\n");
    
    int width = 10;
    int precision = 2;
    double value = 123.456789;
    
    printf("   动态宽度和精度：%*.*f\n", width, precision, value);
    printf("   左对齐：%-10s|\n", "Hello");
    printf("   右对齐：%10s|\n", "Hello");
    printf("   零填充：%08d\n", 42);
    printf("   十六进制：0x%X\n", 255);
    printf("   科学计数法：%e\n", 1234.5);
    printf("   自动选择格式：%g\n", 1234.5);
    
    // 2. scanf的高级用法和陷阱
    printf("\n2. scanf高级用法：\n");
    printf("   请输入一个整数：");
    
    int num;
    int result = scanf("%d", &num);
    if (result == 1) {
        printf("   成功读取：%d\n", num);
    } else {
        printf("   读取失败，清理输入缓冲区\n");
        // 清理输入缓冲区
        int c;
        while ((c = getchar()) != '\n' && c != EOF);
    }
    
    // 3. 安全的字符串输入
    printf("\n3. 安全的字符串输入：\n");
    char safe_buffer[64];
    printf("   请输入一个字符串（最多63个字符）：");
    
    if (fgets(safe_buffer, sizeof(safe_buffer), stdin)) {
        // 移除可能的换行符
        size_t len = strlen(safe_buffer);
        if (len > 0 && safe_buffer[len-1] == '\n') {
            safe_buffer[len-1] = '\0';
        }
        printf("   安全读取：%s\n", safe_buffer);
    }
}
```

### 3.2 字符和行处理函数

```c
// 字符和行处理演示
void character_line_processing_demo() {
    printf("\n=== 字符和行处理演示 ===\n");
    
    // 创建测试文件
    FILE* test_file = fopen("char_line_test.txt", "w");
    if (test_file) {
        fprintf(test_file, "第一行\n第二行\n第三行\n");
        fclose(test_file);
    }
    
    // 1. 字符级处理
    printf("1. 字符级处理：\n");
    test_file = fopen("char_line_test.txt", "r");
    if (test_file) {
        printf("   逐字符读取：");
        int ch;
        int char_count = 0;
        while ((ch = fgetc(test_file)) != EOF && char_count < 10) {
            if (ch == '\n') {
                printf("\\n");
            } else {
                printf("%c", ch);
            }
            char_count++;
        }
        printf("\n");
        fclose(test_file);
    }
    
    // 2. 行级处理
    printf("\n2. 行级处理：\n");
    test_file = fopen("char_line_test.txt", "r");
    if (test_file) {
        char line_buffer[256];
        int line_num = 1;
        
        while (fgets(line_buffer, sizeof(line_buffer), test_file)) {
            printf("   第%d行：%s", line_num++, line_buffer);
        }
        fclose(test_file);
    }
    
    // 3. 字符回退
    printf("\n3. 字符回退演示：\n");
    test_file = fopen("char_line_test.txt", "r");
    if (test_file) {
        int ch1 = fgetc(test_file);
        int ch2 = fgetc(test_file);
        printf("   读取两个字符：'%c' '%c'\n", ch1, ch2);
        
        ungetc(ch2, test_file);  // 回退一个字符
        int ch3 = fgetc(test_file);
        printf("   回退后再读取：'%c'\n", ch3);
        
        fclose(test_file);
    }
}
```

## 4. 文件操作的完整生命周期

### 4.1 文件打开模式的深入理解

```c
// 文件打开模式演示
void file_open_modes_demo() {
    printf("\n=== 文件打开模式演示 ===\n");
    
    // 创建测试数据
    const char* test_data = "原始数据内容\n";
    
    // 1. 写入模式 "w" - 创建新文件或截断现有文件
    printf("1. 写入模式 'w'：\n");
    FILE* file = fopen("mode_test.txt", "w");
    if (file) {
        fprintf(file, "%s", test_data);
        fclose(file);
        printf("   - 创建文件并写入数据\n");
    }
    
    // 2. 追加模式 "a" - 在文件末尾添加内容
    printf("\n2. 追加模式 'a'：\n");
    file = fopen("mode_test.txt", "a");
    if (file) {
        fprintf(file, "追加的数据\n");
        fclose(file);
        printf("   - 在文件末尾追加数据\n");
    }
    
    // 3. 读取模式 "r" - 只读现有文件
    printf("\n3. 读取模式 'r'：\n");
    file = fopen("mode_test.txt", "r");
    if (file) {
        char buffer[256];
        printf("   文件内容：\n");
        while (fgets(buffer, sizeof(buffer), file)) {
            printf("     %s", buffer);
        }
        fclose(file);
    }
    
    // 4. 读写模式 "r+" - 读写现有文件
    printf("\n4. 读写模式 'r+'：\n");
    file = fopen("mode_test.txt", "r+");
    if (file) {
        // 读取第一行
        char buffer[256];
        if (fgets(buffer, sizeof(buffer), file)) {
            printf("   读取：%s", buffer);
        }
        
        // 在当前位置写入
        fprintf(file, "插入的数据\n");
        fclose(file);
        printf("   - 在当前位置插入数据\n");
    }
    
    // 5. 二进制模式
    printf("\n5. 二进制模式：\n");
    file = fopen("binary_test.bin", "wb");
    if (file) {
        int data[] = {1, 2, 3, 4, 5};
        size_t written = fwrite(data, sizeof(int), 5, file);
        fclose(file);
        printf("   - 写入%zu个整数到二进制文件\n", written);
    }
    
    file = fopen("binary_test.bin", "rb");
    if (file) {
        int data[5];
        size_t read = fread(data, sizeof(int), 5, file);
        fclose(file);
        printf("   - 从二进制文件读取%zu个整数：", read);
        for (size_t i = 0; i < read; i++) {
            printf("%d ", data[i]);
        }
        printf("\n");
    }
}
```

### 4.2 文件状态检查和错误处理

```c
// 文件状态和错误处理演示
void file_status_error_handling_demo() {
    printf("\n=== 文件状态和错误处理演示 ===\n");
    
    // 1. 文件存在性检查
    printf("1. 文件存在性检查：\n");
    FILE* file = fopen("nonexistent.txt", "r");
    if (file == NULL) {
        printf("   - 文件不存在：%s\n", strerror(errno));
    } else {
        fclose(file);
    }
    
    // 2. 文件状态检查
    printf("\n2. 文件状态检查：\n");
    file = fopen("status_test.txt", "w+");
    if (file) {
        // 写入一些数据
        fprintf(file, "测试数据");
        
        // 检查文件结束
        if (feof(file)) {
            printf("   - 到达文件末尾\n");
        } else {
            printf("   - 未到达文件末尾\n");
        }
        
        // 检查错误状态
        if (ferror(file)) {
            printf("   - 发生I/O错误\n");
        } else {
            printf("   - 无I/O错误\n");
        }
        
        // 移动到文件末尾并尝试读取
        fseek(file, 0, SEEK_END);
        int ch = fgetc(file);
        
        if (feof(file)) {
            printf("   - 读取后到达文件末尾\n");
        }
        
        // 清除错误标志
        clearerr(file);
        printf("   - 清除错误标志\n");
        
        fclose(file);
    }
    
    // 3. 安全的文件操作包装
    printf("\n3. 安全的文件操作：\n");
    if (safe_file_write("safe_test.txt", "安全写入的数据\n")) {
        printf("   - 安全写入成功\n");
    }
    
    char read_buffer[256];
    if (safe_file_read("safe_test.txt", read_buffer, sizeof(read_buffer))) {
        printf("   - 安全读取：%s", read_buffer);
    }
}

// 安全的文件写入函数
int safe_file_write(const char* filename, const char* data) {
    FILE* file = fopen(filename, "w");
    if (file == NULL) {
        fprintf(stderr, "无法打开文件 %s 进行写入：%s\n", filename, strerror(errno));
        return 0;
    }
    
    if (fprintf(file, "%s", data) < 0) {
        fprintf(stderr, "写入文件 %s 失败：%s\n", filename, strerror(errno));
        fclose(file);
        return 0;
    }
    
    if (fclose(file) != 0) {
        fprintf(stderr, "关闭文件 %s 失败：%s\n", filename, strerror(errno));
        return 0;
    }
    
    return 1;
}

// 安全的文件读取函数
int safe_file_read(const char* filename, char* buffer, size_t buffer_size) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) {
        fprintf(stderr, "无法打开文件 %s 进行读取：%s\n", filename, strerror(errno));
        return 0;
    }
    
    if (fgets(buffer, buffer_size, file) == NULL) {
        if (feof(file)) {
            fprintf(stderr, "文件 %s 为空\n", filename);
        } else {
            fprintf(stderr, "读取文件 %s 失败：%s\n", filename, strerror(errno));
        }
        fclose(file);
        return 0;
    }
    
    fclose(file);
    return 1;
}
```

## 5. 二进制文件处理与数据序列化

### 5.1 结构体的文件存储

```c
#include <stdint.h>

// 学生信息结构体
typedef struct {
    uint32_t id;
    char name[64];
    float score;
    uint16_t age;
    char grade;
    char padding[3];  // 显式填充，确保结构体大小一致
} Student;

// 二进制文件处理演示
void binary_file_processing_demo() {
    printf("\n=== 二进制文件处理演示 ===\n");
    
    // 1. 创建测试数据
    Student students[] = {
        {1001, "张三", 85.5f, 20, 'A', {0}},
        {1002, "李四", 92.0f, 19, 'A', {0}},
        {1003, "王五", 78.5f, 21, 'B', {0}},
        {1004, "赵六", 88.0f, 20, 'A', {0}}
    };
    int student_count = sizeof(students) / sizeof(students[0]);
    
    printf("1. 写入结构体数据到二进制文件：\n");
    FILE* file = fopen("students.dat", "wb");
    if (file) {
        // 写入学生数量
        fwrite(&student_count, sizeof(int), 1, file);
        
        // 写入学生数据
        size_t written = fwrite(students, sizeof(Student), student_count, file);
        printf("   - 成功写入%zu个学生记录\n", written);
        
        fclose(file);
    }
    
    // 2. 从二进制文件读取数据
    printf("\n2. 从二进制文件读取结构体数据：\n");
    file = fopen("students.dat", "rb");
    if (file) {
        int read_count;
        fread(&read_count, sizeof(int), 1, file);
        printf("   - 文件中有%d个学生记录\n", read_count);
        
        Student* read_students = malloc(read_count * sizeof(Student));
        if (read_students) {
            size_t read = fread(read_students, sizeof(Student), read_count, file);
            printf("   - 成功读取%zu个学生记录：\n", read);
            
            for (int i = 0; i < read; i++) {
                printf("     ID:%u, 姓名:%s, 成绩:%.1f, 年龄:%u, 等级:%c\n",
                       read_students[i].id, read_students[i].name,
                       read_students[i].score, read_students[i].age,
                       read_students[i].grade);
            }
            
            free(read_students);
        }
        fclose(file);
    }
    
    // 3. 随机访问二进制文件
    printf("\n3. 随机访问二进制文件：\n");
    file = fopen("students.dat", "r+b");
    if (file) {
        // 跳过学生数量，直接定位到第2个学生记录
        fseek(file, sizeof(int) + sizeof(Student), SEEK_SET);
        
        Student student;
        if (fread(&student, sizeof(Student), 1, file) == 1) {
            printf("   - 读取第2个学生：%s, 成绩:%.1f\n", student.name, student.score);
            
            // 修改成绩
            student.score = 95.0f;
            
            // 回到该记录位置并写入
            fseek(file, sizeof(int) + sizeof(Student), SEEK_SET);
            fwrite(&student, sizeof(Student), 1, file);
            printf("   - 修改第2个学生成绩为%.1f\n", student.score);
        }
        
        fclose(file);
    }
}
```

### 5.2 自定义序列化格式

```c
// 自定义序列化演示
void custom_serialization_demo() {
    printf("\n=== 自定义序列化演示 ===\n");
    
    // 1. 文本格式序列化
    printf("1. 文本格式序列化：\n");
    Student student = {2001, "自定义学生", 87.5f, 22, 'B', {0}};
    
    FILE* text_file = fopen("student.txt", "w");
    if (text_file) {
        fprintf(text_file, "STUDENT_RECORD_V1\n");
        fprintf(text_file, "ID=%u\n", student.id);
        fprintf(text_file, "NAME=%s\n", student.name);
        fprintf(text_file, "SCORE=%.2f\n", student.score);
        fprintf(text_file, "AGE=%u\n", student.age);
        fprintf(text_file, "GRADE=%c\n", student.grade);
        fprintf(text_file, "END_RECORD\n");
        fclose(text_file);
        printf("   - 文本格式序列化完成\n");
    }
    
    // 2. 读取文本格式
    text_file = fopen("student.txt", "r");
    if (text_file) {
        char line[256];
        Student read_student = {0};
        
        while (fgets(line, sizeof(line), text_file)) {
            if (strncmp(line, "ID=", 3) == 0) {
                sscanf(line, "ID=%u", &read_student.id);
            } else if (strncmp(line, "NAME=", 5) == 0) {
                sscanf(line, "NAME=%63s", read_student.name);
            } else if (strncmp(line, "SCORE=", 6) == 0) {
                sscanf(line, "SCORE=%f", &read_student.score);
            } else if (strncmp(line, "AGE=", 4) == 0) {
                sscanf(line, "AGE=%hu", &read_student.age);
            } else if (strncmp(line, "GRADE=", 6) == 0) {
                sscanf(line, "GRADE=%c", &read_student.grade);
            }
        }
        fclose(text_file);
        
        printf("   - 反序列化结果：ID=%u, 姓名=%s, 成绩=%.2f\n",
               read_student.id, read_student.name, read_student.score);
    }
    
    // 3. 带校验和的二进制格式
    printf("\n2. 带校验和的二进制序列化：\n");
    FILE* checksum_file = fopen("student_checksum.dat", "wb");
    if (checksum_file) {
        // 写入魔数（文件格式标识）
        uint32_t magic = 0x53545544;  // "STUD"
        fwrite(&magic, sizeof(uint32_t), 1, checksum_file);
        
        // 写入版本号
        uint16_t version = 1;
        fwrite(&version, sizeof(uint16_t), 1, checksum_file);
        
        // 计算校验和（简单的异或校验）
        uint32_t checksum = 0;
        uint8_t* data = (uint8_t*)&student;
        for (size_t i = 0; i < sizeof(Student); i++) {
            checksum ^= data[i];
        }
        
        // 写入校验和
        fwrite(&checksum, sizeof(uint32_t), 1, checksum_file);
        
        // 写入数据
        fwrite(&student, sizeof(Student), 1, checksum_file);
        
        fclose(checksum_file);
        printf("   - 带校验和的序列化完成，校验和：0x%08X\n", checksum);
    }
}
```

## 6. 高性能I/O编程技巧

### 6.1 缓冲区优化策略

```c
#include <sys/stat.h>
#include <time.h>

// 性能测试函数
double get_time_diff(clock_t start, clock_t end) {
    return ((double)(end - start)) / CLOCKS_PER_SEC;
}

// I/O性能优化演示
void io_performance_optimization_demo() {
    printf("\n=== I/O性能优化演示 ===\n");
    
    const int data_size = 1000000;  // 100万个整数
    int* test_data = malloc(data_size * sizeof(int));
    
    // 初始化测试数据
    for (int i = 0; i < data_size; i++) {
        test_data[i] = i;
    }
    
    clock_t start, end;
    
    // 1. 小缓冲区写入测试
    printf("1. 小缓冲区写入测试（逐个写入）：\n");
    start = clock();
    FILE* file = fopen("small_buffer_test.dat", "wb");
    if (file) {
        for (int i = 0; i < data_size; i++) {
            fwrite(&test_data[i], sizeof(int), 1, file);
        }
        fclose(file);
    }
    end = clock();
    printf("   - 耗时：%.3f秒\n", get_time_diff(start, end));
    
    // 2. 大缓冲区写入测试
    printf("\n2. 大缓冲区写入测试（批量写入）：\n");
    start = clock();
    file = fopen("large_buffer_test.dat", "wb");
    if (file) {
        fwrite(test_data, sizeof(int), data_size, file);
        fclose(file);
    }
    end = clock();
    printf("   - 耗时：%.3f秒\n", get_time_diff(start, end));
    
    // 3. 自定义缓冲区大小测试
    printf("\n3. 自定义缓冲区大小测试：\n");
    const size_t buffer_sizes[] = {1024, 4096, 16384, 65536};
    const int buffer_count = sizeof(buffer_sizes) / sizeof(buffer_sizes[0]);
    
    for (int i = 0; i < buffer_count; i++) {
        char filename[64];
        sprintf(filename, "custom_buffer_%zu.dat", buffer_sizes[i]);
        
        start = clock();
        file = fopen(filename, "wb");
        if (file) {
            char* custom_buffer = malloc(buffer_sizes[i]);
            if (custom_buffer) {
                setvbuf(file, custom_buffer, _IOFBF, buffer_sizes[i]);
                
                for (int j = 0; j < data_size; j++) {
                    fwrite(&test_data[j], sizeof(int), 1, file);
                }
                
                free(custom_buffer);
            }
            fclose(file);
        }
        end = clock();
        printf("   - %zu字节缓冲区耗时：%.3f秒\n", 
               buffer_sizes[i], get_time_diff(start, end));
    }
    
    free(test_data);
}
```

### 6.2 内存映射I/O（概念演示）

```c
// 内存映射I/O概念演示（简化版本）
void memory_mapped_io_concept_demo() {
    printf("\n=== 内存映射I/O概念演示 ===\n");
    
    printf("内存映射I/O的优势：\n");
    printf("- 减少数据拷贝：直接在内存中操作文件数据\n");
    printf("- 提高性能：避免系统调用开销\n");
    printf("- 简化编程：像操作内存一样操作文件\n");
    printf("- 共享内存：多个进程可以共享同一文件映射\n");
    
    printf("\n传统I/O vs 内存映射I/O：\n");
    printf("传统I/O：应用程序 -> 系统调用 -> 内核缓冲区 -> 磁盘\n");
    printf("内存映射：应用程序 -> 直接内存访问 -> 磁盘（由OS管理）\n");
    
    // 模拟内存映射的概念
    printf("\n模拟内存映射操作：\n");
    
    // 创建一个大文件用于演示
    FILE* large_file = fopen("large_data.dat", "wb");
    if (large_file) {
        const int size = 1000000;
        for (int i = 0; i < size; i++) {
            fwrite(&i, sizeof(int), 1, large_file);
        }
        fclose(large_file);
        printf("   - 创建了包含%d个整数的大文件\n", size);
    }
    
    // 传统方式读取和修改
    printf("   - 传统方式：需要读取->修改->写回\n");
    large_file = fopen("large_data.dat", "r+b");
    if (large_file) {
        // 读取第1000个数据
        fseek(large_file, 1000 * sizeof(int), SEEK_SET);
        int value;
        fread(&value, sizeof(int), 1, large_file);
        
        // 修改并写回
        value *= 2;
        fseek(large_file, 1000 * sizeof(int), SEEK_SET);
        fwrite(&value, sizeof(int), 1, large_file);
        
        fclose(large_file);
        printf("     修改第1000个数据完成\n");
    }
    
    printf("   - 内存映射方式：直接在内存中修改（概念演示）\n");
    printf("     // 伪代码：\n");
    printf("     // int* mapped_data = mmap(file, size);\n");
    printf("     // mapped_data[1000] *= 2;  // 直接修改\n");
    printf("     // munmap(mapped_data, size);\n");
}
```

## 7. 实际项目：日志系统实现

### 7.1 多级日志系统

```c
// 日志级别定义
typedef enum {
    LOG_DEBUG = 0,
    LOG_INFO = 1,
    LOG_WARNING = 2,
    LOG_ERROR = 3,
    LOG_CRITICAL = 4
} LogLevel;

// 日志系统结构
typedef struct {
    FILE* file;
    LogLevel min_level;
    int max_file_size;
    int current_file_size;
    char base_filename[256];
    int file_index;
    int console_output;
} Logger;

// 日志级别名称
const char* log_level_names[] = {
    "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"
};

// 初始化日志系统
Logger* logger_init(const char* filename, LogLevel min_level, int max_file_size) {
    Logger* logger = malloc(sizeof(Logger));
    if (!logger) return NULL;
    
    strncpy(logger->base_filename, filename, sizeof(logger->base_filename) - 1);
    logger->base_filename[sizeof(logger->base_filename) - 1] = '\0';
    
    logger->min_level = min_level;
    logger->max_file_size = max_file_size;
    logger->current_file_size = 0;
    logger->file_index = 0;
    logger->console_output = 1;
    
    // 打开日志文件
    logger->file = fopen(filename, "a");
    if (logger->file) {
        // 获取当前文件大小
        fseek(logger->file, 0, SEEK_END);
        logger->current_file_size = ftell(logger->file);
    }
    
    return logger;
}

// 日志轮转
void logger_rotate(Logger* logger) {
    if (!logger || !logger->file) return;
    
    fclose(logger->file);
    
    // 生成新的文件名
    char new_filename[512];
    snprintf(new_filename, sizeof(new_filename), "%s.%d", 
             logger->base_filename, ++logger->file_index);
    
    logger->file = fopen(new_filename, "w");
    logger->current_file_size = 0;
}

// 写入日志
void logger_log(Logger* logger, LogLevel level, const char* format, ...) {
    if (!logger || level < logger->min_level) return;
    
    // 检查是否需要轮转
    if (logger->current_file_size > logger->max_file_size) {
        logger_rotate(logger);
    }
    
    // 获取当前时间
    time_t now = time(NULL);
    struct tm* tm_info = localtime(&now);
    char time_str[64];
    strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", tm_info);
    
    // 格式化消息
    va_list args;
    va_start(args, format);
    
    char message[1024];
    vsnprintf(message, sizeof(message), format, args);
    va_end(args);
    
    // 构建完整的日志行
    char log_line[1200];
    int line_length = snprintf(log_line, sizeof(log_line), 
                              "[%s] [%s] %s\n", 
                              time_str, log_level_names[level], message);
    
    // 写入文件
    if (logger->file) {
        fputs(log_line, logger->file);
        fflush(logger->file);  // 确保立即写入
        logger->current_file_size += line_length;
    }
    
    // 控制台输出
    if (logger->console_output) {
        printf("%s", log_line);
    }
}

// 关闭日志系统
void logger_close(Logger* logger) {
    if (logger) {
        if (logger->file) {
            fclose(logger->file);
        }
        free(logger);
    }
}

// 日志系统演示
void logging_system_demo() {
    printf("\n=== 日志系统演示 ===\n");
    
    // 初始化日志系统
    Logger* logger = logger_init("application.log", LOG_INFO, 1024);
    if (!logger) {
        printf("日志系统初始化失败\n");
        return;
    }
    
    printf("日志系统初始化成功\n");
    
    // 写入不同级别的日志
    logger_log(logger, LOG_DEBUG, "这是调试信息（不会显示，因为级别太低）");
    logger_log(logger, LOG_INFO, "应用程序启动");
    logger_log(logger, LOG_INFO, "用户 %s 登录成功", "admin");
    logger_log(logger, LOG_WARNING, "内存使用率达到 %d%%", 85);
    logger_log(logger, LOG_ERROR, "数据库连接失败：%s", "连接超时");
    logger_log(logger, LOG_CRITICAL, "系统即将关闭");
    
    // 测试日志轮转
    printf("\n测试日志轮转：\n");
    for (int i = 0; i < 50; i++) {
        logger_log(logger, LOG_INFO, "测试消息 #%d - 这是一条用于测试日志轮转的长消息", i);
    }
    
    printf("日志轮转测试完成\n");
    
    // 关闭日志系统
    logger_close(logger);
    printf("日志系统已关闭\n");
}
```

### 7.2 配置文件处理系统

```c
// 配置项结构
typedef struct ConfigItem {
    char key[64];
    char value[256];
    struct ConfigItem* next;
} ConfigItem;

// 配置管理器
typedef struct {
    ConfigItem* items;
    char filename[256];
    int modified;
} ConfigManager;

// 创建配置管理器
ConfigManager* config_create(const char* filename) {
    ConfigManager* config = malloc(sizeof(ConfigManager));
    if (!config) return NULL;
    
    config->items = NULL;
    config->modified = 0;
    strncpy(config->filename, filename, sizeof(config->filename) - 1);
    config->filename[sizeof(config->filename) - 1] = '\0';
    
    return config;
}

// 添加或更新配置项
void config_set(ConfigManager* config, const char* key, const char* value) {
    if (!config || !key || !value) return;
    
    // 查找现有项
    ConfigItem* item = config->items;
    while (item) {
        if (strcmp(item->key, key) == 0) {
            // 更新现有项
            strncpy(item->value, value, sizeof(item->value) - 1);
            item->value[sizeof(item->value) - 1] = '\0';
            config->modified = 1;
            return;
        }
        item = item->next;
    }
    
    // 创建新项
    ConfigItem* new_item = malloc(sizeof(ConfigItem));
    if (new_item) {
        strncpy(new_item->key, key, sizeof(new_item->key) - 1);
        new_item->key[sizeof(new_item->key) - 1] = '\0';
        strncpy(new_item->value, value, sizeof(new_item->value) - 1);
        new_item->value[sizeof(new_item->value) - 1] = '\0';
        new_item->next = config->items;
        config->items = new_item;
        config->modified = 1;
    }
}

// 获取配置项
const char* config_get(ConfigManager* config, const char* key, const char* default_value) {
    if (!config || !key) return default_value;
    
    ConfigItem* item = config->items;
    while (item) {
        if (strcmp(item->key, key) == 0) {
            return item->value;
        }
        item = item->next;
    }
    
    return default_value;
}

// 从文件加载配置
int config_load(ConfigManager* config) {
    if (!config) return 0;
    
    FILE* file = fopen(config->filename, "r");
    if (!file) return 0;
    
    char line[512];
    int line_number = 0;
    
    while (fgets(line, sizeof(line), file)) {
        line_number++;
        
        // 移除换行符
        size_t len = strlen(line);
        if (len > 0 && line[len-1] == '\n') {
            line[len-1] = '\0';
        }
        
        // 跳过空行和注释
        if (line[0] == '\0' || line[0] == '#' || line[0] == ';') {
            continue;
        }
        
        // 解析键值对
        char* equals = strchr(line, '=');
        if (equals) {
            *equals = '\0';
            char* key = line;
            char* value = equals + 1;
            
            // 去除前后空格（简化版本）
            while (*key == ' ' || *key == '\t') key++;
            while (*value == ' ' || *value == '\t') value++;
            
            config_set(config, key, value);
        }
    }
    
    fclose(file);
    config->modified = 0;
    return 1;
}

// 保存配置到文件
int config_save(ConfigManager* config) {
    if (!config || !config->modified) return 1;
    
    FILE* file = fopen(config->filename, "w");
    if (!file) return 0;
    
    // 写入文件头
    fprintf(file, "# 配置文件\n");
    fprintf(file, "# 自动生成于 ");
    
    time_t now = time(NULL);
    struct tm* tm_info = localtime(&now);
    fprintf(file, "%04d-%02d-%02d %02d:%02d:%02d\n\n",
            tm_info->tm_year + 1900, tm_info->tm_mon + 1, tm_info->tm_mday,
            tm_info->tm_hour, tm_info->tm_min, tm_info->tm_sec);
    
    // 写入配置项
    ConfigItem* item = config->items;
    while (item) {
        fprintf(file, "%s=%s\n", item->key, item->value);
        item = item->next;
    }
    
    fclose(file);
    config->modified = 0;
    return 1;
}

// 释放配置管理器
void config_free(ConfigManager* config) {
    if (!config) return;
    
    ConfigItem* item = config->items;
    while (item) {
        ConfigItem* next = item->next;
        free(item);
        item = next;
    }
    
    free(config);
}

// 配置系统演示
void config_system_demo() {
    printf("\n=== 配置文件处理系统演示 ===\n");
    
    // 创建配置管理器
    ConfigManager* config = config_create("app_config.ini");
    if (!config) {
        printf("配置管理器创建失败\n");
        return;
    }
    
    // 设置一些配置项
    printf("1. 设置配置项：\n");
    config_set(config, "server.host", "localhost");
    config_set(config, "server.port", "8080");
    config_set(config, "database.url", "postgresql://localhost:5432/mydb");
    config_set(config, "logging.level", "INFO");
    config_set(config, "cache.enabled", "true");
    
    printf("   - 已设置5个配置项\n");
    
    // 保存配置
    printf("\n2. 保存配置到文件：\n");
    if (config_save(config)) {
        printf("   - 配置保存成功\n");
    }
    
    // 读取配置
    printf("\n3. 读取配置项：\n");
    printf("   - 服务器主机：%s\n", config_get(config, "server.host", "未设置"));
    printf("   - 服务器端口：%s\n", config_get(config, "server.port", "未设置"));
    printf("   - 数据库URL：%s\n", config_get(config, "database.url", "未设置"));
    printf("   - 日志级别：%s\n", config_get(config, "logging.level", "未设置"));
    printf("   - 缓存启用：%s\n", config_get(config, "cache.enabled", "未设置"));
    printf("   - 不存在的项：%s\n", config_get(config, "nonexistent", "默认值"));
    
    // 释放配置管理器
    config_free(config);
    
    // 重新加载配置
    printf("\n4. 重新加载配置：\n");
    config = config_create("app_config.ini");
    if (config_load(config)) {
        printf("   - 配置加载成功\n");
        printf("   - 重新读取服务器端口：%s\n", config_get(config, "server.port", "未找到"));
    }
    
    config_free(config);
    printf("配置系统演示完成\n");
}
```

## 8. 主函数和综合演示

```c
// 主函数
int main() {
    printf("C语言输入输出与文件操作综合演示\n");
    printf("==========================================\n");
    
    // 基础概念演示
    io_abstraction_demo();
    io_layers_demo();
    
    // 流和缓冲机制
    stream_characteristics_demo();
    buffering_mechanism_demo();
    
    // 高级I/O操作
    advanced_formatted_io_demo();
    character_line_processing_demo();
    
    // 文件操作
    file_open_modes_demo();
    file_status_error_handling_demo();
    
    // 二进制文件处理
    binary_file_processing_demo();
    custom_serialization_demo();
    
    // 性能优化
    io_performance_optimization_demo();
    memory_mapped_io_concept_demo();
    
    // 实际项目
    logging_system_demo();
    config_system_demo();
    
    printf("\n==========================================\n");
    printf("所有演示完成！\n");
    
    return 0;
}
```

## 总结

### 核心要点回顾

1. **I/O系统设计理念**
   - "一切皆文件"的抽象统一了各种I/O操作
   - 流的概念提供了简洁而强大的数据处理模型
   - 分层架构确保了可移植性和性能的平衡

2. **缓冲机制的重要性**
   - 理解不同缓冲模式的适用场景
   - 合理配置缓冲区大小可以显著提升性能
   - 及时刷新缓冲区确保数据的完整性

3. **文件操作的最佳实践**
   - 始终检查文件操作的返回值
   - 正确处理错误情况和异常状态
   - 及时关闭文件资源，避免资源泄漏

4. **二进制文件处理技巧**
   - 注意数据结构的内存对齐和填充
   - 考虑跨平台的字节序问题
   - 实现健壮的序列化和反序列化机制

5. **性能优化策略**
   - 选择合适的I/O函数和缓冲策略
   - 批量操作优于频繁的小操作
   - 了解底层存储设备的特性

### 进阶学习方向

1. **系统级I/O编程**
   - 学习POSIX I/O函数（open, read, write等）
   - 掌握异步I/O和非阻塞I/O技术
   - 理解I/O多路复用（select, poll, epoll）

2. **网络I/O编程**
   - 套接字编程基础
   - TCP/UDP协议的实现
   - 高性能网络服务器设计

3. **内存映射和共享内存**
   - mmap系统调用的使用
   - 共享内存的进程间通信
   - 内存映射文件的高级应用

4. **跨平台I/O编程**
   - Windows和Unix/Linux的I/O差异
   - 可移植的I/O代码编写技巧
   - 条件编译和抽象层设计

通过深入理解C语言的I/O系统，你将能够编写出高效、可靠、可维护的文件处理程序。记住，良好的I/O设计是构建健壮应用程序的基础！
