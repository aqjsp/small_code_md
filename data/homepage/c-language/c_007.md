# C语言预处理器与宏编程

## 学习目标

通过本章学习，你将掌握：
- 预处理器的工作原理和基本指令
- 宏定义的语法和高级应用技巧
- 条件编译在跨平台开发中的应用
- 宏编程的最佳实践和常见陷阱
- 现代C语言中宏的合理使用方式

## 1. 预处理器基础

### 1.1 预处理器概述

预处理器在编译之前对源代码进行文本级别的处理。

#define 是 C语言里的一种预处理指令，用于定义宏（macro）。所谓宏，可以简单理解成是一种"查找并替换"的工具，它可以让 C语言预处理器（preprocessor）在编译之前将代码中的某些标识符替换为指定的内容。

C语言程序里定义的宏，可以是简单的常量，也可以是带参数的复杂表达式，它的主要作用包括：
1. **定义常量**：避免在代码中使用魔法数字，提高可读性和可维护性
2. **代码复用**：将常用的代码片段定义为宏，减少重复代码
3. **条件编译**：根据不同条件编译不同的代码版本
4. **提高效率**：避免函数调用的开销（内联展开）

- 定义常量
- 简化重复代码，提高可维护性
- 实现条件编译或调试功能

```c
// 预处理器的主要功能：
// 1. 文件包含 (#include)
// 2. 宏定义和展开 (#define)
// 3. 条件编译 (#if, #ifdef, #ifndef)
// 4. 其他指令 (#pragma, #error, #line)

#include <stdio.h>      // 包含标准库头文件
#include "myheader.h"   // 包含用户定义头文件

#define PI 3.14159      // 定义符号常量
#define MAX(a,b) ((a)>(b)?(a):(b))  // 定义函数式宏

#ifdef DEBUG
    #define DBG_PRINT(x) printf(x)
#else
    #define DBG_PRINT(x)
#endif
```

### 1.2 预定义宏概述

C语言中的预定义宏，是由编译器自动定义好的宏，我们可以直接在代码中使用，而不需要提前定义。预定义宏是编译器内置的宏定义，它们在编译时会被自动替换为相应的值，为程序提供了编译时的环境信息。

以下是C语言中常用的预定义宏及其含义：

| 预定义宏 | 含义 |
|---------|------|
| `__FILE__` | 当前源文件名 |
| `__LINE__` | 当前源代码行号 |
| `__DATE__` | 编译日期 |
| `__TIME__` | 编译时间 |
| `__STDC__` | 指明当前编译器是否符合 ISO C（ANSI C） 标准 |
| `__STDC_VERSION__` | 详细的 C 标准版本信息 |
| `__FUNCTION__` | 当前函数名（C99 引入） |

```c
#include <stdio.h>

int main() {
    printf("文件名: %s\n", __FILE__);
    printf("行号: %d\n", __LINE__);
    printf("编译日期: %s\n", __DATE__);
    printf("编译时间: %s\n", __TIME__);
    
    #ifdef __STDC__
    printf("符合标准C\n");
    #endif
    
    #ifdef __STDC_VERSION__
    printf("C标准版本: %ld\n", __STDC_VERSION__);
    #endif
    
    return 0;
}
```

#### 1.2.1 __FILE__ 和 __LINE__ 预定义宏

`__FILE__` 宏用于获取当前源文件的名称。`__FILE__`会被替换为一个字符串，包含了正在编译的源文件的名称。这个宏在程序调试和日志生成中特别有用，可以帮助我们快速定位发生问题的文件。当程序出现错误时，通过 `__FILE__` 宏可以准确知道错误发生在哪个源文件中。

`__LINE__` 宏用于获取当前代码行的行号。`__LINE__`会被替换为一个整数，表示当前代码在源文件中的行号。这个宏通常与 `__FILE__` 一起使用，可以精确定位代码的位置，对于程序调试和错误报告非常有帮助。在调试过程中，结合使用这两个宏可以快速定位问题所在的具体位置。

#### 1.2.2 __DATE__ 和 __TIME__ 预定义宏

`__DATE__` 宏用于获取源文件被编译的日期，格式为 "Mmm dd yyyy"，例如 "Jun 14 2023"。这个宏可以用来记录程序的编译时间，有助于版本控制和追踪。在软件发布时，可以通过这个宏来标识程序的构建日期。

`__TIME__` 宏用于获取源文件被编译的时间，格式为 "hh:mm:ss"，例如 "23:59:59"。与 `__DATE__` 宏结合使用，可以精确记录程序的编译时间。这对于版本管理和问题追踪非常有用，特别是在需要区分同一天内不同时间编译的版本时。
```

## 2. 宏定义与展开

### 2.1 对象式宏

对象式宏用于定义符号常量。

#### #define的基本用法

#define 的基本形式如下：

```c
#define 宏名 替换文本
```

- **宏名**：通常使用全大写字母（这是惯例，便于区分变量），遵循C语言标识符规则。
- **替换文本**：可以是数字、字符串、表达式，甚至多行代码（通过续行符 \）。

注意：#define 指令必须单独占一行，以#开头，且通常放在文件顶部或头文件中。

与变量不同，宏没有类型检查，完全是文本替换，因此使用时需要格外小心。

```c
// 基本宏定义
#define PI 3.14159265359
#define MAX_SIZE 1024
#define VERSION "1.0.0"
#define TRUE 1
#define FALSE 0

// 使用示例
#include <stdio.h>

int main() {
    double radius = 5.0;
    double area = PI * radius * radius;
    
    char buffer[MAX_SIZE];
    printf("程序版本: %s\n", VERSION);
    printf("圆的面积: %.2f\n", area);
    
    return 0;
}

// 取消宏定义
#undef PI
#define PI 3.14  // 重新定义
```

在这个例子中，PI 被定义为 3.14159，在代码中任何出现 PI 的地方都会被替换为这个值。宏定义让代码更具可读性，且便于修改。

### 2.2 函数式宏

#define 还可以定义带参数的宏，类似于函数，但它是纯文本替换。

```c
// 基本函数式宏
#define SQUARE(x) ((x) * (x))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define ABS(x) ((x) < 0 ? -(x) : (x))

// 多语句宏（使用do-while(0)技巧）
#define SWAP(a, b, type) do { \
    type temp = (a); \
    (a) = (b); \
    (b) = temp; \
} while(0)

// 使用示例
#include <stdio.h>

int main() {
    int x = 5, y = 3;
    
    printf("SQUARE(%d) = %d\n", x, SQUARE(x));
    printf("MAX(%d, %d) = %d\n", x, y, MAX(x, y));
    printf("MIN(%d, %d) = %d\n", x, y, MIN(x, y));
    printf("ABS(%d) = %d\n", -x, ABS(-x));
    
    printf("交换前: x=%d, y=%d\n", x, y);
    SWAP(x, y, int);
    printf("交换后: x=%d, y=%d\n", x, y);
    
    return 0;
}
```

#### 宏定义中的括号问题

在定义中加了括号 `((x) * (x))`，这是为了避免运算优先级问题。例如，如果写成 `x * x`，使用 `SQUARE(2 + 3)` 会展开为 `2 + 3 * 2 + 3`（结果为 11），而不是预期的 `(2 + 3) * (2 + 3)`（25）。

#### 多行宏定义

如果替换文本较长，可以用续行符 `\` 将宏定义拆成多行。

```c
#include <stdio.h>

#define PRINT_MESSAGE(name) \
    printf("Hello, %s!\n", name); \
    printf("Welcome to C programming.\n")

int main() {
    PRINT_MESSAGE("Alice");
    return 0;
}
```

续行符 `\` 表示宏定义未结束，下一行仍属于同一宏。注意，每行末尾需加分号（如果需要），因为宏本身不会自动添加。

### 2.3 宏的副作用

使用宏时需要注意副作用：

```c
#include <stdio.h>

#define SQUARE(x) ((x) * (x))
#define UNSAFE_MAX(a, b) ((a) > (b) ? (a) : (b))

int main() {
    int i = 5;
    
    // 危险：参数被多次求值
    printf("SQUARE(++i) = %d\n", SQUARE(++i));  // i被递增两次
    printf("i = %d\n", i);  // i的值可能不是预期的
    
    // 重置i
    i = 5;
    int j = 3;
    
    // 危险：副作用
    printf("UNSAFE_MAX(++i, ++j) = %d\n", UNSAFE_MAX(++i, ++j));
    printf("i = %d, j = %d\n", i, j);
    
    return 0;
}

// 更安全的实现（使用GCC扩展）
#ifdef __GNUC__
#define SAFE_MAX(a, b) ({ \
    typeof(a) _a = (a); \
    typeof(b) _b = (b); \
    (_a) > (_b) ? (_a) : (_b); \
})
#endif
```

## 3. 高级宏技术

### 3.1 字符串化操作符 (#)

将宏参数转换为字符串：

```c
#include <stdio.h>

#define STRINGIFY(x) #x
#define PRINT_VAR(var) printf(#var " = %d\n", (var))

// 调试宏
#define DEBUG_PRINT(expr) \
    printf("DEBUG: %s = %d (file: %s, line: %d)\n", \
           #expr, (expr), __FILE__, __LINE__)

int main() {
    int count = 42;
    int sum = 100;
    
    // 字符串化示例
    printf("PI的字符串形式: %s\n", STRINGIFY(3.14159));
    
    // 变量打印宏
    PRINT_VAR(count);
    PRINT_VAR(sum);
    
    // 调试宏
    DEBUG_PRINT(count + sum);
    
    return 0;
}
```

### 3.2 标记粘贴操作符 (##)

将两个标记连接成一个：

```c
#include <stdio.h>

#define CONCAT(a, b) a ## b
#define MAKE_VARIABLE(name, num) int var_ ## name ## _ ## num

// 生成函数的宏
#define DECLARE_GETTER_SETTER(type, name) \
    static type _##name; \
    type get_##name(void) { return _##name; } \
    void set_##name(type value) { _##name = value; }

// 使用标记粘贴
DECLARE_GETTER_SETTER(int, age)
DECLARE_GETTER_SETTER(double, salary)

int main() {
    // 动态变量名
    MAKE_VARIABLE(test, 1) = 10;
    MAKE_VARIABLE(test, 2) = 20;
    
    printf("var_test_1 = %d\n", var_test_1);
    printf("var_test_2 = %d\n", var_test_2);
    
    // 使用生成的getter/setter
    set_age(25);
    set_salary(5000.0);
    
    printf("年龄: %d\n", get_age());
    printf("薪资: %.2f\n", get_salary());
    
    return 0;
}
```

### 3.3 可变参数宏

C99引入了可变参数宏：

```c
#include <stdio.h>

// 可变参数宏
#define DEBUG_PRINTF(format, ...) \
    printf("[DEBUG] " format, ##__VA_ARGS__)

#define LOG(level, format, ...) \
    printf("[%s] %s:%d: " format "\n", \
           level, __FILE__, __LINE__, ##__VA_ARGS__)

// 条件调试宏
#ifdef DEBUG
    #define DBG(format, ...) \
        printf("[DEBUG] %s:%d: " format "\n", \
               __FILE__, __LINE__, ##__VA_ARGS__)
#else
    #define DBG(format, ...)
#endif

int main() {
    int x = 10, y = 20;
    
    DEBUG_PRINTF("x = %d, y = %d\n", x, y);
    DEBUG_PRINTF("Hello World!\n");  // 无额外参数
    
    LOG("INFO", "程序启动");
    LOG("ERROR", "错误代码: %d", 404);
    
    DBG("调试信息: x + y = %d", x + y);
    
    return 0;
}
```

## 4. 条件编译

条件编译（conditional compiling）命令指定预处理器依据特定的条件来判断保留或删除某段源代码。例如，可以使用条件编译让源代码适用于不同的目标系统，而不需要管理该源代码的各种不同版本。条件编译是C语言预处理器的重要功能，它允许程序员根据不同的编译环境或需求选择性地编译代码段，这在跨平台开发和调试中非常有用。

条件编译区域以 #if、#ifdef 或 #ifndef 等命令作为开头，以 #endif 命令结尾。条件编译区域可以有任意数量的 #elif 命令，但最多一个 #else 命令。这种结构类似于普通的 if-else 语句，但它是在预处理阶段执行的，而不是在程序运行时执行。

### 4.1 基本条件编译

#### #if 的用法

#if 用法的一般格式为：

```c
#if 整型常量表达式1
    程序段1
#elif 整型常量表达式2
    程序段2
#elif 整型常量表达式3
    程序段3
#else
    程序段4
#endif
```

它的意思是：如果"表达式1"的值为真（非0），就对"程序段1"进行编译，否则就计算"表达式2"，结果为真的话就对"程序段2"进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。预处理器会从上到下依次检查每个条件，一旦找到为真的条件，就编译对应的代码段，并跳过其余部分。

需要注意的是，#if 命令要求判断条件为"整型常量表达式"，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。这种限制是因为条件编译在预处理阶段进行，此时变量还未分配内存，只能使用编译时已知的常量。

```c
#include <stdio.h>

// 定义调试级别
#define DEBUG_LEVEL 2

int main() {
    printf("程序开始执行\n");
    
    #ifdef DEBUG_LEVEL
        printf("调试模式已启用\n");
        
        #if DEBUG_LEVEL >= 1
            printf("基本调试信息\n");
        #endif
        
        #if DEBUG_LEVEL >= 2
            printf("详细调试信息\n");
        #endif
        
        #if DEBUG_LEVEL >= 3
            printf("完整调试信息\n");
        #endif
    #else
        printf("发布模式\n");
    #endif
    
    #ifndef NDEBUG
        printf("断言已启用\n");
    #endif
    
    return 0;
}
```

#### #ifdef 的用法

#ifdef 用法的一般格式为：

```c
#ifdef  宏名
    程序段1
#else
    程序段2
#endif
```

它的意思是，如果当前的宏已被定义过，则对"程序段1"进行编译，否则对"程序段2"进行编译。#ifdef 指令检查指定的宏是否已经通过 #define 定义过，如果定义过就编译相应的代码段，这在条件编译中非常有用。

#### #ifndef 的用法

#ifndef 用法的一般格式为：

```c
#ifndef 宏名
    程序段1 
#else 
    程序段2 
#endif
```

与 #ifdef 不同，#ifndef 的意思是，如果当前的宏未被定义，则对"程序段1"进行编译，否则对"程序段2"进行编译，这与 #ifdef 的功能正好相反。#ifndef 常用于防止头文件重复包含，是C语言中实现头文件保护的标准方法。

#### 三者之间的区别

最后需要注意的是，#if 后面跟的是"整型常量表达式"，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。这是因为 #if 需要计算表达式的值来判断真假，而 #ifdef 和 #ifndef 只需要检查宏是否存在，不涉及值的计算。

### 4.2 平台适配

预定义宏的一个重要应用是条件编译。通过使用 #ifdef、#ifndef、#if defined() 等预处理指令，我们可以根据不同的宏定义来选择性地编译代码，这在跨平台开发、调试模式切换等场景中非常有用。条件编译允许同一份源代码在不同的编译环境下产生不同的可执行程序，大大提高了代码的可移植性和灵活性。

```c
#include <stdio.h>

// 平台检测
#ifdef _WIN32
    #define PLATFORM "Windows"
    #define PATH_SEPARATOR '\\'
    #include <windows.h>
#elif defined(__linux__)
    #define PLATFORM "Linux"
    #define PATH_SEPARATOR '/'
    #include <unistd.h>
#elif defined(__APPLE__)
    #define PLATFORM "macOS"
    #define PATH_SEPARATOR '/'
    #include <unistd.h>
#else
    #define PLATFORM "Unknown"
    #define PATH_SEPARATOR '/'
#endif

// 编译器特定功能
#ifdef __GNUC__
    #define FORCE_INLINE __attribute__((always_inline)) inline
    #define DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
    #define FORCE_INLINE __forceinline
    #define DEPRECATED __declspec(deprecated)
#else
    #define FORCE_INLINE inline
    #define DEPRECATED
#endif

DEPRECATED void old_function(void) {
    printf("这是一个已废弃的函数\n");
}

FORCE_INLINE int add(int a, int b) {
    return a + b;
}

int main() {
    printf("当前平台: %s\n", PLATFORM);
    printf("路径分隔符: %c\n", PATH_SEPARATOR);
    
    printf("5 + 3 = %d\n", add(5, 3));
    
    return 0;
}
```

#### 跨平台示例

假如现在要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行。

这个程序的难点在于，不同平台下控制文字颜色的代码不一样，我们必须要能够识别出不同的平台。Windows 有专有的宏_WIN32，Linux 有专有的宏__linux__。

```c
#include <stdio.h>

int main(){
    #if _WIN32
        system("color 0c");
        printf("Welcome to C Programming Tutorial\n");
    #elif __linux__
        printf("\033[22;31mWelcome to C Programming Tutorial\n\033[22;30m");
    #else
        printf("Welcome to C Programming Tutorial\n");
    #endif
    return 0;
}
```

#if、#elif、#else 和 #endif 都是预处理命令，整段代码的意思是：如果宏 _WIN32 的值为真，就保留第 4、5 行代码，删除第 7、9 行代码；如果宏 __linux__ 的值为真，就保留第 7 行代码；如果所有的宏都为假，就保留第 9 行代码。

这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。

这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能。

## 5. 实用工具宏

### 5.1 通用工具宏

```c
#include <stdio.h>
#include <stdlib.h>

// 数组大小
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

// 结构体成员偏移
#define OFFSET_OF(type, member) ((size_t)&((type*)0)->member)

// 容器获取（Linux内核风格）
#define CONTAINER_OF(ptr, type, member) \
    ((type*)((char*)(ptr) - OFFSET_OF(type, member)))

// 安全的内存分配
#define SAFE_MALLOC(ptr, size) do { \
    (ptr) = malloc(size); \
    if (!(ptr)) { \
        fprintf(stderr, "内存分配失败: %s:%d\n", __FILE__, __LINE__); \
        exit(EXIT_FAILURE); \
    } \
} while(0)

// 安全的内存释放
#define SAFE_FREE(ptr) do { \
    if (ptr) { \
        free(ptr); \
        (ptr) = NULL; \
    } \
} while(0)

// 示例结构体
typedef struct {
    int id;
    char name[50];
    double salary;
} Employee;

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    printf("数组大小: %zu\n", ARRAY_SIZE(numbers));
    
    Employee emp = {1001, "张三", 5000.0};
    printf("name成员偏移: %zu\n", OFFSET_OF(Employee, name));
    printf("salary成员偏移: %zu\n", OFFSET_OF(Employee, salary));
    
    // 安全内存分配示例
    int *ptr;
    SAFE_MALLOC(ptr, sizeof(int) * 10);
    
    for (int i = 0; i < 10; i++) {
        ptr[i] = i * i;
    }
    
    printf("动态数组: ");
    for (int i = 0; i < 10; i++) {
        printf("%d ", ptr[i]);
    }
    printf("\n");
    
    SAFE_FREE(ptr);
    
    return 0;
}
```

### 5.2 断言和错误处理宏

```c
#include <stdio.h>
#include <stdlib.h>

// 自定义断言宏
#ifdef NDEBUG
    #define ASSERT(condition) ((void)0)
#else
    #define ASSERT(condition) do { \
        if (!(condition)) { \
            fprintf(stderr, "断言失败: %s\n", #condition); \
            fprintf(stderr, "文件: %s, 行号: %d\n", __FILE__, __LINE__); \
            abort(); \
        } \
    } while(0)
#endif

// 错误检查宏
#define CHECK_NULL(ptr) do { \
    if ((ptr) == NULL) { \
        fprintf(stderr, "空指针错误: %s\n", #ptr); \
        fprintf(stderr, "文件: %s, 行号: %d\n", __FILE__, __LINE__); \
        return -1; \
    } \
} while(0)

// 范围检查宏
#define CHECK_RANGE(value, min, max) do { \
    if ((value) < (min) || (value) > (max)) { \
        fprintf(stderr, "值 %d 超出范围 [%d, %d]\n", \
                (value), (min), (max)); \
        return -1; \
    } \
} while(0)

int divide(int a, int b) {
    ASSERT(b != 0);  // 断言除数不为零
    return a / b;
}

int process_array(int *arr, int size) {
    CHECK_NULL(arr);
    CHECK_RANGE(size, 1, 1000);
    
    printf("处理数组，大小: %d\n", size);
    return 0;
}

int main() {
    int result = divide(10, 2);
    printf("10 / 2 = %d\n", result);
    
    int arr[] = {1, 2, 3, 4, 5};
    process_array(arr, 5);
    
    // 这会触发断言失败（如果未定义NDEBUG）
    // result = divide(10, 0);
    
    return 0;
}
```

## 6. 宏的陷阱与最佳实践

### 6.1 常见陷阱

#### 1. 缺少括号导致的优先级问题

宏定义时如果不加括号，可能会导致运算优先级错误：

```c
#include <stdio.h>

// 错误的宏定义
#define SQUARE_BAD(x) x * x

// 正确的宏定义
#define SQUARE_GOOD(x) ((x) * (x))

int main() {
    int result1 = SQUARE_BAD(2 + 3);  // 展开为: 2 + 3 * 2 + 3 = 11
    int result2 = SQUARE_GOOD(2 + 3); // 展开为: ((2 + 3) * (2 + 3)) = 25
    
    printf("SQUARE_BAD(2 + 3) = %d\n", result1);   // 输出: 11
    printf("SQUARE_GOOD(2 + 3) = %d\n", result2);  // 输出: 25
    
    return 0;
}
```

#### 2. 副作用问题

宏会导致参数被多次计算，产生副作用：

```c
#include <stdio.h>

#define MAX(a, b) ((a) > (b) ? (a) : (b))

int main() {
    int x = 5, y = 3;
    
    // 副作用：x 被递增两次
    int result = MAX(++x, y);  // 展开为: ((++x) > (y) ? (++x) : (y))
    
    printf("x = %d, result = %d\n", x, result);  // x = 7, result = 7
    
    return 0;
}
```

#### 3. 多语句宏的问题

多语句宏如果不使用 do-while(0) 包装，可能导致语法错误：

```c
#include <stdio.h>

// 错误的多语句宏
#define DEBUG_PRINT_BAD(x) printf("Debug: %s = %d\n", #x, x); fflush(stdout)

// 正确的多语句宏
#define DEBUG_PRINT_GOOD(x) do { \
    printf("Debug: %s = %d\n", #x, x); \
    fflush(stdout); \
} while(0)

int main() {
    int value = 42;
    
    // 这会导致语法错误（在某些情况下）
    if (value > 0)
        DEBUG_PRINT_BAD(value);
    // 展开后变成：
    // if (value > 0)
    //     printf("Debug: %s = %d\n", "value", value); fflush(stdout);
    // 第二个语句不在 if 块内
    
    // 正确的用法
    if (value > 0)
        DEBUG_PRINT_GOOD(value);
    
    return 0;
}
```

### 6.2 最佳实践

#### 1. 宏命名规范

- 使用全大写字母命名宏，用下划线分隔单词
- 避免与标准库或系统宏冲突
- 使用有意义的名称

```c
// 好的命名
#define MAX_BUFFER_SIZE 1024
#define IS_POWER_OF_TWO(x) (((x) & ((x) - 1)) == 0)

// 不好的命名
#define max 100  // 可能与标准库冲突
#define X(a) ((a) * 2)  // 名称不明确
```

#### 2. 参数保护

始终为宏参数添加括号：

```c
// 正确的做法
#define MULTIPLY(a, b) ((a) * (b))
#define ABS(x) ((x) < 0 ? -(x) : (x))

// 错误的做法
#define MULTIPLY_BAD(a, b) a * b
#define ABS_BAD(x) x < 0 ? -x : x
```

#### 3. 多语句宏使用 do-while(0)

```c
#define SAFE_FREE(ptr) do { \
    if (ptr) { \
        free(ptr); \
        ptr = NULL; \
    } \
} while(0)
```

#### 4. 避免副作用

对于可能产生副作用的宏，考虑使用内联函数替代：

```c
// 宏版本（有副作用）
#define MAX_MACRO(a, b) ((a) > (b) ? (a) : (b))

// 内联函数版本（无副作用）
static inline int max_func(int a, int b) {
    return a > b ? a : b;
}
```

#### 5. 宏与函数的选择

| 特性 | 宏 | 函数 |
|------|----|----|  
| 执行速度 | 快（无函数调用开销） | 相对较慢 |
| 代码大小 | 可能增大（代码展开） | 较小 |
| 类型检查 | 无 | 有 |
| 副作用 | 可能有 | 无 |
| 调试 | 困难 | 容易 |
| 适用场景 | 简单操作、常量定义 | 复杂逻辑、类型安全要求高 |

宏和函数各有优缺点，在实际开发中应根据具体需求选择合适的方式。对于简单的常量定义和文本替换，宏是很好的选择；对于复杂的逻辑处理，函数更加安全可靠。

## 7. 综合示例：配置系统

```c
#include <stdio.h>

// 配置选项
#define CONFIG_DEBUG 1
#define CONFIG_LOGGING 1
#define CONFIG_MAX_USERS 100
#define CONFIG_VERSION_MAJOR 1
#define CONFIG_VERSION_MINOR 2
#define CONFIG_VERSION_PATCH 3

// 版本字符串生成
#define STRINGIFY(x) #x
#define VERSION_STRING(major, minor, patch) \
    STRINGIFY(major) "." STRINGIFY(minor) "." STRINGIFY(patch)

// 功能开关
#if CONFIG_DEBUG
    #define DEBUG_ENABLED 1
    #define DBG_PRINT(fmt, ...) \
        printf("[DEBUG] " fmt "\n", ##__VA_ARGS__)
#else
    #define DEBUG_ENABLED 0
    #define DBG_PRINT(fmt, ...)
#endif

#if CONFIG_LOGGING
    #define LOG_ENABLED 1
    #define LOG_PRINT(level, fmt, ...) \
        printf("[%s] " fmt "\n", level, ##__VA_ARGS__)
#else
    #define LOG_ENABLED 0
    #define LOG_PRINT(level, fmt, ...)
#endif

// 编译时断言（C11特性）
#if __STDC_VERSION__ >= 201112L
    #define STATIC_ASSERT(condition, message) \
        _Static_assert(condition, message)
#else
    #define STATIC_ASSERT(condition, message) \
        typedef char static_assertion_##__LINE__[(condition) ? 1 : -1]
#endif

// 编译时检查
STATIC_ASSERT(CONFIG_MAX_USERS > 0, "Max users must be positive");
STATIC_ASSERT(CONFIG_MAX_USERS <= 1000, "Max users too large");

int main() {
    printf("程序版本: %s\n", 
           VERSION_STRING(CONFIG_VERSION_MAJOR, 
                         CONFIG_VERSION_MINOR, 
                         CONFIG_VERSION_PATCH));
    
    printf("最大用户数: %d\n", CONFIG_MAX_USERS);
    printf("调试模式: %s\n", DEBUG_ENABLED ? "启用" : "禁用");
    printf("日志记录: %s\n", LOG_ENABLED ? "启用" : "禁用");
    
    DBG_PRINT("这是调试信息");
    LOG_PRINT("INFO", "程序启动成功");
    LOG_PRINT("WARNING", "这是一个警告");
    
    return 0;
}
```

## 总结

C语言预处理器和宏系统提供了强大的代码生成和配置管理能力：

1. **预处理器**：在编译前进行文本级别的代码转换
2. **宏定义**：提供符号常量和代码模板功能
3. **条件编译**：实现平台适配和功能开关
4. **高级技术**：字符串化、标记粘贴、可变参数等
5. **最佳实践**：避免副作用，正确使用括号和do-while结构

合理使用预处理器和宏可以提高代码的可维护性和可移植性，但要注意避免过度使用和常见陷阱。在现代C++中，许多宏的功能可以用更安全的模板和constexpr来替代。
