# C语言预处理器与宏编程

## 1. 预处理器系统的深度解析

### 1.1 预处理器的设计哲学与架构

C语言预处理器体现了"简单而强大"的设计哲学，它是一个独立的文本处理器，在编译器之前运行。

```c
// 预处理器处理流程演示
#include <stdio.h>

// 第一阶段：字符映射和注释处理
/* 这个注释会被替换为空格 */ int value = 42;

// 第二阶段：行拼接处理
#define LONG_MACRO(x) \
    do { \
        printf("Processing: %d\n", x); \
        printf("Result: %d\n", x * 2); \
    } while(0)

// 第三阶段：标记化
#define MAX(a, b) ((a) > (b) ? (a) : (b))

// 第四阶段：宏展开和指令处理
int main() {
    LONG_MACRO(10);
    printf("Max: %d\n", MAX(5, 8));
    return 0;
}
```

**预处理器的核心特征**：

```c
// 1. 文本替换的本质
#define PI 3.14159
#define CIRCLE_AREA(r) (PI * (r) * (r))

// 展开后实际代码：
// double area = (3.14159 * (5.0) * (5.0));
double area = CIRCLE_AREA(5.0);

// 2. 编译时执行
#define COMPILE_TIME_CALC (2 + 3 * 4)  // 在预处理时计算
const int result = COMPILE_TIME_CALC;  // 实际为：const int result = 14;

// 3. 递归展开能力
#define STRINGIFY(x) #x
#define EXPAND_AND_STRINGIFY(x) STRINGIFY(x)
#define VERSION_MAJOR 2
#define VERSION_MINOR 1

// 复杂的宏展开
const char* version = EXPAND_AND_STRINGIFY(VERSION_MAJOR.VERSION_MINOR);
// 展开为："2.1"
```

### 1.2 预处理阶段的详细工作流程

```c
// 演示预处理器的各个处理阶段

// 阶段1：字符映射和三字符序列
// ??= 会被转换为 #（在支持三字符序列的编译器中）
// 现代编译器通常不启用此功能

// 阶段2：行拼接演示
#define MULTI_LINE_STRING "This is a very long string that " \
                         "spans multiple lines and will be " \
                         "concatenated into a single line"

// 阶段3：标记化演示
#define TOKEN_PASTE(a, b) a##b
#define MAKE_VARIABLE(name) int TOKEN_PASTE(var_, name)

MAKE_VARIABLE(counter);  // 展开为：int var_counter;

// 阶段4：预处理指令执行
#if defined(__GNUC__)
    #define COMPILER_HINT __attribute__((always_inline))
#elif defined(_MSC_VER)
    #define COMPILER_HINT __forceinline
#else
    #define COMPILER_HINT inline
#endif

COMPILER_HINT void fast_function() {
    // 函数实现
}
```

### 1.3 预处理器的能力边界与限制

```c
// 预处理器能做的事情
#define MAX_BUFFER_SIZE 1024
#define SAFE_FREE(ptr) do { if(ptr) { free(ptr); ptr = NULL; } } while(0)

// 条件编译
#ifdef DEBUG
    #define LOG(msg) printf("DEBUG: %s\n", msg)
#else
    #define LOG(msg) ((void)0)
#endif

// 预处理器不能做的事情（这些会导致错误或问题）

// 1. 不能理解C语法结构
#define BROKEN_IF(cond) if (cond) {
// 使用：BROKEN_IF(x > 0) printf("positive"); }  // 语法错误

// 2. 不能进行类型检查
#define UNSAFE_MAX(a, b) ((a) > (b) ? (a) : (b))
// 问题：UNSAFE_MAX("hello", 42) 会编译但逻辑错误

// 3. 副作用问题
#define DANGEROUS_MAX(a, b) ((a) > (b) ? (a) : (b))
int i = 5;
int result = DANGEROUS_MAX(++i, 10);  // i 可能被递增两次！

// 4. 作用域问题
#define LOCAL_VAR int temp = 42
void function() {
    LOCAL_VAR;  // 可能与其他 temp 变量冲突
    // ...
}
```

## 2. 宏系统的深度应用

### 2.1 宏的分类与高级技巧

```c
// 对象式宏（Object-like macros）
#define MAX_SIZE 1024
#define VERSION "2.1.0"
#define DEBUG_MODE 1

// 函数式宏（Function-like macros）
#define SQUARE(x) ((x) * (x))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

// 可变参数宏（Variadic macros）
#define LOG_INFO(fmt, ...) \
    printf("[INFO] " fmt "\n", ##__VA_ARGS__)

#define LOG_ERROR(fmt, ...) \
    fprintf(stderr, "[ERROR] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)

// 使用示例
void demo_logging() {
    LOG_INFO("Application started");
    LOG_INFO("Processing %d items", 42);
    LOG_ERROR("Failed to open file: %s", "config.txt");
}

// 高级宏技巧：字符串化和标记粘贴
#define STRINGIFY(x) #x
#define CONCAT(a, b) a##b

// 创建变量名
#define DECLARE_GETTER_SETTER(type, name) \
    type CONCAT(get_, name)() { return name; } \
    void CONCAT(set_, name)(type value) { name = value; }

// 使用示例
static int age;
DECLARE_GETTER_SETTER(int, age)
// 展开为：
// int get_age() { return age; }
// void set_age(int value) { age = value; }
```

### 2.2 复杂宏系统的构建

```c
// 构建一个通用的数据结构宏系统

// 基础宏定义
#define DECLARE_LIST_TYPE(type) \
    typedef struct type##_list_node { \
        type data; \
        struct type##_list_node* next; \
    } type##_list_node_t; \
    \
    typedef struct { \
        type##_list_node_t* head; \
        type##_list_node_t* tail; \
        size_t size; \
    } type##_list_t;

#define DEFINE_LIST_FUNCTIONS(type) \
    type##_list_t* type##_list_create() { \
        type##_list_t* list = malloc(sizeof(type##_list_t)); \
        if (list) { \
            list->head = NULL; \
            list->tail = NULL; \
            list->size = 0; \
        } \
        return list; \
    } \
    \
    void type##_list_push_back(type##_list_t* list, type value) { \
        type##_list_node_t* node = malloc(sizeof(type##_list_node_t)); \
        if (!node || !list) return; \
        \
        node->data = value; \
        node->next = NULL; \
        \
        if (list->tail) { \
            list->tail->next = node; \
        } else { \
            list->head = node; \
        } \
        list->tail = node; \
        list->size++; \
    } \
    \
    type type##_list_get(type##_list_t* list, size_t index) { \
        if (!list || index >= list->size) { \
            type default_value = {0}; \
            return default_value; \
        } \
        \
        type##_list_node_t* current = list->head; \
        for (size_t i = 0; i < index; i++) { \
            current = current->next; \
        } \
        return current->data; \
    } \
    \
    void type##_list_destroy(type##_list_t* list) { \
        if (!list) return; \
        \
        type##_list_node_t* current = list->head; \
        while (current) { \
            type##_list_node_t* next = current->next; \
            free(current); \
            current = next; \
        } \
        free(list); \
    }

// 使用宏系统创建具体类型的链表
DECLARE_LIST_TYPE(int)
DEFINE_LIST_FUNCTIONS(int)

DECLARE_LIST_TYPE(double)
DEFINE_LIST_FUNCTIONS(double)

// 使用示例
void demo_generic_list() {
    // 创建整数链表
    int_list_t* int_list = int_list_create();
    int_list_push_back(int_list, 10);
    int_list_push_back(int_list, 20);
    int_list_push_back(int_list, 30);
    
    printf("First element: %d\n", int_list_get(int_list, 0));
    int_list_destroy(int_list);
    
    // 创建浮点数链表
    double_list_t* double_list = double_list_create();
    double_list_push_back(double_list, 3.14);
    double_list_push_back(double_list, 2.71);
    
    printf("First element: %.2f\n", double_list_get(double_list, 0));
    double_list_destroy(double_list);
}
```

### 2.3 宏的安全编程实践

```c
// 安全宏编程的最佳实践

// 1. 使用 do-while(0) 包装多语句宏
#define SAFE_MACRO(x) \
    do { \
        printf("Processing: %d\n", x); \
        x *= 2; \
        printf("Result: %d\n", x); \
    } while(0)

// 2. 参数多重求值问题的解决
#define UNSAFE_MAX(a, b) ((a) > (b) ? (a) : (b))
#define SAFE_MAX(a, b) \
    ({ \
        typeof(a) _a = (a); \
        typeof(b) _b = (b); \
        (_a) > (_b) ? (_a) : (_b); \
    })

// 3. 类型安全的宏设计
#define TYPE_SAFE_SWAP(type, a, b) \
    do { \
        type temp = (a); \
        (a) = (b); \
        (b) = temp; \
    } while(0)

// 4. 防止宏名冲突
#define MY_PROJECT_MAX_BUFFER_SIZE 1024
#define MY_PROJECT_LOG(msg) printf("[MY_PROJECT] %s\n", msg)

// 5. 条件宏定义
#ifndef MY_ASSERT
    #ifdef DEBUG
        #define MY_ASSERT(cond) \
            do { \
                if (!(cond)) { \
                    fprintf(stderr, "Assertion failed: %s at %s:%d\n", \
                            #cond, __FILE__, __LINE__); \
                    abort(); \
                } \
            } while(0)
    #else
        #define MY_ASSERT(cond) ((void)0)
    #endif
#endif

// 使用示例
void demo_safe_macros() {
    int a = 5, b = 10;
    
    // 安全的交换
    TYPE_SAFE_SWAP(int, a, b);
    printf("After swap: a=%d, b=%d\n", a, b);
    
    // 安全的最大值计算
    int x = 3;
    int max_val = SAFE_MAX(++x, 5);  // x 只会被递增一次
    printf("x=%d, max=%d\n", x, max_val);
    
    // 断言使用
    MY_ASSERT(max_val > 0);
}
```

## 3. 条件编译的高级应用

### 3.1 平台适配与配置管理

```c
// 复杂的平台适配系统
#ifndef CONFIG_H
#define CONFIG_H

// 平台检测
#if defined(_WIN32) || defined(_WIN64)
    #define PLATFORM_WINDOWS
    #define PATH_SEPARATOR '\\'
    #define PATH_SEPARATOR_STR "\\"
    #define NEWLINE "\r\n"
    #include <windows.h>
#elif defined(__linux__)
    #define PLATFORM_LINUX
    #define PATH_SEPARATOR '/'
    #define PATH_SEPARATOR_STR "/"
    #define NEWLINE "\n"
    #include <unistd.h>
    #include <sys/types.h>
#elif defined(__APPLE__) && defined(__MACH__)
    #define PLATFORM_MACOS
    #define PATH_SEPARATOR '/'
    #define PATH_SEPARATOR_STR "/"
    #define NEWLINE "\n"
    #include <unistd.h>
    #include <sys/types.h>
#else
    #error "Unsupported platform"
#endif

// 编译器特定优化
#ifdef __GNUC__
    #define FORCE_INLINE __attribute__((always_inline)) inline
    #define NO_INLINE __attribute__((noinline))
    #define LIKELY(x) __builtin_expect(!!(x), 1)
    #define UNLIKELY(x) __builtin_expect(!!(x), 0)
    #define DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
    #define FORCE_INLINE __forceinline
    #define NO_INLINE __declspec(noinline)
    #define LIKELY(x) (x)
    #define UNLIKELY(x) (x)
    #define DEPRECATED __declspec(deprecated)
#else
    #define FORCE_INLINE inline
    #define NO_INLINE
    #define LIKELY(x) (x)
    #define UNLIKELY(x) (x)
    #define DEPRECATED
#endif

// 功能特性配置
#define FEATURE_LOGGING 1
#define FEATURE_NETWORKING 1
#define FEATURE_GRAPHICS 0
#define FEATURE_AUDIO 1

// 性能配置
#define ENABLE_OPTIMIZATIONS 1
#define ENABLE_PROFILING 0
#define ENABLE_MEMORY_TRACKING 1

// 调试配置
#ifdef DEBUG
    #define DEBUG_LEVEL 3
    #define ENABLE_ASSERTIONS 1
    #define ENABLE_MEMORY_DEBUGGING 1
#else
    #define DEBUG_LEVEL 0
    #define ENABLE_ASSERTIONS 0
    #define ENABLE_MEMORY_DEBUGGING 0
#endif

#endif // CONFIG_H

// 使用配置的示例代码
#include "config.h"

// 平台特定的文件操作
#ifdef PLATFORM_WINDOWS
    #define OPEN_FILE(path, mode) fopen_s(&file, path, mode)
#else
    #define OPEN_FILE(path, mode) fopen(path, mode)
#endif

// 功能特性的条件编译
#if FEATURE_LOGGING
void log_message(const char* message) {
    printf("[LOG] %s%s", message, NEWLINE);
}
#else
#define log_message(msg) ((void)0)
#endif

#if FEATURE_NETWORKING
#include <sys/socket.h>
void network_init() {
    // 网络初始化代码
    log_message("Network initialized");
}
#else
void network_init() {
    log_message("Network feature disabled");
}
#endif
```

### 3.2 版本控制与API兼容性

```c
// 版本控制系统
#define VERSION_MAJOR 2
#define VERSION_MINOR 1
#define VERSION_PATCH 3
#define VERSION_BUILD 1234

#define MAKE_VERSION(major, minor, patch) \
    ((major) * 10000 + (minor) * 100 + (patch))

#define CURRENT_VERSION MAKE_VERSION(VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH)

// API版本兼容性处理
#if CURRENT_VERSION >= MAKE_VERSION(2, 1, 0)
    #define HAS_NEW_API 1
    
    // 新版本API
    typedef struct {
        int id;
        char name[64];
        double value;
        int flags;  // 新增字段
    } data_record_t;
    
    void process_record_v2(data_record_t* record) {
        printf("Processing record %d: %s (%.2f) [flags: %d]\n",
               record->id, record->name, record->value, record->flags);
    }
    
    #define process_record process_record_v2
    
#else
    #define HAS_NEW_API 0
    
    // 旧版本API
    typedef struct {
        int id;
        char name[64];
        double value;
    } data_record_t;
    
    void process_record_v1(data_record_t* record) {
        printf("Processing record %d: %s (%.2f)\n",
               record->id, record->name, record->value);
    }
    
    #define process_record process_record_v1
#endif

// 向后兼容性宏
#if CURRENT_VERSION >= MAKE_VERSION(2, 0, 0)
    #define DEPRECATED_FUNCTION(name) \
        DEPRECATED void name() { \
            fprintf(stderr, "Warning: " #name " is deprecated\n"); \
        }
#else
    #define DEPRECATED_FUNCTION(name) void name()
#endif

// 条件API暴露
#ifdef ENABLE_EXPERIMENTAL_FEATURES
    void experimental_feature() {
        printf("This is an experimental feature\n");
    }
#endif

// 使用示例
void demo_version_control() {
    data_record_t record = {1, "test", 3.14};
    
#if HAS_NEW_API
    record.flags = 0x01;
#endif
    
    process_record(&record);
    
#ifdef ENABLE_EXPERIMENTAL_FEATURES
    experimental_feature();
#endif
}
```

## 4. 文件包含系统的深度应用

### 4.1 头文件保护与模块化设计

```c
// 传统的头文件保护
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

// 现代编译器支持的 pragma once
#pragma once

// 系统头文件包含
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// 条件包含
#ifdef __cplusplus
extern "C" {
#endif

// 前向声明
struct point;
struct vector;

// 类型定义
typedef struct point {
    double x, y;
} point_t;

typedef struct vector {
    double x, y, z;
} vector_t;

// 函数声明
double distance(const point_t* p1, const point_t* p2);
vector_t cross_product(const vector_t* v1, const vector_t* v2);

// 内联函数定义
static inline double point_distance_squared(const point_t* p1, const point_t* p2) {
    double dx = p1->x - p2->x;
    double dy = p1->y - p2->y;
    return dx * dx + dy * dy;
}

#ifdef __cplusplus
}
#endif

#endif // MATH_UTILS_H
```

### 4.2 动态包含与配置驱动的模块系统

```c
// config_modules.h - 模块配置
#ifndef CONFIG_MODULES_H
#define CONFIG_MODULES_H

// 模块启用配置
#define MODULE_MATH 1
#define MODULE_STRING 1
#define MODULE_IO 1
#define MODULE_NETWORK 0
#define MODULE_GRAPHICS 0

// 根据配置动态包含模块
#if MODULE_MATH
    #define INCLUDE_MATH_MODULE
#endif

#if MODULE_STRING
    #define INCLUDE_STRING_MODULE
#endif

#if MODULE_IO
    #define INCLUDE_IO_MODULE
#endif

#if MODULE_NETWORK
    #define INCLUDE_NETWORK_MODULE
#endif

#if MODULE_GRAPHICS
    #define INCLUDE_GRAPHICS_MODULE
#endif

#endif // CONFIG_MODULES_H

// main_modules.h - 主模块包含文件
#ifndef MAIN_MODULES_H
#define MAIN_MODULES_H

#include "config_modules.h"

#ifdef INCLUDE_MATH_MODULE
    #include "modules/math_module.h"
#endif

#ifdef INCLUDE_STRING_MODULE
    #include "modules/string_module.h"
#endif

#ifdef INCLUDE_IO_MODULE
    #include "modules/io_module.h"
#endif

#ifdef INCLUDE_NETWORK_MODULE
    #include "modules/network_module.h"
#endif

#ifdef INCLUDE_GRAPHICS_MODULE
    #include "modules/graphics_module.h"
#endif

// 模块初始化宏
#define INIT_ALL_MODULES() \
    do { \
        INIT_MATH_MODULE(); \
        INIT_STRING_MODULE(); \
        INIT_IO_MODULE(); \
        INIT_NETWORK_MODULE(); \
        INIT_GRAPHICS_MODULE(); \
    } while(0)

// 条件初始化宏
#ifdef INCLUDE_MATH_MODULE
    #define INIT_MATH_MODULE() math_module_init()
#else
    #define INIT_MATH_MODULE() ((void)0)
#endif

#ifdef INCLUDE_STRING_MODULE
    #define INIT_STRING_MODULE() string_module_init()
#else
    #define INIT_STRING_MODULE() ((void)0)
#endif

#ifdef INCLUDE_IO_MODULE
    #define INIT_IO_MODULE() io_module_init()
#else
    #define INIT_IO_MODULE() ((void)0)
#endif

#ifdef INCLUDE_NETWORK_MODULE
    #define INIT_NETWORK_MODULE() network_module_init()
#else
    #define INIT_NETWORK_MODULE() ((void)0)
#endif

#ifdef INCLUDE_GRAPHICS_MODULE
    #define INIT_GRAPHICS_MODULE() graphics_module_init()
#else
    #define INIT_GRAPHICS_MODULE() ((void)0)
#endif

#endif // MAIN_MODULES_H
```

## 5. 实践项目：构建一个完整的宏系统框架

### 5.1 通用数据结构宏库

```c
// generic_containers.h - 通用容器宏库
#ifndef GENERIC_CONTAINERS_H
#define GENERIC_CONTAINERS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// 动态数组宏系统
#define DECLARE_VECTOR(type) \
    typedef struct { \
        type* data; \
        size_t size; \
        size_t capacity; \
    } type##_vector_t; \
    \
    type##_vector_t* type##_vector_create(size_t initial_capacity); \
    void type##_vector_destroy(type##_vector_t* vec); \
    bool type##_vector_push_back(type##_vector_t* vec, type value); \
    bool type##_vector_pop_back(type##_vector_t* vec, type* out_value); \
    type* type##_vector_get(type##_vector_t* vec, size_t index); \
    bool type##_vector_set(type##_vector_t* vec, size_t index, type value); \
    void type##_vector_clear(type##_vector_t* vec); \
    size_t type##_vector_size(const type##_vector_t* vec); \
    bool type##_vector_empty(const type##_vector_t* vec);

#define DEFINE_VECTOR(type) \
    type##_vector_t* type##_vector_create(size_t initial_capacity) { \
        type##_vector_t* vec = malloc(sizeof(type##_vector_t)); \
        if (!vec) return NULL; \
        \
        vec->data = malloc(sizeof(type) * initial_capacity); \
        if (!vec->data) { \
            free(vec); \
            return NULL; \
        } \
        \
        vec->size = 0; \
        vec->capacity = initial_capacity; \
        return vec; \
    } \
    \
    void type##_vector_destroy(type##_vector_t* vec) { \
        if (vec) { \
            free(vec->data); \
            free(vec); \
        } \
    } \
    \
    bool type##_vector_push_back(type##_vector_t* vec, type value) { \
        if (!vec) return false; \
        \
        if (vec->size >= vec->capacity) { \
            size_t new_capacity = vec->capacity * 2; \
            type* new_data = realloc(vec->data, sizeof(type) * new_capacity); \
            if (!new_data) return false; \
            \
            vec->data = new_data; \
            vec->capacity = new_capacity; \
        } \
        \
        vec->data[vec->size++] = value; \
        return true; \
    } \
    \
    bool type##_vector_pop_back(type##_vector_t* vec, type* out_value) { \
        if (!vec || vec->size == 0) return false; \
        \
        if (out_value) { \
            *out_value = vec->data[vec->size - 1]; \
        } \
        vec->size--; \
        return true; \
    } \
    \
    type* type##_vector_get(type##_vector_t* vec, size_t index) { \
        if (!vec || index >= vec->size) return NULL; \
        return &vec->data[index]; \
    } \
    \
    bool type##_vector_set(type##_vector_t* vec, size_t index, type value) { \
        if (!vec || index >= vec->size) return false; \
        vec->data[index] = value; \
        return true; \
    } \
    \
    void type##_vector_clear(type##_vector_t* vec) { \
        if (vec) vec->size = 0; \
    } \
    \
    size_t type##_vector_size(const type##_vector_t* vec) { \
        return vec ? vec->size : 0; \
    } \
    \
    bool type##_vector_empty(const type##_vector_t* vec) { \
        return vec ? (vec->size == 0) : true; \
    }

// 哈希表宏系统
#define DECLARE_HASHMAP(key_type, value_type) \
    typedef struct key_type##_##value_type##_pair { \
        key_type key; \
        value_type value; \
        bool occupied; \
    } key_type##_##value_type##_pair_t; \
    \
    typedef struct { \
        key_type##_##value_type##_pair_t* buckets; \
        size_t capacity; \
        size_t size; \
        size_t (*hash_func)(key_type key); \
        bool (*key_equal)(key_type a, key_type b); \
    } key_type##_##value_type##_hashmap_t; \
    \
    key_type##_##value_type##_hashmap_t* key_type##_##value_type##_hashmap_create( \
        size_t initial_capacity, \
        size_t (*hash_func)(key_type), \
        bool (*key_equal)(key_type, key_type)); \
    void key_type##_##value_type##_hashmap_destroy(key_type##_##value_type##_hashmap_t* map); \
    bool key_type##_##value_type##_hashmap_insert(key_type##_##value_type##_hashmap_t* map, \
                                                  key_type key, value_type value); \
    bool key_type##_##value_type##_hashmap_get(key_type##_##value_type##_hashmap_t* map, \
                                               key_type key, value_type* out_value); \
    bool key_type##_##value_type##_hashmap_remove(key_type##_##value_type##_hashmap_t* map, \
                                                  key_type key);

// 使用示例：创建具体类型的容器
DECLARE_VECTOR(int)
DECLARE_VECTOR(double)
DECLARE_VECTOR(char*)

DECLARE_HASHMAP(int, char*)
DECLARE_HASHMAP(char*, int)

#endif // GENERIC_CONTAINERS_H
```

### 5.2 日志系统宏框架

```c
// logging_system.h - 完整的日志系统
#ifndef LOGGING_SYSTEM_H
#define LOGGING_SYSTEM_H

#include <stdio.h>
#include <time.h>
#include <stdarg.h>
#include <string.h>

// 日志级别定义
typedef enum {
    LOG_LEVEL_TRACE = 0,
    LOG_LEVEL_DEBUG = 1,
    LOG_LEVEL_INFO = 2,
    LOG_LEVEL_WARN = 3,
    LOG_LEVEL_ERROR = 4,
    LOG_LEVEL_FATAL = 5
} log_level_t;

// 全局日志配置
extern log_level_t g_log_level;
extern FILE* g_log_file;

// 日志级别字符串
#define LOG_LEVEL_STRINGS { "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "FATAL" }

// 颜色代码（用于终端输出）
#define COLOR_RESET   "\033[0m"
#define COLOR_RED     "\033[31m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_CYAN    "\033[36m"

// 获取当前时间字符串
#define GET_TIMESTAMP(buffer) \
    do { \
        time_t now = time(NULL); \
        struct tm* tm_info = localtime(&now); \
        strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info); \
    } while(0)

// 获取文件名（不包含路径）
#define FILENAME(path) (strrchr(path, '/') ? strrchr(path, '/') + 1 : \
                       (strrchr(path, '\\') ? strrchr(path, '\\') + 1 : path))

// 核心日志宏
#define LOG_INTERNAL(level, color, fmt, ...) \
    do { \
        if (level >= g_log_level) { \
            char timestamp[32]; \
            GET_TIMESTAMP(timestamp); \
            const char* level_strings[] = LOG_LEVEL_STRINGS; \
            \
            /* 输出到控制台 */ \
            fprintf(stderr, "%s[%s] %s %s:%d %s() - " fmt "%s\n", \
                    color, level_strings[level], timestamp, \
                    FILENAME(__FILE__), __LINE__, __func__, \
                    ##__VA_ARGS__, COLOR_RESET); \
            \
            /* 输出到文件 */ \
            if (g_log_file) { \
                fprintf(g_log_file, "[%s] %s %s:%d %s() - " fmt "\n", \
                        level_strings[level], timestamp, \
                        FILENAME(__FILE__), __LINE__, __func__, \
                        ##__VA_ARGS__); \
                fflush(g_log_file); \
            } \
        } \
    } while(0)

// 各级别日志宏
#define LOG_TRACE(fmt, ...) LOG_INTERNAL(LOG_LEVEL_TRACE, COLOR_CYAN, fmt, ##__VA_ARGS__)
#define LOG_DEBUG(fmt, ...) LOG_INTERNAL(LOG_LEVEL_DEBUG, COLOR_BLUE, fmt, ##__VA_ARGS__)
#define LOG_INFO(fmt, ...)  LOG_INTERNAL(LOG_LEVEL_INFO, COLOR_GREEN, fmt, ##__VA_ARGS__)
#define LOG_WARN(fmt, ...)  LOG_INTERNAL(LOG_LEVEL_WARN, COLOR_YELLOW, fmt, ##__VA_ARGS__)
#define LOG_ERROR(fmt, ...) LOG_INTERNAL(LOG_LEVEL_ERROR, COLOR_RED, fmt, ##__VA_ARGS__)
#define LOG_FATAL(fmt, ...) LOG_INTERNAL(LOG_LEVEL_FATAL, COLOR_MAGENTA, fmt, ##__VA_ARGS__)

// 条件日志宏
#define LOG_IF(condition, level, fmt, ...) \
    do { \
        if (condition) { \
            LOG_##level(fmt, ##__VA_ARGS__); \
        } \
    } while(0)

// 性能测量宏
#define PERF_START(name) \
    clock_t perf_start_##name = clock(); \
    LOG_DEBUG("Performance measurement started: " #name)

#define PERF_END(name) \
    do { \
        clock_t perf_end_##name = clock(); \
        double perf_time_##name = ((double)(perf_end_##name - perf_start_##name)) / CLOCKS_PER_SEC; \
        LOG_INFO("Performance measurement [" #name "]: %.6f seconds", perf_time_##name); \
    } while(0)

// 断言宏
#ifdef DEBUG
    #define ASSERT(condition) \
        do { \
            if (!(condition)) { \
                LOG_FATAL("Assertion failed: " #condition); \
                abort(); \
            } \
        } while(0)
#else
    #define ASSERT(condition) ((void)0)
#endif

// 内存分配跟踪宏
#ifdef ENABLE_MEMORY_TRACKING
    #define MALLOC_TRACKED(size) \
        ({ \
            void* ptr = malloc(size); \
            LOG_DEBUG("Memory allocated: %p (%zu bytes)", ptr, size); \
            ptr; \
        })
    
    #define FREE_TRACKED(ptr) \
        do { \
            LOG_DEBUG("Memory freed: %p", ptr); \
            free(ptr); \
        } while(0)
#else
    #define MALLOC_TRACKED(size) malloc(size)
    #define FREE_TRACKED(ptr) free(ptr)
#endif

// 日志系统初始化和清理
void log_system_init(log_level_t level, const char* log_file_path);
void log_system_cleanup();

#endif // LOGGING_SYSTEM_H

// logging_system.c - 实现文件
#include "logging_system.h"

// 全局变量定义
log_level_t g_log_level = LOG_LEVEL_INFO;
FILE* g_log_file = NULL;

void log_system_init(log_level_t level, const char* log_file_path) {
    g_log_level = level;
    
    if (log_file_path) {
        g_log_file = fopen(log_file_path, "a");
        if (!g_log_file) {
            fprintf(stderr, "Failed to open log file: %s\n", log_file_path);
        }
    }
    
    LOG_INFO("Log system initialized (level: %d)", level);
}

void log_system_cleanup() {
    LOG_INFO("Log system shutting down");
    
    if (g_log_file) {
        fclose(g_log_file);
        g_log_file = NULL;
    }
}
```

### 5.3 配置管理系统

```c
// config_system.h - 配置管理系统
#ifndef CONFIG_SYSTEM_H
#define CONFIG_SYSTEM_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// 配置项类型
typedef enum {
    CONFIG_TYPE_INT,
    CONFIG_TYPE_DOUBLE,
    CONFIG_TYPE_STRING,
    CONFIG_TYPE_BOOL
} config_type_t;

// 配置项值联合体
typedef union {
    int int_val;
    double double_val;
    char* string_val;
    bool bool_val;
} config_value_t;

// 配置项结构
typedef struct config_item {
    char* key;
    config_type_t type;
    config_value_t value;
    config_value_t default_value;
    char* description;
    struct config_item* next;
} config_item_t;

// 配置管理器
typedef struct {
    config_item_t* items;
    char* config_file;
} config_manager_t;

// 配置项声明宏
#define DECLARE_CONFIG_INT(name, default_val, desc) \
    static config_item_t config_##name = { \
        .key = #name, \
        .type = CONFIG_TYPE_INT, \
        .value = {.int_val = default_val}, \
        .default_value = {.int_val = default_val}, \
        .description = desc, \
        .next = NULL \
    };

#define DECLARE_CONFIG_DOUBLE(name, default_val, desc) \
    static config_item_t config_##name = { \
        .key = #name, \
        .type = CONFIG_TYPE_DOUBLE, \
        .value = {.double_val = default_val}, \
        .default_value = {.double_val = default_val}, \
        .description = desc, \
        .next = NULL \
    };

#define DECLARE_CONFIG_STRING(name, default_val, desc) \
    static config_item_t config_##name = { \
        .key = #name, \
        .type = CONFIG_TYPE_STRING, \
        .value = {.string_val = default_val}, \
        .default_value = {.string_val = default_val}, \
        .description = desc, \
        .next = NULL \
    };

#define DECLARE_CONFIG_BOOL(name, default_val, desc) \
    static config_item_t config_##name = { \
        .key = #name, \
        .type = CONFIG_TYPE_BOOL, \
        .value = {.bool_val = default_val}, \
        .default_value = {.bool_val = default_val}, \
        .description = desc, \
        .next = NULL \
    };

// 配置访问宏
#define GET_CONFIG_INT(name) (config_##name.value.int_val)
#define GET_CONFIG_DOUBLE(name) (config_##name.value.double_val)
#define GET_CONFIG_STRING(name) (config_##name.value.string_val)
#define GET_CONFIG_BOOL(name) (config_##name.value.bool_val)

#define SET_CONFIG_INT(name, val) \
    do { config_##name.value.int_val = (val); } while(0)
#define SET_CONFIG_DOUBLE(name, val) \
    do { config_##name.value.double_val = (val); } while(0)
#define SET_CONFIG_STRING(name, val) \
    do { \
        if (config_##name.value.string_val && \
            config_##name.value.string_val != config_##name.default_value.string_val) { \
            free(config_##name.value.string_val); \
        } \
        config_##name.value.string_val = strdup(val); \
    } while(0)
#define SET_CONFIG_BOOL(name, val) \
    do { config_##name.value.bool_val = (val); } while(0)

// 配置注册宏
#define REGISTER_CONFIG(manager, name) \
    config_register_item(manager, &config_##name)

// 函数声明
config_manager_t* config_manager_create(const char* config_file);
void config_manager_destroy(config_manager_t* manager);
void config_register_item(config_manager_t* manager, config_item_t* item);
bool config_load_from_file(config_manager_t* manager);
bool config_save_to_file(config_manager_t* manager);
void config_print_all(config_manager_t* manager);
void config_reset_to_defaults(config_manager_t* manager);

#endif // CONFIG_SYSTEM_H

// 使用示例
void demo_config_system() {
    // 声明配置项
    DECLARE_CONFIG_INT(max_connections, 100, "Maximum number of connections");
    DECLARE_CONFIG_DOUBLE(timeout, 30.0, "Connection timeout in seconds");
    DECLARE_CONFIG_STRING(server_name, "MyServer", "Server name");
    DECLARE_CONFIG_BOOL(enable_logging, true, "Enable logging");
    
    // 创建配置管理器
    config_manager_t* config = config_manager_create("app.conf");
    
    // 注册配置项
    REGISTER_CONFIG(config, max_connections);
    REGISTER_CONFIG(config, timeout);
    REGISTER_CONFIG(config, server_name);
    REGISTER_CONFIG(config, enable_logging);
    
    // 加载配置
    config_load_from_file(config);
    
    // 使用配置
    printf("Max connections: %d\n", GET_CONFIG_INT(max_connections));
    printf("Timeout: %.1f\n", GET_CONFIG_DOUBLE(timeout));
    printf("Server name: %s\n", GET_CONFIG_STRING(server_name));
    printf("Logging enabled: %s\n", GET_CONFIG_BOOL(enable_logging) ? "yes" : "no");
    
    // 修改配置
    SET_CONFIG_INT(max_connections, 200);
    SET_CONFIG_STRING(server_name, "UpdatedServer");
    
    // 保存配置
    config_save_to_file(config);
    
    // 清理
    config_manager_destroy(config);
}
```

## 6. 主函数和综合演示

```c
// main.c - 综合演示程序
#include "logging_system.h"
#include "config_system.h"
#include "generic_containers.h"

// 实现容器类型
DEFINE_VECTOR(int)
DEFINE_VECTOR(double)

// 配置声明
DECLARE_CONFIG_INT(vector_size, 10, "Initial vector size");
DECLARE_CONFIG_BOOL(enable_performance_logging, true, "Enable performance logging");

int main() {
    // 初始化日志系统
    log_system_init(LOG_LEVEL_DEBUG, "app.log");
    LOG_INFO("Application started");
    
    // 初始化配置系统
    config_manager_t* config = config_manager_create("demo.conf");
    REGISTER_CONFIG(config, vector_size);
    REGISTER_CONFIG(config, enable_performance_logging);
    config_load_from_file(config);
    
    // 性能测试开始
    if (GET_CONFIG_BOOL(enable_performance_logging)) {
        PERF_START(vector_operations);
    }
    
    // 创建和使用动态数组
    int_vector_t* int_vec = int_vector_create(GET_CONFIG_INT(vector_size));
    ASSERT(int_vec != NULL);
    
    LOG_INFO("Created integer vector with capacity %d", GET_CONFIG_INT(vector_size));
    
    // 添加元素
    for (int i = 0; i < 20; i++) {
        bool success = int_vector_push_back(int_vec, i * i);
        LOG_IF(!success, ERROR, "Failed to add element %d", i);
    }
    
    LOG_INFO("Added %zu elements to vector", int_vector_size(int_vec));
    
    // 访问元素
    for (size_t i = 0; i < int_vector_size(int_vec); i++) {
        int* value = int_vector_get(int_vec, i);
        if (value) {
            LOG_TRACE("Element[%zu] = %d", i, *value);
        }
    }
    
    // 性能测试结束
    if (GET_CONFIG_BOOL(enable_performance_logging)) {
        PERF_END(vector_operations);
    }
    
    // 清理资源
    int_vector_destroy(int_vec);
    config_manager_destroy(config);
    
    LOG_INFO("Application finished successfully");
    log_system_cleanup();
    
    return 0;
}
```

## 总结

C语言预处理器是一个强大的元编程工具，它为C语言提供了在编译时生成和修改代码的能力。通过深入理解预处理器的工作原理和掌握高级宏编程技巧，我们可以：

**核心要点回顾**：

1. **预处理器本质**：理解预处理器是纯文本处理器，工作在编译之前
2. **宏系统应用**：掌握对象式宏、函数式宏和可变参数宏的使用
3. **条件编译策略**：学会使用条件编译处理平台差异和功能配置
4. **文件包含管理**：构建模块化的头文件系统和动态包含机制
5. **安全编程实践**：避免宏的常见陷阱，编写安全可维护的宏代码
6. **工程化应用**：在大型项目中合理使用预处理器提高代码复用性

**高级应用价值**：

- **代码生成**：通过宏系统生成重复性代码，减少手工编写
- **平台适配**：使用条件编译处理不同平台和编译器的差异
- **性能优化**：通过内联宏避免函数调用开销
- **调试支持**：构建灵活的调试和日志系统
- **配置管理**：实现编译时和运行时的配置管理

**学习建议**：

1. **深入理解机制**：学习预处理器的详细工作流程和处理阶段
2. **实践安全编程**：重点掌握宏编程的安全实践和常见陷阱
3. **工具使用**：学会使用编译器的预处理输出功能调试宏问题
4. **项目实践**：在实际项目中应用预处理器技术，积累经验
5. **现代替代方案**：了解C11/C18标准的新特性，合理选择技术方案
6. **持续学习**：关注编译器发展和最佳实践的演进

预处理器虽然强大，但也要谨慎使用。在现代C语言开发中，应该平衡预处理器的便利性和代码的可读性、可维护性，选择最适合项目需求的技术方案。
