# 预处理器与宏：从宏替换到条件编译

目标：掌握头文件包含、宏定义、函数式宏、条件编译、内置宏与常见陷阱；理解宏与内联、枚举常量等替代方案。

## 1. 头文件包含
- #include <...> 与 "..." 的差异：搜索路径不同
- 头文件保护：#ifndef/#define/#endif 或 #pragma once

## 2. 宏定义
- 对象式宏：#define BUF_SIZE 1024
- 函数式宏：#define MAX(a,b) ((a)>(b)?(a):(b)) 注意多次求值与副作用
- 字符串化与连接：# 与 ##
- 宏续行：反斜杠 \

## 3. 条件编译
- #if/#ifdef/#ifndef/#elif/#else/#endif
- 根据平台/编译器切换实现；根据开关裁剪功能

## 4. 内置宏与诊断
- __FILE__/__LINE__/__func__/__DATE__/__TIME__
- #error 触发编译错误，#warning（部分编译器扩展）

## 5. 宏陷阱与替代
- 多次求值导致未定义行为；括号与 do{...}while(0) 技巧
- 常量：优先使用 const 或枚举常量
- 内联函数：替代函数式宏，提高类型安全

示例：
```c
#define LOG_INFO(fmt, ...) \
    do { fprintf(stderr, "[INFO] %s:%d: " fmt "\n", \
                 __FILE__, __LINE__, __VA_ARGS__); } while (0)
```

## 6. 练习
- 用宏实现一个简单的断言（含文件与行号）。
- 使用条件编译为不同平台选择不同的socket实现。
- 将若干函数式宏替换为 static inline 函数并比较效果。

## 更多示例

示例A：宏的副作用
```c
#define MAX(a,b) ((a)>(b)?(a):(b))
int main(void){
    int x=1,y=2; int z=MAX(++x, ++y); // x被加了两次！
    // 改进：用内联函数或do-while
    return 0;
}
```

示例B：安全的MAX宏（GNU扩展）
```c
#define MAX(a,b) ({        \
    __typeof__(a) _a = (a); \
    __typeof__(b) _b = (b); \
    (_a > _b) ? _a : _b;    \
})
```

示例C：可变参数宏（C99）
```c
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#define LOG(fmt, ...) printf("[LOG] " fmt "\n", __VA_ARGS__)
int main(void){ DEBUG("值是%d\n", 42); }
```

示例D：条件编译
```c
#ifdef DEBUG
    #define DBG(x) printf("DEBUG: " #x " = %d\n", x)
#else
    #define DBG(x)
#endif

// 特性检测
#if __STDC_VERSION__ >= 201112L
    _Static_assert(sizeof(int)>=4, "int too small");
#endif
```

## 练习参考答案（节选）
- 避免参数多次求值：用GNU语句表达式或临时变量。
- 字符串化与连接：##用于标识符拼接；#用于字符串化。
- 交换宏：需要typeof或临时变量避免类型不兼容。

## 参考资料
- ISO C11 预处理器章节；GNU C 手册关于语句表达式；《C陷阱与缺陷》第7章。