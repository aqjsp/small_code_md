# C语言标准库与常用接口

## 学习目标

通过本章学习，你将掌握：
- C标准库的组织结构和设计原理
- 内存管理函数的正确使用方法
- 字符串处理函数的安全编程实践
- 数学函数库的应用和性能考虑
- 时间处理和随机数生成的标准方法

## 1. 标准库概述

### 1.1 标准库的作用和意义

C标准库提供了对操作系统服务的标准化抽象接口：

```c
// 主要标准库头文件
#include <stdio.h>    // 输入输出：流、格式化、文件操作
#include <stdlib.h>   // 通用工具：内存、转换、随机数、程序控制
#include <string.h>   // 字符串处理：操作、比较、搜索、内存操作
#include <math.h>     // 数学计算：基础运算、三角函数、对数指数
#include <time.h>     // 时间处理：获取、格式化、计算
#include <errno.h>    // 错误处理：错误码、错误信息
#include <ctype.h>    // 字符分类：判断、转换
#include <limits.h>   // 实现限制：数据类型范围
#include <float.h>    // 浮点特性：精度、范围
#include <stddef.h>   // 标准定义：NULL、size_t、ptrdiff_t

// 标准库的优势
void library_benefits_demo() {
    printf("标准库的优势：\n");
    printf("1. 跨平台兼容性\n");
    printf("2. 经过优化和测试\n");
    printf("3. 统一的编程接口\n");
    printf("4. 丰富的功能支持\n");
}
```

### 1.2 标准库的使用原则

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

// 错误检查的重要性
void error_checking_example() {
    FILE *file = fopen("nonexistent.txt", "r");
    if (file == NULL) {
        perror("文件打开失败");
        return;
    }
    
    // 使用文件...
    fclose(file);
}

// 资源管理原则
void resource_management_example() {
    char *buffer = malloc(1024);
    if (buffer == NULL) {
        fprintf(stderr, "内存分配失败\n");
        return;
    }
    
    // 使用buffer...
    
    free(buffer);  // 及时释放资源
    buffer = NULL; // 避免悬空指针
}
```

## 2. 内存管理

### 2.1 动态内存分配

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// 基本内存分配函数
void basic_memory_allocation() {
    // malloc - 分配未初始化的内存
    int *array = malloc(10 * sizeof(int));
    if (array == NULL) {
        fprintf(stderr, "malloc失败\n");
        return;
    }
    
    // 初始化内存
    for (int i = 0; i < 10; i++) {
        array[i] = i * i;
    }
    
    // calloc - 分配并初始化为零的内存
    int *zero_array = calloc(10, sizeof(int));
    if (zero_array == NULL) {
        fprintf(stderr, "calloc失败\n");
        free(array);
        return;
    }
    
    // realloc - 重新分配内存大小
    array = realloc(array, 20 * sizeof(int));
    if (array == NULL) {
        fprintf(stderr, "realloc失败\n");
        free(zero_array);
        return;
    }
    
    // 初始化新分配的部分
    for (int i = 10; i < 20; i++) {
        array[i] = i * i;
    }
    
    // 释放内存
    free(array);
    free(zero_array);
}

// 内存分配的最佳实践
void memory_best_practices() {
    size_t count = 100;
    
    // 1. 检查分配是否成功
    double *data = malloc(count * sizeof(double));
    if (data == NULL) {
        fprintf(stderr, "内存分配失败\n");
        exit(EXIT_FAILURE);
    }
    
    // 2. 初始化内存内容
    memset(data, 0, count * sizeof(double));
    
    // 3. 使用内存
    for (size_t i = 0; i < count; i++) {
        data[i] = i * 0.5;
    }
    
    // 4. 及时释放内存
    free(data);
    data = NULL;  // 防止意外使用
}
```

### 2.2 内存操作函数

```c
#include <string.h>
#include <stdio.h>

// 内存操作函数示例
void memory_operations() {
    char src[] = "Hello, World!";
    char dest[20];
    
    // memcpy - 内存复制（不重叠）
    memcpy(dest, src, strlen(src) + 1);
    printf("memcpy结果: %s\n", dest);
    
    // memmove - 内存移动（可重叠）
    char buffer[] = "abcdefghij";
    memmove(buffer + 2, buffer, 5);  // 重叠复制
    printf("memmove结果: %s\n", buffer);
    
    // memset - 内存设置
    char array[10];
    memset(array, 'A', sizeof(array) - 1);
    array[sizeof(array) - 1] = '\0';
    printf("memset结果: %s\n", array);
    
    // memcmp - 内存比较
    char str1[] = "Hello";
    char str2[] = "Hello";
    char str3[] = "World";
    
    printf("memcmp(str1, str2): %d\n", memcmp(str1, str2, 5));  // 0
    printf("memcmp(str1, str3): %d\n", memcmp(str1, str3, 5));  // 负数
}

// 安全的内存操作
void safe_memory_operations() {
    const size_t BUFFER_SIZE = 256;
    char buffer[BUFFER_SIZE];
    const char *source = "这是一个测试字符串";
    
    // 安全的内存复制
    size_t source_len = strlen(source);
    if (source_len < BUFFER_SIZE) {
        memcpy(buffer, source, source_len + 1);
        printf("安全复制: %s\n", buffer);
    } else {
        fprintf(stderr, "源字符串太长\n");
    }
    
    // 清零敏感数据
    memset(buffer, 0, BUFFER_SIZE);  // 清除敏感信息
}
```

## 3. 字符串处理

### 3.1 基本字符串函数概述

C语言提供了丰富的字符串处理函数，主要定义在`<string.h>`头文件中。这些函数操作的对象通常是字符串（以 `\0` 结尾的字符数组），它们极大地方便了文本处理任务。

### 3.2 字符串长度函数 - strlen()

`strlen()` 函数用来计算字符串长度（包含多少个字符）。该函数通过遍历字符串直到遇到终止符'\0'来计算字符串的实际长度。

**函数原型：**
```c
size_t strlen(const char *str);
```

**参数说明：**
- `str`：要计算长度的字符串
- 返回值：字符串的长度（不包括 `\0`），类型为 `size_t`（无符号整数）

**重要特性：**
- `strlen()` 只计算实际字符数，不包括末尾的 `\0`
- 如果传入的不是以 `\0` 结尾的字符数组，结果将是未定义的
- `strlen()` 函数从字符串的开头位置依次向后计数，直到遇见 `\0`，然后返回计数器的值

### 3.3 字符串复制函数 - strcpy() 和 strncpy()

#### 3.3.1 strcpy() 函数

`strcpy()` 将源字符串（包括 `\0`）复制到目标字符串。

**函数原型：**
```c
char *strcpy(char *dest, const char *src);
```

**参数说明：**
- `dest`：目标字符数组
- `src`：源字符串
- 返回值：指向 `dest` 的指针

**重要注意事项：**
- `dest` 必须有足够的空间容纳 `src`，否则会引发缓冲区溢出
- 必须保证 `dest` 足够大，能够容纳下 `src`，否则会导致溢出错误

#### 3.3.2 strncpy() 函数

`strncpy()` 是更安全的版本，允许指定复制的最大字符数。

**函数原型：**
```c
char *strncpy(char *dest, const char *src, size_t n);
```

**参数说明：**
- `n`：最多复制的字符数

**重要注意事项：**
- `strncpy()` 不会自动添加 `\0`，如果 `n` 小于 `src` 长度，需手动补上
- 当 `src` 的长度小于 `n` 时，目标数组 `dest` 的剩余部分将用空字节填充

### 3.4 字符串连接函数 - strcat() 和 strncat()

#### 3.4.1 strcat() 函数

`strcat()` 函数用来将两个字符串连接（拼接）起来。该函数将源字符串追加到目标字符串的末尾，形成一个新的字符串。

**函数原型：**
```c
char *strcat(char *dest, const char *src);
```

**参数说明：**
- `dest`：目标字符串
- `src`：源字符串
- 返回值：指向目标字符串的指针

**重要注意事项：**
- `strcat()` 将 `src` 指向的字符串追加到 `dest` 指向的字符串的结尾
- 必须要保证 `dest` 有足够的内存空间来容纳两个字符串，否则会出现溢出错误
- `dest` 末尾的 `\0` 会被覆盖，`src` 末尾的 `\0` 会一起被复制过去，因此最终的字符串只有一个 `\0`

#### 3.4.2 strncat() 函数

`strncat()` 限制追加的字符数，是更安全的版本。

**函数原型：**
```c
char *strncat(char *dest, const char *src, size_t n);
```

**参数说明：**
- `n`：最多追加的字符数

**重要特性：**
- `strncat()` 会自动添加 `\0`，无需手动补齐

### 3.5 字符串比较函数 - strcmp() 和 strncmp()

#### 3.5.1 strcmp() 函数

`strcmp()` 函数用于对两个字符串进行比较（区分大小写）。该函数通过逐字符比较来确定两个字符串的大小关系。

**函数原型：**
```c
int strcmp(const char *str1, const char *str2);
```

**返回值说明：**
- 返回值 < 0：`str1` 小于 `str2`
- 返回值 > 0：`str1` 大于 `str2`  
- 返回值 = 0：`str1` 等于 `str2`

**比较原理：**
- `strcmp()` 函数会根据 ASCII 值依次比较 `str1` 和 `str2` 的每一个字符，直到出现不一样的字符，或者到达字符串末尾的 `\0`

#### 3.5.2 strncmp() 函数

`strncmp()` 只比较前 n 个字符。

**函数原型：**
```c
int strncmp(const char *str1, const char *str2, size_t n);
```

### 3.6 字符串查找函数

#### 3.6.1 strchr() 函数

`strchr()` 查找字符在字符串中第一次出现的位置。

**函数原型：**
```c
char *strchr(const char *str, int c);
```

**参数说明：**
- `str`：要查找的字符串
- `c`：要查找的字符（传入 int，但实际按 char 处理）
- 返回值：指向首次出现位置的指针，或 NULL（未找到）

#### 3.6.2 strrchr() 函数

`strrchr()` 查找字符在字符串中最后一次出现的位置。

#### 3.6.3 strstr() 函数

`strstr()` 查找子字符串在字符串中第一次出现的位置。

**函数原型：**
```c
char *strstr(const char *str, const char *substr);
```

**参数说明：**
- `str`：要查找的字符串
- `substr`：要查找的子字符串
- 返回值：指向首次出现位置的指针，或 NULL（未找到）

### 3.7 字符串处理实例

```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

// 字符串长度和复制
void string_basics() {
    char src[] = "Hello, World!";
    char dest[50];
    
    // strlen - 获取字符串长度
    size_t len = strlen(src);
    printf("字符串长度: %zu\n", len);
    
    // strcpy - 字符串复制
    strcpy(dest, src);
    printf("复制结果: %s\n", dest);
    
    // strncpy - 限制长度的字符串复制
    char limited[10];
    strncpy(limited, src, sizeof(limited) - 1);
    limited[sizeof(limited) - 1] = '\0';  // 确保空字符结尾
    printf("限制复制: %s\n", limited);
    
    // strcat - 字符串连接
    char greeting[100] = "Hello, ";
    strcat(greeting, "World!");
    printf("连接结果: %s\n", greeting);
    
    // strncat - 限制长度的字符串连接
    char buffer[20] = "Hi ";
    strncat(buffer, "there, friend!", sizeof(buffer) - strlen(buffer) - 1);
    printf("限制连接: %s\n", buffer);
}

// 字符串比较和搜索
void string_comparison_search() {
    char str1[] = "apple";
    char str2[] = "banana";
    char str3[] = "apple";
    
    // strcmp - 字符串比较
    printf("strcmp(apple, banana): %d\n", strcmp(str1, str2));  // 负数
    printf("strcmp(apple, apple): %d\n", strcmp(str1, str3));   // 0
    
    // strncmp - 限制长度的字符串比较
    printf("strncmp(apple, app, 3): %d\n", strncmp(str1, "app", 3));  // 0
    
    // strchr - 查找字符
    char *pos = strchr(str1, 'p');
    if (pos) {
        printf("找到字符'p'，位置: %ld\n", pos - str1);
    }
    
    // strstr - 查找子字符串
    char text[] = "The quick brown fox";
    char *found = strstr(text, "quick");
    if (found) {
        printf("找到子字符串: %s\n", found);
    }
    
    // strrchr - 从右侧查找字符
    char path[] = "/home/user/document.txt";
    char *filename = strrchr(path, '/');
    if (filename) {
        printf("文件名: %s\n", filename + 1);
    }
}
```

### 3.8 字符串转换和处理

```c
#include <stdlib.h>
#include <ctype.h>
#include <stdio.h>

// 字符串到数值的转换
void string_to_number_conversion() {
    // 字符串到整数
    char int_str[] = "12345";
    int num = atoi(int_str);
    printf("atoi(\"%s\") = %d\n", int_str, num);
    
    // 更安全的转换（带错误检查）
    char *endptr;
    long long_num = strtol("98765", &endptr, 10);
    if (*endptr == '\0') {
        printf("strtol转换成功: %ld\n", long_num);
    } else {
        printf("strtol转换失败\n");
    }
    
    // 字符串到浮点数
    char float_str[] = "3.14159";
    double pi = atof(float_str);
    printf("atof(\"%s\") = %.5f\n", float_str, pi);
    
    // 更安全的浮点转换
    double precise_pi = strtod("3.141592653589793", &endptr);
    if (*endptr == '\0') {
        printf("strtod转换成功: %.15f\n", precise_pi);
    }
}

// 字符分类和转换
void character_classification() {
    char test_chars[] = "Hello123!@#";
    
    printf("字符分类测试:\n");
    for (int i = 0; test_chars[i]; i++) {
        char c = test_chars[i];
        printf("'%c': ", c);
        
        if (isalpha(c)) printf("字母 ");
        if (isdigit(c)) printf("数字 ");
        if (isalnum(c)) printf("字母数字 ");
        if (ispunct(c)) printf("标点 ");
        if (isspace(c)) printf("空白 ");
        if (isupper(c)) printf("大写 ");
        if (islower(c)) printf("小写 ");
        
        printf("\n");
    }
    
    // 字符转换
    printf("\n字符转换:\n");
    char mixed[] = "Hello World";
    for (int i = 0; mixed[i]; i++) {
        printf("'%c' -> 大写:'%c' 小写:'%c'\n", 
               mixed[i], toupper(mixed[i]), tolower(mixed[i]));
    }
}

// 自定义字符串处理函数
char* string_trim(char *str) {
    if (str == NULL) return NULL;
    
    // 去除前导空白
    while (isspace(*str)) str++;
    
    if (*str == '\0') return str;  // 全是空白字符
    
    // 去除尾随空白
    char *end = str + strlen(str) - 1;
    while (end > str && isspace(*end)) end--;
    
    *(end + 1) = '\0';
    return str;
}

void custom_string_functions() {
    char text[] = "  Hello, World!  ";
    printf("原始字符串: '%s'\n", text);
    
    char *trimmed = string_trim(text);
    printf("去空白后: '%s'\n", trimmed);
}
```

## 4. 数学计算

### 4.1 数学函数概述

C语言提供了丰富的数学函数，主要定义在`<math.h>`头文件中。这些函数涵盖了基本数学运算、三角函数、对数函数等。

### 4.2 基本数学函数

#### 4.2.1 幂运算函数 - pow()

`pow()` 函数用来求 x 的 y 次方的值。

**函数原型：**
```c
double pow(double x, double y);
```

**参数说明：**
- `x`：底数（双精度数）
- `y`：指数（双精度数）
- 返回值：x 的 y 次方的值

**可能导致错误的情况：**
- 如果底数 x 为负数并且指数 y 不是整数，将会导致 domain error 错误
- 如果底数 x 和指数 y 都是 0，可能会导致 domain error 错误
- 如果底数 x 是 0，指数 y 是负数，可能会导致 domain error 或 pole error 错误
- 如果返回值太大或者太小，将会导致 range error 错误

#### 4.2.2 平方根函数 - sqrt()

`sqrt()` 函数用于计算一个非负实数的平方根。

**函数原型：**
```c
double sqrt(double x);
```

**参数说明：**
- `x`：要计算平方根的非负浮点数

**返回值：**
- 如果 x 是非负数，则返回 x 的平方根
- 如果 x 是负数，则会发生域错误，全局变量 errno 的值为 EDOM

**特殊情况：**
- 如果参数是负数，函数将返回 NaN（Not-a-Number）值
- 如果参数是 0，则返回值为 0
- 如果参数是正无穷，则返回正无穷
- 如果参数是 NaN，则返回 NaN

#### 4.2.3 其他基本数学函数

```c
#include <math.h>
#include <stdio.h>

// 基本数学运算
void basic_math_functions() {
    double x = 16.0, y = 3.0;
    
    // 幂运算和根运算
    printf("pow(%.1f, %.1f) = %.2f\n", x, y, pow(x, y));
    printf("sqrt(%.1f) = %.2f\n", x, sqrt(x));
    printf("cbrt(%.1f) = %.2f\n", x, cbrt(x));  // 立方根
    
    // 指数和对数
    printf("exp(%.1f) = %.2f\n", y, exp(y));
    printf("log(%.1f) = %.2f\n", x, log(x));    // 自然对数
    printf("log10(%.1f) = %.2f\n", x, log10(x)); // 常用对数
    
    // 取整函数
    double value = 3.7;
    printf("ceil(%.1f) = %.0f\n", value, ceil(value));   // 向上取整
    printf("floor(%.1f) = %.0f\n", value, floor(value)); // 向下取整
    printf("round(%.1f) = %.0f\n", value, round(value)); // 四舍五入
    
    // 绝对值
    printf("fabs(-%.1f) = %.1f\n", value, fabs(-value));
    
    // 取模运算
    printf("fmod(%.1f, %.1f) = %.2f\n", x, y, fmod(x, y));
}

// 三角函数
void trigonometric_functions() {
    double angle_deg = 45.0;
    double angle_rad = angle_deg * M_PI / 180.0;  // 转换为弧度
    
    printf("角度: %.1f度 = %.4f弧度\n", angle_deg, angle_rad);
    
    // 基本三角函数
    printf("sin(%.4f) = %.4f\n", angle_rad, sin(angle_rad));
    printf("cos(%.4f) = %.4f\n", angle_rad, cos(angle_rad));
    printf("tan(%.4f) = %.4f\n", angle_rad, tan(angle_rad));
    
    // 反三角函数
    double value = 0.5;
    printf("asin(%.1f) = %.4f弧度\n", value, asin(value));
    printf("acos(%.1f) = %.4f弧度\n", value, acos(value));
    printf("atan(%.1f) = %.4f弧度\n", value, atan(value));
    
    // 双曲函数
    printf("sinh(%.1f) = %.4f\n", value, sinh(value));
    printf("cosh(%.1f) = %.4f\n", value, cosh(value));
    printf("tanh(%.1f) = %.4f\n", value, tanh(value));
}
```

### 4.3 三角函数

### 4.4 随机数生成

```c
#include <stdlib.h>
#include <time.h>
#include <stdio.h>

// 随机数生成
void random_number_generation() {
    // 设置随机种子
    srand((unsigned int)time(NULL));
    
    printf("随机数生成示例:\n");
    
    // 生成0到RAND_MAX之间的随机数
    for (int i = 0; i < 5; i++) {
        int random_num = rand();
        printf("rand() = %d\n", random_num);
    }
    
    // 生成指定范围的随机数
    printf("\n1到100之间的随机数:\n");
    for (int i = 0; i < 5; i++) {
        int random_range = rand() % 100 + 1;
        printf("%d ", random_range);
    }
    printf("\n");
    
    // 生成随机浮点数（0.0到1.0）
    printf("\n0.0到1.0之间的随机浮点数:\n");
    for (int i = 0; i < 5; i++) {
        double random_float = (double)rand() / RAND_MAX;
        printf("%.4f ", random_float);
    }
    printf("\n");
}

// 更好的随机数生成函数
int random_range(int min, int max) {
    if (min > max) {
        int temp = min;
        min = max;
        max = temp;
    }
    return rand() % (max - min + 1) + min;
}

double random_double(double min, double max) {
    double scale = (double)rand() / RAND_MAX;
    return min + scale * (max - min);
}

void improved_random_functions() {
    srand((unsigned int)time(NULL));
    
    printf("改进的随机数函数:\n");
    
    // 指定范围的整数
    printf("10到50之间的随机整数: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", random_range(10, 50));
    }
    printf("\n");
    
    // 指定范围的浮点数
    printf("1.0到10.0之间的随机浮点数: ");
    for (int i = 0; i < 5; i++) {
        printf("%.2f ", random_double(1.0, 10.0));
    }
    printf("\n");
}
```

## 5. 时间处理

### 5.1 时间获取和格式化

```c
#include <time.h>
#include <stdio.h>

// 时间获取和显示
void time_operations() {
    // 获取当前时间戳
    time_t current_time = time(NULL);
    printf("时间戳: %ld\n", current_time);
    
    // 转换为本地时间
    struct tm *local_time = localtime(&current_time);
    if (local_time) {
        printf("本地时间: %d年%d月%d日 %d:%d:%d\n",
               local_time->tm_year + 1900,
               local_time->tm_mon + 1,
               local_time->tm_mday,
               local_time->tm_hour,
               local_time->tm_min,
               local_time->tm_sec);
    }
    
    // 转换为UTC时间
    struct tm *utc_time = gmtime(&current_time);
    if (utc_time) {
        printf("UTC时间: %d年%d月%d日 %d:%d:%d\n",
               utc_time->tm_year + 1900,
               utc_time->tm_mon + 1,
               utc_time->tm_mday,
               utc_time->tm_hour,
               utc_time->tm_min,
               utc_time->tm_sec);
    }
    
    // 格式化时间字符串
    char time_str[100];
    strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", local_time);
    printf("格式化时间: %s\n", time_str);
    
    // 不同的格式化选项
    strftime(time_str, sizeof(time_str), "%A, %B %d, %Y", local_time);
    printf("完整格式: %s\n", time_str);
    
    strftime(time_str, sizeof(time_str), "%Y/%m/%d %I:%M:%S %p", local_time);
    printf("12小时制: %s\n", time_str);
}

// 时间计算和比较
void time_calculations() {
    time_t start_time = time(NULL);
    
    // 模拟一些工作
    printf("开始工作...\n");
    for (volatile int i = 0; i < 100000000; i++) {
        // 空循环，消耗时间
    }
    
    time_t end_time = time(NULL);
    double elapsed = difftime(end_time, start_time);
    printf("工作完成，耗时: %.0f秒\n", elapsed);
    
    // 创建特定时间
    struct tm specific_time = {0};
    specific_time.tm_year = 2024 - 1900;  // 年份从1900开始计算
    specific_time.tm_mon = 0;             // 月份从0开始（0=1月）
    specific_time.tm_mday = 1;            // 日期从1开始
    specific_time.tm_hour = 0;
    specific_time.tm_min = 0;
    specific_time.tm_sec = 0;
    
    time_t new_year = mktime(&specific_time);
    if (new_year != -1) {
        printf("2024年新年时间戳: %ld\n", new_year);
        
        double days_diff = difftime(current_time, new_year) / (24 * 60 * 60);
        printf("距离2024年新年已过去: %.0f天\n", days_diff);
    }
}
```

### 5.2 高精度时间测量

```c
#include <time.h>
#include <stdio.h>

// 高精度时间测量
void high_precision_timing() {
    clock_t start_clock = clock();
    
    // 执行一些计算
    double sum = 0.0;
    for (int i = 0; i < 1000000; i++) {
        sum += i * 0.5;
    }
    
    clock_t end_clock = clock();
    double cpu_time = ((double)(end_clock - start_clock)) / CLOCKS_PER_SEC;
    
    printf("计算结果: %.2f\n", sum);
    printf("CPU时间: %.6f秒\n", cpu_time);
    printf("时钟周期: %ld\n", end_clock - start_clock);
}

// 简单的性能测试框架
typedef struct {
    const char *name;
    void (*function)(void);
} benchmark_t;

void test_function1(void) {
    for (volatile int i = 0; i < 100000; i++);
}

void test_function2(void) {
    for (volatile int i = 0; i < 200000; i++);
}

void run_benchmarks() {
    benchmark_t tests[] = {
        {"测试函数1", test_function1},
        {"测试函数2", test_function2},
        {NULL, NULL}
    };
    
    printf("性能测试结果:\n");
    for (int i = 0; tests[i].name; i++) {
        clock_t start = clock();
        tests[i].function();
        clock_t end = clock();
        
        double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;
        printf("%s: %.6f秒\n", tests[i].name, time_taken);
    }
}
```

## 6. 错误处理

### 6.1 错误码和错误信息概述

### 6.2 标准错误处理

```c
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

// 错误处理示例
void error_handling_demo() {
    FILE *file;
    
    // 尝试打开不存在的文件
    errno = 0;  // 清除之前的错误
    file = fopen("nonexistent_file.txt", "r");
    
    if (file == NULL) {
        printf("错误码: %d\n", errno);
        printf("错误描述: %s\n", strerror(errno));
        perror("fopen失败");  // 自动打印错误信息
        return;
    }
    
    fclose(file);
}

// 内存分配错误处理
void memory_error_handling() {
    size_t huge_size = SIZE_MAX;  // 尝试分配巨大内存
    
    errno = 0;
    void *ptr = malloc(huge_size);
    
    if (ptr == NULL) {
        printf("内存分配失败\n");
        printf("错误码: %d\n", errno);
        printf("错误描述: %s\n", strerror(errno));
        
        // 尝试分配较小的内存
        ptr = malloc(1024);
        if (ptr != NULL) {
            printf("分配1KB内存成功\n");
            free(ptr);
        }
    } else {
        printf("意外：巨大内存分配成功\n");
        free(ptr);
    }
}
```

### 6.3 自定义错误处理
typedef enum {
    ERROR_NONE = 0,
    ERROR_NULL_POINTER,
    ERROR_INVALID_ARGUMENT,
    ERROR_OUT_OF_MEMORY,
    ERROR_FILE_NOT_FOUND
} error_code_t;

const char* get_error_message(error_code_t code) {
    switch (code) {
        case ERROR_NONE: return "无错误";
        case ERROR_NULL_POINTER: return "空指针错误";
        case ERROR_INVALID_ARGUMENT: return "无效参数";
        case ERROR_OUT_OF_MEMORY: return "内存不足";
        case ERROR_FILE_NOT_FOUND: return "文件未找到";
        default: return "未知错误";
    }
}

error_code_t safe_string_copy(char *dest, const char *src, size_t dest_size) {
    if (dest == NULL || src == NULL) {
        return ERROR_NULL_POINTER;
    }
    
    if (dest_size == 0) {
        return ERROR_INVALID_ARGUMENT;
    }
    
    size_t src_len = strlen(src);
    if (src_len >= dest_size) {
        return ERROR_INVALID_ARGUMENT;  // 目标缓冲区太小
    }
    
    strcpy(dest, src);
    return ERROR_NONE;
}

void custom_error_handling() {
    char buffer[10];
    const char *source = "Hello, World!";
    
    error_code_t result = safe_string_copy(buffer, source, sizeof(buffer));
    if (result != ERROR_NONE) {
        printf("字符串复制失败: %s\n", get_error_message(result));
    } else {
        printf("字符串复制成功: %s\n", buffer);
    }
}
```

## 7. 综合示例：文本处理工具

### 7.1 文本统计功能

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

// 文本统计结构
typedef struct {
    int lines;
    int words;
    int characters;
    int letters;
    int digits;
    int spaces;
} text_stats_t;

// 统计文本信息
text_stats_t analyze_text(const char *text) {
    text_stats_t stats = {0};
    
    if (text == NULL) return stats;
    
    int in_word = 0;
    
    for (const char *p = text; *p; p++) {
        stats.characters++;
        
        if (*p == '\n') {
            stats.lines++;
            in_word = 0;
        } else if (isspace(*p)) {
            stats.spaces++;
            in_word = 0;
        } else {
            if (!in_word) {
                stats.words++;
                in_word = 1;
            }
            
            if (isalpha(*p)) {
                stats.letters++;
            } else if (isdigit(*p)) {
                stats.digits++;
            }
        }
    }
    
    // 如果文本不以换行符结尾，但有内容，则算作一行
    if (stats.characters > 0 && text[strlen(text) - 1] != '\n') {
        stats.lines++;
    }
    
    return stats;
}
```

### 7.2 文本处理工具实现

```c
// 文本处理工具
char* process_text(const char *input, int to_upper) {
    if (input == NULL) return NULL;
    
    size_t len = strlen(input);
    char *result = malloc(len + 1);
    if (result == NULL) return NULL;
    
    for (size_t i = 0; i <= len; i++) {
        if (to_upper) {
            result[i] = toupper(input[i]);
        } else {
            result[i] = tolower(input[i]);
        }
    }
    
    return result;
}

// 单词计数器
int count_word_occurrences(const char *text, const char *word) {
    if (text == NULL || word == NULL) return 0;
    
    int count = 0;
    const char *pos = text;
    size_t word_len = strlen(word);
    
    while ((pos = strstr(pos, word)) != NULL) {
        // 检查是否是完整单词（前后都是非字母字符）
        int is_word_start = (pos == text) || !isalpha(*(pos - 1));
        int is_word_end = !isalpha(*(pos + word_len));
        
        if (is_word_start && is_word_end) {
            count++;
        }
        pos++;
    }
    
    return count;
}
```

### 7.3 文本处理工具演示
void text_processing_demo() {
    const char *sample_text = 
        "Hello World!\n"
        "This is a sample text for testing.\n"
        "It contains 123 numbers and various characters.\n"
        "The word 'test' appears in testing.\n";
    
    printf("=== 文本处理工具演示 ===\n");
    printf("原始文本:\n%s\n", sample_text);
    
    // 文本统计
    text_stats_t stats = analyze_text(sample_text);
    printf("文本统计:\n");
    printf("  行数: %d\n", stats.lines);
    printf("  单词数: %d\n", stats.words);
    printf("  字符数: %d\n", stats.characters);
    printf("  字母数: %d\n", stats.letters);
    printf("  数字数: %d\n", stats.digits);
    printf("  空格数: %d\n", stats.spaces);
    
    // 大小写转换
    char *upper_text = process_text(sample_text, 1);
    char *lower_text = process_text(sample_text, 0);
    
    if (upper_text) {
        printf("\n大写转换:\n%s\n", upper_text);
        free(upper_text);
    }
    
    if (lower_text) {
        printf("小写转换:\n%s\n", lower_text);
        free(lower_text);
    }
    
    // 单词计数
    int test_count = count_word_occurrences(sample_text, "test");
    printf("单词'test'出现次数: %d\n", test_count);
    
    int the_count = count_word_occurrences(sample_text, "the");
    printf("单词'the'出现次数: %d\n", the_count);
}
```c
// 自定义错误处理
typedef enum {
    ERROR_NONE = 0,
    ERROR_NULL_POINTER,
    ERROR_INVALID_ARGUMENT,
    ERROR_OUT_OF_MEMORY,
    ERROR_FILE_NOT_FOUND
} error_code_t;

const char* get_error_message(error_code_t code) {
    switch (code) {
        case ERROR_NONE: return "无错误";
        case ERROR_NULL_POINTER: return "空指针错误";
        case ERROR_INVALID_ARGUMENT: return "无效参数";
        case ERROR_OUT_OF_MEMORY: return "内存不足";
        case ERROR_FILE_NOT_FOUND: return "文件未找到";
        default: return "未知错误";
    }
}

error_code_t safe_string_copy(char *dest, const char *src, size_t dest_size) {
    if (dest == NULL || src == NULL) {
        return ERROR_NULL_POINTER;
    }
    
    if (dest_size == 0) {
        return ERROR_INVALID_ARGUMENT;
    }
    
    size_t src_len = strlen(src);
    if (src_len >= dest_size) {
        return ERROR_INVALID_ARGUMENT;  // 目标缓冲区太小
    }
    
    strcpy(dest, src);
    return ERROR_NONE;
}

void custom_error_handling() {
    char buffer[10];
    const char *source = "Hello, World!";
    
    error_code_t result = safe_string_copy(buffer, source, sizeof(buffer));
    if (result != ERROR_NONE) {
        printf("字符串复制失败: %s\n", get_error_message(result));
    } else {
        printf("字符串复制成功: %s\n", buffer);
    }
}
```

## 8. 最佳实践

### 8.1 安全编程原则

```c
// 1. 总是检查返回值
void safe_programming_practices() {
    // 内存分配检查
    char *buffer = malloc(1024);
    if (buffer == NULL) {
        fprintf(stderr, "内存分配失败\n");
        return;
    }
    
    // 文件操作检查
    FILE *file = fopen("data.txt", "r");
    if (file == NULL) {
        perror("文件打开失败");
        free(buffer);
        return;
    }
    
    // 字符串操作安全
    char dest[100];
    const char *src = "Hello, World!";
    
    if (strlen(src) < sizeof(dest)) {
        strcpy(dest, src);
    } else {
        strncpy(dest, src, sizeof(dest) - 1);
        dest[sizeof(dest) - 1] = '\0';
    }
    
    // 清理资源
    fclose(file);
    free(buffer);
}

// 2. 使用安全的字符串函数
void secure_string_functions() {
    char buffer[50];
    const char *input = "This is a potentially long input string";
    
    // 使用安全的字符串函数
    snprintf(buffer, sizeof(buffer), "输入: %.20s", input);
    printf("%s\n", buffer);
    
    // 安全的字符串连接
    char result[100] = "前缀: ";
    size_t remaining = sizeof(result) - strlen(result) - 1;
    strncat(result, input, remaining);
    printf("%s\n", result);
}
```

### 8.2 性能优化建议

```c
// 性能优化示例
void performance_tips() {
    const int SIZE = 1000000;
    
    // 1. 减少函数调用开销
    clock_t start = clock();
    
    // 低效方式：重复调用strlen
    char str[] = "Hello, World!";
    int count1 = 0;
    for (int i = 0; i < strlen(str); i++) {  // 每次都调用strlen
        if (str[i] != ' ') count1++;
    }
    
    clock_t mid = clock();
    
    // 高效方式：缓存strlen结果
    int count2 = 0;
    size_t len = strlen(str);  // 只调用一次
    for (size_t i = 0; i < len; i++) {
        if (str[i] != ' ') count2++;
    }
    
    clock_t end = clock();
    
    printf("低效方式耗时: %.6f秒\n", 
           ((double)(mid - start)) / CLOCKS_PER_SEC);
    printf("高效方式耗时: %.6f秒\n", 
           ((double)(end - mid)) / CLOCKS_PER_SEC);
    
    // 2. 内存访问模式优化
    // 连续内存访问比随机访问更快
    int *array = malloc(SIZE * sizeof(int));
    if (array) {
        // 顺序访问（缓存友好）
        start = clock();
        for (int i = 0; i < SIZE; i++) {
            array[i] = i;
        }
        end = clock();
        printf("顺序访问耗时: %.6f秒\n", 
               ((double)(end - start)) / CLOCKS_PER_SEC);
        
        free(array);
    }
}
```

## 总结

C标准库提供了丰富而强大的功能集合：

1. **内存管理**：动态分配、释放和操作内存
2. **字符串处理**：复制、比较、搜索和转换字符串
3. **数学计算**：基本运算、三角函数、随机数生成
4. **时间处理**：获取、格式化和计算时间
5. **错误处理**：检测和处理各种错误情况

掌握这些标准库函数的正确使用方法，遵循安全编程原则，能够帮助你编写出高效、可靠、可移植的C语言程序。记住始终检查返回值、合理管理资源、使用安全的字符串函数，这些都是成为优秀C程序员的基本要求。
