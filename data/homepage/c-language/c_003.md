# C语言控制结构与函数设计

## 学习目标

通过本章学习，你将掌握：
- 各种控制结构的语法和应用场景
- 函数设计的原则和最佳实践
- 参数传递机制和内存管理
- 递归算法的实现和优化技巧
- 错误处理和异常安全编程

## 1. 控制结构基础

### 1.1 结构化编程原理

结构化编程基于Böhm-Jacopini定理，任何算法都可以用三种基本控制结构表示：

```c
#include <stdio.h>
#include <stdbool.h>

// 顺序结构 - 语句按顺序执行
void sequence_example(void) {
    int a = 10, b = 20;
    int sum = a + b;
    printf("Sum: %d\n", sum);
}

// 选择结构 - 根据条件选择执行路径
void selection_example(int value) {
    if (value > 0) {
        printf("Positive\n");
    } else if (value < 0) {
        printf("Negative\n");
    } else {
        printf("Zero\n");
    }
}

// 循环结构 - 重复执行代码块
void iteration_example(int n) {
    for (int i = 1; i <= n; i++) {
        printf("%d ", i);
    }
    printf("\n");
}
```

### 1.2 控制流最佳实践

- **单一入口单一出口**：每个控制结构只有一个入口和出口
- **避免深层嵌套**：嵌套层次不超过3层
- **早期返回**：使用早期返回减少嵌套复杂度
- **明确的条件表达式**：使用有意义的变量名和函数名

## 2. 条件控制语句

### 2.1 布尔逻辑与短路求值

C语言中的真值定义和逻辑运算的短路特性：

```c
#include <stdbool.h>

// 安全的指针检查和数组访问
bool safe_array_access(int *arr, size_t index, size_t size) {
    return arr != NULL && index < size;  // 短路求值保证安全
}

// 安全的除法运算
bool safe_divide(double a, double b, double *result) {
    if (b != 0.0 && (*result = a / b, true)) {
        return true;
    }
    *result = 0.0;
    return false;
}

void boolean_demo(void) {
    // 逻辑运算示例
    bool and_result = (5 > 3) && (2 < 4);  // true
    bool or_result = (5 < 3) || (2 < 4);   // true
    bool not_result = !(5 > 3);             // false
    
    printf("AND: %s, OR: %s, NOT: %s\n",
           and_result ? "true" : "false",
           or_result ? "true" : "false",
           not_result ? "true" : "false");
}
```

### 2.2 if语句的高效使用

```c
// 成绩评定 - 使用早期返回
const char *get_grade(int score) {
    if (score < 0 || score > 100) return "INVALID";
    if (score >= 90) return "A";
    if (score >= 80) return "B";
    if (score >= 70) return "C";
    if (score >= 60) return "D";
    return "F";
}

// 多条件判断 - 避免深层嵌套
typedef enum {
    USER_ADMIN,
    USER_MODERATOR,
    USER_REGULAR,
    USER_GUEST
} UserRole;

bool can_delete_post(UserRole role, bool is_owner, bool is_expired) {
    // 管理员可以删除任何帖子
    if (role == USER_ADMIN) return true;
    
    // 版主可以删除过期帖子
    if (role == USER_MODERATOR && is_expired) return true;
    
    // 用户只能删除自己的帖子
    if (role == USER_REGULAR && is_owner) return true;
    
    return false;  // 其他情况不允许删除
}
```

### 2.3 switch语句的最佳实践

```c
#include <stdio.h>

typedef enum {
    STATE_INIT,
    STATE_RUNNING,
    STATE_PAUSED,
    STATE_STOPPED,
    STATE_ERROR
} SystemState;

// 状态机实现
void handle_state_transition(SystemState current_state, int event) {
    switch (current_state) {
        case STATE_INIT:
            printf("Initializing system...\n");
            // 初始化逻辑
            break;
            
        case STATE_RUNNING:
            printf("System running normally\n");
            // 运行时逻辑
            break;
            
        case STATE_PAUSED:
            printf("System paused\n");
            // 暂停状态逻辑
            break;
            
        case STATE_STOPPED:
            printf("System stopped\n");
            // 停止状态逻辑
            break;
            
        case STATE_ERROR:
            printf("System error - attempting recovery\n");
            // 错误处理逻辑
            break;
            
        default:
            printf("Unknown state: %d\n", current_state);
            // 处理未知状态
            break;
    }
}

// 计算器操作 - 使用函数指针表
typedef double (*operation_func)(double, double);

double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) { 
    return (b != 0.0) ? a / b : 0.0; 
}

double calculate(char op, double a, double b) {
    switch (op) {
        case '+': return add(a, b);
        case '-': return subtract(a, b);
        case '*': return multiply(a, b);
        case '/': return divide(a, b);
        default:
            printf("Error: Unknown operator '%c'\n", op);
            return 0.0;
    }
}
```

## 3. 循环控制语句

### 3.1 for循环的高效使用

```c
#include <stddef.h>

// 基本for循环模式
void basic_for_patterns(void) {
    // 标准递增循环
    for (int i = 0; i < 10; i++) {
        printf("%d ", i);
    }
    printf("\n");
    
    // 递减循环
    for (int i = 9; i >= 0; i--) {
        printf("%d ", i);
    }
    printf("\n");
    
    // 步长为2的循环
    for (int i = 0; i < 20; i += 2) {
        printf("%d ", i);
    }
    printf("\n");
}

// 数组遍历的安全模式
void safe_array_iteration(const int *arr, size_t size) {
    if (arr == NULL || size == 0) return;
    
    for (size_t i = 0; i < size; i++) {
        printf("arr[%zu] = %d\n", i, arr[i]);
    }
}

// 多维数组遍历
void matrix_operations(int matrix[][3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%4d", matrix[i][j]);
        }
        printf("\n");
    }
}
```

### 3.2 while和do-while循环

```c
#include <stdio.h>
#include <stdlib.h>

// 输入验证循环
int get_valid_input(int min, int max) {
    int value;
    bool valid = false;
    
    do {
        printf("Enter a number between %d and %d: ", min, max);
        if (scanf("%d", &value) == 1) {
            if (value >= min && value <= max) {
                valid = true;
            } else {
                printf("Value out of range. Try again.\n");
            }
        } else {
            printf("Invalid input. Try again.\n");
            // 清除输入缓冲区
            int c;
            while ((c = getchar()) != '\n' && c != EOF);
        }
    } while (!valid);
    
    return value;
}

// 文件处理循环
void process_file_lines(FILE *file) {
    if (file == NULL) return;
    
    char line[256];
    int line_number = 1;
    
    while (fgets(line, sizeof(line), file) != NULL) {
        printf("Line %d: %s", line_number++, line);
    }
}

// 链表遍历模式
typedef struct Node {
    int data;
    struct Node *next;
} Node;

void print_list(const Node *head) {
    const Node *current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}
```

### 3.3 循环控制和优化

```c
// 循环控制语句的正确使用
void loop_control_examples(void) {
    // break - 跳出循环
    for (int i = 0; i < 100; i++) {
        if (i * i > 50) {
            printf("Found: %d^2 = %d > 50\n", i, i * i);
            break;
        }
    }
    
    // continue - 跳过当前迭代
    printf("Odd numbers: ");
    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) continue;
        printf("%d ", i);
    }
    printf("\n");
}

// 嵌套循环优化
void optimized_nested_loops(void) {
    const int SIZE = 1000;
    
    // 优化：将较短的循环放在外层
    for (int j = 0; j < 10; j++) {        // 短循环在外
        for (int i = 0; i < SIZE; i++) {   // 长循环在内
            // 处理逻辑
        }
    }
}

// 循环展开优化示例
void loop_unrolling_example(const int *arr, size_t size) {
    size_t i;
    
    // 4路循环展开
    for (i = 0; i + 3 < size; i += 4) {
        printf("%d %d %d %d\n", arr[i], arr[i+1], arr[i+2], arr[i+3]);
    }
    
    // 处理剩余元素
    for (; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
```

## 4. 函数设计与实现

### 4.1 函数设计原则

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

// 单一职责原则 - 每个函数只做一件事
bool is_prime(int n) {
    if (n < 2) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    
    for (int i = 3; i * i <= n; i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}

// 输入验证和错误处理
typedef enum {
    CALC_SUCCESS,
    CALC_INVALID_INPUT,
    CALC_DIVISION_BY_ZERO,
    CALC_OVERFLOW
} CalcResult;

CalcResult safe_divide(double a, double b, double *result) {
    if (result == NULL) return CALC_INVALID_INPUT;
    if (b == 0.0) return CALC_DIVISION_BY_ZERO;
    
    *result = a / b;
    return CALC_SUCCESS;
}

// 使用示例
void demonstrate_safe_divide(void) {
    double result;
    CalcResult status = safe_divide(10.0, 3.0, &result);
    
    switch (status) {
        case CALC_SUCCESS:
            printf("Result: %.2f\n", result);
            break;
        case CALC_DIVISION_BY_ZERO:
            printf("Error: Division by zero\n");
            break;
        case CALC_INVALID_INPUT:
            printf("Error: Invalid input\n");
            break;
        default:
            printf("Error: Unknown error\n");
            break;
    }
}
```

### 4.2 参数传递和内存管理

```c
// 值传递 vs 指针传递
void swap_values(int a, int b) {
    // 无效 - 只交换副本
    int temp = a;
    a = b;
    b = temp;
}

void swap_pointers(int *a, int *b) {
    // 有效 - 交换原始值
    if (a != NULL && b != NULL) {
        int temp = *a;
        *a = *b;
        *b = temp;
    }
}

// 数组参数处理
void process_array(int arr[], size_t size) {
    // arr实际上是指针，不是数组
    for (size_t i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

// 字符串处理的安全模式
size_t safe_strlen(const char *str) {
    if (str == NULL) return 0;
    
    size_t len = 0;
    while (str[len] != '\0') {
        len++;
    }
    return len;
}

char *safe_strcpy(char *dest, const char *src, size_t dest_size) {
    if (dest == NULL || src == NULL || dest_size == 0) {
        return NULL;
    }
    
    size_t i;
    for (i = 0; i < dest_size - 1 && src[i] != '\0'; i++) {
        dest[i] = src[i];
    }
    dest[i] = '\0';
    
    return dest;
}
```

### 4.3 作用域和存储类别

```c
// 全局变量 - 谨慎使用
static int global_counter = 0;  // 文件作用域

// 函数内静态变量 - 保持状态
int get_next_id(void) {
    static int next_id = 1;  // 只初始化一次
    return next_id++;
}

// 局部变量和动态内存
void memory_management_example(void) {
    // 栈内存 - 自动管理
    int local_array[100];
    
    // 堆内存 - 手动管理
    int *dynamic_array = malloc(100 * sizeof(int));
    if (dynamic_array != NULL) {
        // 使用动态数组
        for (int i = 0; i < 100; i++) {
            dynamic_array[i] = i;
        }
        
        // 释放内存
        free(dynamic_array);
        dynamic_array = NULL;  // 避免悬空指针
    }
}

// 作用域演示
void scope_demonstration(void) {
    int outer = 10;
    
    {
        int inner = 20;
        printf("Inner scope: outer=%d, inner=%d\n", outer, inner);
    }
    
    // printf("Outer scope: inner=%d\n", inner);  // 错误！inner不可见
    printf("Outer scope: outer=%d\n", outer);
}
```

### 4.4 递归函数设计

```c
#include <stdio.h>

// 经典递归 - 阶乘
long long factorial(int n) {
    // 边界检查
    if (n < 0) return -1;  // 错误标识
    if (n <= 1) return 1;  // 基本情况
    
    return n * factorial(n - 1);  // 递归调用
}

// 尾递归优化 - 斐波那契数列
long long fibonacci_tail(int n, long long a, long long b) {
    if (n == 0) return a;
    if (n == 1) return b;
    return fibonacci_tail(n - 1, b, a + b);
}

long long fibonacci(int n) {
    if (n < 0) return -1;
    return fibonacci_tail(n, 0, 1);
}

// 递归与迭代的选择
long long factorial_iterative(int n) {
    if (n < 0) return -1;
    
    long long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

// 二分查找 - 递归实现
int binary_search_recursive(const int arr[], int left, int right, int target) {
    if (left > right) return -1;  // 未找到
    
    int mid = left + (right - left) / 2;  // 避免溢出
    
    if (arr[mid] == target) return mid;
    if (arr[mid] > target) {
        return binary_search_recursive(arr, left, mid - 1, target);
    } else {
        return binary_search_recursive(arr, mid + 1, right, target);
    }
}

// 二分查找 - 迭代实现（推荐）
int binary_search_iterative(const int arr[], int size, int target) {
    int left = 0, right = size - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) return mid;
        if (arr[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return -1;  // 未找到
}
```

## 5. 实践应用

### 5.1 错误处理模式

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

// 错误码定义
typedef enum {
    ERR_SUCCESS = 0,
    ERR_NULL_POINTER,
    ERR_INVALID_ARGUMENT,
    ERR_MEMORY_ALLOCATION,
    ERR_FILE_NOT_FOUND,
    ERR_BUFFER_OVERFLOW
} ErrorCode;

// 安全的文件读取
ErrorCode read_file_content(const char *filename, char **content, size_t *size) {
    if (filename == NULL || content == NULL || size == NULL) {
        return ERR_NULL_POINTER;
    }
    
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        return ERR_FILE_NOT_FOUND;
    }
    
    // 获取文件大小
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    if (file_size < 0) {
        fclose(file);
        return ERR_INVALID_ARGUMENT;
    }
    
    // 分配内存
    *content = malloc(file_size + 1);
    if (*content == NULL) {
        fclose(file);
        return ERR_MEMORY_ALLOCATION;
    }
    
    // 读取文件
    size_t bytes_read = fread(*content, 1, file_size, file);
    (*content)[bytes_read] = '\0';
    *size = bytes_read;
    
    fclose(file);
    return ERR_SUCCESS;
}

// 错误处理示例
void demonstrate_error_handling(void) {
    char *content = NULL;
    size_t size = 0;
    
    ErrorCode result = read_file_content("example.txt", &content, &size);
    
    switch (result) {
        case ERR_SUCCESS:
            printf("File content (%zu bytes):\n%s\n", size, content);
            free(content);
            break;
        case ERR_FILE_NOT_FOUND:
            printf("Error: File not found\n");
            break;
        case ERR_MEMORY_ALLOCATION:
            printf("Error: Memory allocation failed\n");
            break;
        default:
            printf("Error: Unknown error occurred\n");
            break;
    }
}
```

### 5.2 数据结构操作

```c
// 动态数组实现
typedef struct {
    int *data;
    size_t size;
    size_t capacity;
} DynamicArray;

DynamicArray *array_create(size_t initial_capacity) {
    DynamicArray *arr = malloc(sizeof(DynamicArray));
    if (arr == NULL) return NULL;
    
    arr->data = malloc(initial_capacity * sizeof(int));
    if (arr->data == NULL) {
        free(arr);
        return NULL;
    }
    
    arr->size = 0;
    arr->capacity = initial_capacity;
    return arr;
}

bool array_push(DynamicArray *arr, int value) {
    if (arr == NULL) return false;
    
    if (arr->size >= arr->capacity) {
        // 扩容
        size_t new_capacity = arr->capacity * 2;
        int *new_data = realloc(arr->data, new_capacity * sizeof(int));
        if (new_data == NULL) return false;
        
        arr->data = new_data;
        arr->capacity = new_capacity;
    }
    
    arr->data[arr->size++] = value;
    return true;
}

void array_destroy(DynamicArray *arr) {
    if (arr != NULL) {
        free(arr->data);
        free(arr);
    }
}

// 使用示例
void dynamic_array_demo(void) {
    DynamicArray *arr = array_create(4);
    if (arr == NULL) {
        printf("Failed to create array\n");
        return;
    }
    
    // 添加元素
    for (int i = 0; i < 10; i++) {
        if (!array_push(arr, i * i)) {
            printf("Failed to add element\n");
            break;
        }
    }
    
    // 打印元素
    for (size_t i = 0; i < arr->size; i++) {
        printf("%d ", arr->data[i]);
    }
    printf("\n");
    
    array_destroy(arr);
}
```

### 5.3 算法实现

```c
// 快速排序实现
void quick_sort(int arr[], int low, int high) {
    if (low < high) {
        int pivot = partition(arr, low, high);
        quick_sort(arr, low, pivot - 1);
        quick_sort(arr, pivot + 1, high);
    }
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    
    swap(&arr[i + 1], &arr[high]);
    return i + 1;
}

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 字符串匹配算法
int string_search(const char *text, const char *pattern) {
    if (text == NULL || pattern == NULL) return -1;
    
    size_t text_len = strlen(text);
    size_t pattern_len = strlen(pattern);
    
    if (pattern_len > text_len) return -1;
    
    for (size_t i = 0; i <= text_len - pattern_len; i++) {
        size_t j;
        for (j = 0; j < pattern_len; j++) {
            if (text[i + j] != pattern[j]) break;
        }
        if (j == pattern_len) return (int)i;
    }
    
    return -1;  // 未找到
}
```

## 6. 性能优化与最佳实践

### 6.1 代码优化技巧

```c
// 循环优化
void loop_optimization_examples(void) {
    const int SIZE = 1000;
    int arr[SIZE];
    
    // 优化前：重复计算
    for (int i = 0; i < SIZE; i++) {
        arr[i] = i * i * i;  // 每次都计算立方
    }
    
    // 优化后：减少计算
    for (int i = 0; i < SIZE; i++) {
        int square = i * i;
        arr[i] = square * i;  // 复用平方结果
    }
}

// 性能优化示例：减少重复计算
int calculate_distance(int x1, int y1, int x2, int y2) {
    int dx = x2 - x1;
    int dy = y2 - y1;
    return dx * dx + dy * dy;  // 避免重复计算差值
}

// 性能优化示例：减少分支预测失败
int process_array_optimized(int arr[], int size) {
    int sum = 0;
    // 使用循环展开减少分支
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}

// 分支预测优化
void branch_prediction_optimization(const int *arr, size_t size) {
    int positive_count = 0;
    
    // 优化前：随机分支
    for (size_t i = 0; i < size; i++) {
        if (arr[i] > 0) {
            positive_count++;
        }
    }
    
    // 如果数据有序，分支预测会更准确
    printf("Positive numbers: %d\n", positive_count);
}

// 内存访问优化
void memory_access_optimization(int matrix[][100], int rows) {
    // 优化：按行访问（缓存友好）
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 100; j++) {
            matrix[i][j] = i + j;
        }
    }
    
    // 避免：按列访问（缓存不友好）
    // for (int j = 0; j < 100; j++) {
    //     for (int i = 0; i < rows; i++) {
    //         matrix[i][j] = i + j;
    //     }
    // }
}
```

### 6.2 调试和测试

```c
#include <assert.h>
#include <time.h>

// 断言使用
int safe_array_get(const int *arr, size_t size, size_t index) {
    assert(arr != NULL);
    assert(index < size);
    return arr[index];
}

// 性能测试
void performance_test(void) {
    clock_t start, end;
    const int N = 1000000;
    
    start = clock();
    
    // 测试代码
    long long sum = 0;
    for (int i = 0; i < N; i++) {
        sum += i;
    }
    
    end = clock();
    
    double cpu_time = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("Time taken: %f seconds\n", cpu_time);
    printf("Sum: %lld\n", sum);
}

// 单元测试示例
void test_factorial(void) {
    assert(factorial(0) == 1);
    assert(factorial(1) == 1);
    assert(factorial(5) == 120);
    assert(factorial(-1) == -1);  // 错误情况
    printf("All factorial tests passed!\n");
}
```

## 7. 总结

### 核心要点

1. **控制结构掌握**：熟练使用三种基本控制结构，避免深层嵌套
2. **函数设计原则**：单一职责、输入验证、错误处理
3. **内存安全**：正确管理动态内存，避免内存泄漏和悬空指针
4. **性能优化**：了解编译器优化，编写缓存友好的代码
5. **调试技巧**：使用断言、单元测试和性能分析工具

### 最佳实践

- **代码可读性**：使用有意义的变量名和函数名
- **错误处理**：总是检查函数返回值和指针有效性
- **资源管理**：遵循RAII原则，及时释放资源
- **测试驱动**：编写测试用例验证函数正确性
- **性能意识**：了解算法复杂度，选择合适的数据结构

### 进阶方向

- 学习更复杂的数据结构（链表、树、图）
- 掌握高级算法设计技巧
- 理解并发编程和线程安全
- 深入学习编译器优化原理
- 掌握调试工具和性能分析工具

通过掌握这些控制结构和函数设计技巧，你将能够编写出高效、安全、可维护的C语言程序。记住，良好的编程习惯和持续的实践是成为优秀程序员的关键。

