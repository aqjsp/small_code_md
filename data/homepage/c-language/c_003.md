# 控制流与函数：从流程到模块化

目标：掌握选择与循环语句、函数声明与定义、作用域与链接、头文件组织与编译单元。

## 1. 控制流语句
- if / else if / else：选择分支
- switch / case / default：整型选择，注意break防止贯穿
- for / while / do-while：循环；for包含初始化、条件、迭代表达式
- break / continue：控制循环；goto不建议使用

## 2. 函数
- 声明与定义：返回类型、参数列表、形参与实参
- 原型的重要性：避免隐式声明（C99之后禁止）
- 返回与参数传递：值传递；需要修改外部数据时用指针
- 递归与尾递归优化（取决于实现）

示例：
```c
#include <stdio.h>

int add(int a, int b) { return a + b; }

int main(void) {
    int s = add(2, 3);
    printf("%d\n", s);
    return 0;
}
```

## 3. 作用域、存储期与链接
- 作用域：块作用域、函数作用域、文件作用域
- 标识符链接：无链接（局部）、内部链接（static）、外部链接（默认）
- 存储期：自动（栈）、静态（全局/静态）、动态（堆，malloc/free）

## 4. 头文件与编译单元
- 头文件放声明、宏与内联；源文件放定义与实现
- 头文件保护：#ifndef/#define/#endif 或 #pragma once（非标准但常见）
- 多文件编译：gcc a.c b.c -o prog 或分别编译后链接

## 5. 练习
- 写一个计算n!的函数与迭代/递归实现，比较性能与栈深度。
- 使用switch实现一个简易菜单。
- 将函数声明放入头文件，源文件实现，演示多文件编译。

## 更多示例

示例A：尾递归与普通递归
```c
#include <stdio.h>

long fact_rec(long n){
    return n<=1 ? 1 : n * fact_rec(n-1);
}

long fact_tail_impl(long n, long acc){
    return n<=1 ? acc : fact_tail_impl(n-1, n*acc);
}

long fact_tail(long n){
    return fact_tail_impl(n, 1);
}

int main(void){
    printf("%ld %ld\n", fact_rec(10), fact_tail(10));
}
```
说明：尾递归优化是否发生取决于实现与优化级别。

示例B：头文件与源文件
- mathx.h
```c
#ifndef MATHX_H
#define MATHX_H
int add(int a, int b);
#endif
```
- mathx.c
```c
int add(int a, int b){ return a+b; }
```
- main.c
```c
#include <stdio.h>
#include "mathx.h"
int main(void){ printf("%d\n", add(2,3)); }
```
构建：`gcc main.c mathx.c -o app`

## 练习参考答案（节选）
- n!：给出迭代与递归版本，比较函数调用开销与栈深度。
- switch菜单：确保每个case以break结束，default兜底。

## 参考资料
- C 接口与实现组织建议：以头文件暴露API、隐藏实现细节。
- CMake 多文件构建示例（官方教程章节 2-4）。