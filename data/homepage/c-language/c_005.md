# C语言结构体、联合体与枚举

## 学习目标

通过本章学习，你将掌握：
- 结构体的定义、初始化和成员访问方法
- 联合体的内存共享机制和应用场景
- 枚举类型的定义和使用规范
- 位域的概念和内存优化技巧
- 复合数据类型在实际项目中的应用

## 1. 结构体基础

### 1.1 什么是结构体

结构体是将不同类型的数据组合在一起的复合数据类型，它允许我们创建自定义的数据类型来表示现实世界中的实体。

```c
#include <stdio.h>
#include <string.h>

// 定义一个学生结构体
struct Student {
    int id;
    char name[50];
    float score;
    int age;
};

// 使用typedef简化类型名
typedef struct {
    double x;
    double y;
} Point;
```

### 1.2 结构体的声明和初始化

```c
void struct_declaration_demo() {
    // 方法1：声明后赋值
    struct Student s1;
    s1.id = 1001;
    strcpy(s1.name, "张三");
    s1.score = 85.5;
    s1.age = 20;
    
    // 方法2：初始化列表
    struct Student s2 = {1002, "李四", 92.0, 19};
    
    // 方法3：指定成员初始化（C99）
    struct Student s3 = {
        .id = 1003,
        .name = "王五",
        .score = 78.5,
        .age = 21
    };
    
    // 使用typedef定义的类型
    Point p1 = {3.0, 4.0};
    Point p2 = {.x = 1.0, .y = 2.0};
    
    printf("学生%s的成绩: %.1f\n", s1.name, s1.score);
    printf("点坐标: (%.1f, %.1f)\n", p1.x, p1.y);
}
```

### 1.3 结构体成员访问

```c
void struct_access_demo() {
    Point p = {3.0, 4.0};
    Point *ptr = &p;
    
    // 直接访问成员
    printf("x = %.1f, y = %.1f\n", p.x, p.y);
    
    // 通过指针访问成员
    printf("x = %.1f, y = %.1f\n", (*ptr).x, (*ptr).y);
    
    // 使用箭头操作符（推荐）
    printf("x = %.1f, y = %.1f\n", ptr->x, ptr->y);
    
    // 修改成员值
    ptr->x = 5.0;
    ptr->y = 6.0;
    printf("修改后: x = %.1f, y = %.1f\n", p.x, p.y);
}
```

### 1.4 结构体数组

```c
void struct_array_demo() {
    // 结构体数组
    struct Student class[3] = {
        {1001, "张三", 85.5, 20},
        {1002, "李四", 92.0, 19},
        {1003, "王五", 78.5, 21}
    };
    
    // 遍历结构体数组
    printf("班级成绩单:\n");
    for (int i = 0; i < 3; i++) {
        printf("学号: %d, 姓名: %s, 成绩: %.1f, 年龄: %d\n",
               class[i].id, class[i].name, class[i].score, class[i].age);
    }
    
    // 计算平均分
    float total = 0;
    for (int i = 0; i < 3; i++) {
        total += class[i].score;
    }
    printf("平均分: %.1f\n", total / 3);
}
```

### 1.5 嵌套结构体

```c
// 地址结构体
typedef struct {
    char street[100];
    char city[50];
    char zipcode[10];
} Address;

// 包含地址的人员结构体
typedef struct {
    char name[50];
    int age;
    Address addr;  // 嵌套结构体
} Person;

void nested_struct_demo() {
    Person person = {
        .name = "张三",
        .age = 25,
        .addr = {
            .street = "中山路123号",
            .city = "北京",
            .zipcode = "100000"
        }
    };
    
    printf("姓名: %s\n", person.name);
    printf("年龄: %d\n", person.age);
    printf("地址: %s, %s, %s\n", 
           person.addr.street, person.addr.city, person.addr.zipcode);
}
```

## 2. 联合体（Union）

### 2.1 基本概念

联合体（Union）是一种特殊的数据类型，它允许在同一内存位置存储不同类型的数据。与结构体不同，联合体的所有成员共享同一块内存空间，修改一个成员会影响其余所有成员。

联合体的定义格式为：

```c
union 共用体名{
    成员列表
};
```

联合体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。

### 2.2 结构体与联合体的区别

结构体和联合体的区别在于：
- 结构体的各个成员会占用不同的内存，互相之间没有影响
- 联合体的所有成员占用同一段内存，修改一个成员会影响其余所有成员

结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），联合体占用的内存等于最长的成员占用的内存。联合体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

### 2.3 联合体变量的定义

联合体也是一种自定义类型，可以通过它来创建变量：

```c
union data{
    int n;
    char ch;
    double f;
};
union data a, b, c;
```

也可以在定义联合体的同时创建变量：

```c
union data{
    int n;
    char ch;
    double f;
} a, b, c;
```

如果不再定义新的变量，也可以将联合体的名字省略：

```c
union{
    int n;
    char ch;
    double f;
} a, b, c;
```

### 2.4 共享内存示例

联合体的所有成员占用同一段内存，修改一个成员会影响其他成员：

```c
#include <stdio.h>

union data{
    int n;
    char ch;
    short m;
};

int main(){
    union data a;
    printf("%d, %d\n", sizeof(a), sizeof(union data) );
    
    a.n = 0x40;
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    
    a.ch = '9';
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    
    a.m = 0x2059;
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    
    a.n = 0x3E25AD54;
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    
    return 0;
}
```

运行结果：
```
4, 4
40, @, 40
39, 9, 39
2059, Y, 2059
3E25AD54, T, AD54
```

这段代码不但验证了联合体的长度，还说明联合体成员之间会相互影响，修改一个成员的值会影响其他成员。

### 2.5 内存布局

成员 n、ch、m 在内存中"对齐"到一头，对 ch 赋值修改的是前一个字节，对 m 赋值修改的是前两个字节，对 n 赋值修改的是全部字节。也就是说，ch、m 会影响到 n 的一部分数据，而 n 会影响到 ch、m 的全部数据。

void union_basics() {
    union Data data;
    
    // 存储整数
    data.i = 10;
    printf("data.i = %d\n", data.i);
    
    // 存储浮点数（覆盖之前的整数）
    data.f = 220.5;
    printf("data.f = %.1f\n", data.f);
    
    // 存储字符串（覆盖之前的浮点数）
    strcpy(data.str, "Hello");
    printf("data.str = %s\n", data.str);
    
    printf("联合体大小: %zu字节\n", sizeof(union Data));
}
```

### 2.6 标记联合体

为了安全使用联合体，通常配合枚举类型创建标记联合体：

```c
// 数据类型标记
typedef enum {
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_STRING
} DataType;

// 标记联合体
typedef struct {
    DataType type;
    union {
        int i;
        float f;
        char str[20];
    } value;
} TaggedData;

void tagged_union_demo() {
    TaggedData data1 = {TYPE_INT, .value.i = 42};
    TaggedData data2 = {TYPE_FLOAT, .value.f = 3.14};
    TaggedData data3 = {TYPE_STRING};
    strcpy(data3.value.str, "Hello");
    
    // 安全访问联合体成员
    TaggedData items[] = {data1, data2, data3};
    
    for (int i = 0; i < 3; i++) {
        switch (items[i].type) {
            case TYPE_INT:
                printf("整数: %d\n", items[i].value.i);
                break;
            case TYPE_FLOAT:
                printf("浮点数: %.2f\n", items[i].value.f);
                break;
            case TYPE_STRING:
                printf("字符串: %s\n", items[i].value.str);
                break;
        }
    }
}
```

### 2.7 联合体的实际应用

```c
// 网络数据包示例
typedef struct {
    unsigned char type;
    union {
        struct {
            int user_id;
            char message[100];
        } chat;
        struct {
            float x, y, z;
        } position;
        struct {
            int health;
            int mana;
        } status;
    } data;
} NetworkPacket;

void network_packet_demo() {
    NetworkPacket packet;
    
    // 聊天消息包
    packet.type = 1;
    packet.data.chat.user_id = 123;
    strcpy(packet.data.chat.message, "Hello World!");
    
    printf("消息包 - 用户ID: %d, 消息: %s\n", 
           packet.data.chat.user_id, packet.data.chat.message);
    
    // 位置更新包
    packet.type = 2;
    packet.data.position.x = 10.5;
    packet.data.position.y = 20.3;
    packet.data.position.z = 5.7;
    
    printf("位置包 - 坐标: (%.1f, %.1f, %.1f)\n",
           packet.data.position.x, packet.data.position.y, packet.data.position.z);
}
```

## 3. 枚举类型

### 3.1 枚举基础

在实际编程中，有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用。C语言提供了一种枚举（Enum）类型，能够列出所有可能的取值，并给它们取一个名字。

枚举类型的定义形式为：

```c
enum typeName{ valueName1, valueName2, valueName3, ...... };
```

enum是一个新的关键字，专门用来定义枚举类型，这也是它在C语言中的唯一用途；typeName是枚举类型的名字；valueName1, valueName2, valueName3, ......是每个值对应的名字的列表。注意最后的;不能少。

### 枚举值的赋值

我们可以仅仅给出名字，却没有给出名字对应的值，这是因为枚举值默认从 0 开始，往后逐个加 1（递增）：

```c
enum week{ Mon, Tues, Wed, Thurs, Fri, Sat, Sun };
```

week 中的 Mon、Tues ...... Sun 对应的值分别为 0、1 ...... 6。

我们也可以给每个名字都指定一个值：

```c
enum week{ Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 };
```

更为简单的方法是只给第一个名字指定值：

```c
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
```

这样枚举值就从 1 开始递增，跟上面的写法是等效的。

### 枚举变量的定义和使用

枚举是一种类型，通过它可以定义枚举变量：

```c
enum week a, b, c;
```

也可以在定义枚举类型的同时定义变量：

```c
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } a, b, c;
```

有了枚举变量，就可以把列表中的值赋给它：

```c
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
enum week a = Mon, b = Wed, c = Sat;
```

### 实际应用示例

判断用户输入的是星期几：

```c
#include <stdio.h>

int main(){
    enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } day;
    scanf("%d", &day);
    switch(day){
        case Mon: puts("Monday"); break;
        case Tues: puts("Tuesday"); break;
        case Wed: puts("Wednesday"); break;
        case Thurs: puts("Thursday"); break;
        case Fri: puts("Friday"); break;
        case Sat: puts("Saturday"); break;
        case Sun: puts("Sunday"); break;
        default: puts("Error!");
    }
    return 0;
}
```

运行结果：
```
4↙
Thursday
```

### 枚举的本质

需要注意的两点是：

1) 枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。

2) Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。

枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。

Mon、Tues、Wed 这些名字都被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用&取得它们的地址。这就是枚举的本质。

// 使用typedef简化
typedef enum {
    MONDAY = 1,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
} Weekday;

void enum_basics() {
    enum Color color = RED;
    enum Status status = SUCCESS;
    Weekday today = FRIDAY;
    
    printf("颜色值: %d\n", color);
    printf("状态值: %d\n", status);
    printf("今天是第%d天\n", today);
}```

### 3.2 枚举的实际应用

```c
// 游戏状态管理
typedef enum {
    GAME_MENU,
    GAME_PLAYING,
    GAME_PAUSED,
    GAME_OVER
} GameState;

// 文件操作结果
typedef enum {
    FILE_OK = 0,
    FILE_NOT_FOUND = -1,
    FILE_PERMISSION_DENIED = -2,
    FILE_IO_ERROR = -3
} FileResult;

void enum_applications() {
    GameState state = GAME_MENU;
    
    switch (state) {
        case GAME_MENU:
            printf("显示游戏菜单\n");
            break;
        case GAME_PLAYING:
            printf("游戏进行中\n");
            break;
        case GAME_PAUSED:
            printf("游戏已暂停\n");
            break;
        case GAME_OVER:
            printf("游戏结束\n");
            break;
    }
    
    // 文件操作示例
    FileResult result = FILE_OK;
    if (result == FILE_OK) {
        printf("文件操作成功\n");
    } else {
        printf("文件操作失败，错误码: %d\n", result);
    }
}
```

### 3.3 枚举与字符串转换

```c
// 枚举到字符串的转换
const char* color_to_string(enum Color color) {
    switch (color) {
        case RED:   return "红色";
        case GREEN: return "绿色";
        case BLUE:  return "蓝色";
        default:    return "未知颜色";
    }
}

// 字符串到枚举的转换
enum Color string_to_color(const char* str) {
    if (strcmp(str, "red") == 0) return RED;
    if (strcmp(str, "green") == 0) return GREEN;
    if (strcmp(str, "blue") == 0) return BLUE;
    return -1;  // 表示无效值
}

void enum_string_conversion() {
    enum Color colors[] = {RED, GREEN, BLUE};
    
    for (int i = 0; i < 3; i++) {
        printf("颜色 %d: %s\n", colors[i], color_to_string(colors[i]));
    }
    
    enum Color color = string_to_color("green");
    if (color != -1) {
        printf("解析的颜色: %s\n", color_to_string(color));
    }
}
```

## 4. 位域

### 4.1 位域基础

位域允许在结构体中以位为单位分配存储空间，常用于节省内存或映射硬件寄存器。

```c
// 位域结构体
struct Flags {
    unsigned int is_visible : 1;    // 1位
    unsigned int is_enabled : 1;    // 1位
    unsigned int priority : 3;      // 3位（0-7）
    unsigned int reserved : 3;      // 3位保留
};

// 硬件寄存器映射示例
struct ControlRegister {
    unsigned int enable : 1;        // 使能位
    unsigned int mode : 2;          // 工作模式（0-3）
    unsigned int speed : 3;         // 速度设置（0-7）
    unsigned int interrupt : 1;     // 中断使能
    unsigned int reserved : 25;     // 保留位
};

void bitfield_demo() {
    struct Flags flags = {0};
    
    // 设置位域值
    flags.is_visible = 1;
    flags.is_enabled = 1;
    flags.priority = 5;
    
    printf("可见: %d, 启用: %d, 优先级: %d\n",
           flags.is_visible, flags.is_enabled, flags.priority);
    
    printf("Flags结构体大小: %zu字节\n", sizeof(struct Flags));
    
    // 硬件寄存器操作
    struct ControlRegister reg = {0};
    reg.enable = 1;
    reg.mode = 2;
    reg.speed = 7;
    reg.interrupt = 1;
    
    printf("寄存器配置 - 使能: %d, 模式: %d, 速度: %d, 中断: %d\n",
           reg.enable, reg.mode, reg.speed, reg.interrupt);
}
```

### 4.2 位域的注意事项

```c
void bitfield_limitations() {
    struct Flags flags = {1, 1, 5, 0};
    
    // 位域的限制：
    // 1. 不能取地址
    // printf("地址: %p\n", &flags.is_visible);  // 编译错误
    
    // 2. 不能用作数组元素类型
    // unsigned int arr : 3[10];  // 编译错误
    
    // 3. 位域的存储和字节序相关
    printf("整个结构体的值: %u\n", *(unsigned int*)&flags);
    
    // 4. 跨越存储单元边界的行为是实现定义的
    struct CrossBoundary {
        unsigned int a : 30;
        unsigned int b : 5;  // 可能跨越32位边界
    };
    
    printf("CrossBoundary大小: %zu字节\n", sizeof(struct CrossBoundary));
}
```

## 5. 实践示例

### 5.1 学生管理系统

```c
#include <stdlib.h>

#define MAX_STUDENTS 100
#define MAX_NAME_LEN 50

typedef struct {
    int id;
    char name[MAX_NAME_LEN];
    float score;
    int age;
} Student;

typedef struct {
    Student students[MAX_STUDENTS];
    int count;
} StudentManager;

// 初始化学生管理器
void init_manager(StudentManager *mgr) {
    mgr->count = 0;
}

// 添加学生
int add_student(StudentManager *mgr, int id, const char *name, float score, int age) {
    if (mgr->count >= MAX_STUDENTS) {
        printf("学生数量已达上限\n");
        return -1;
    }
    
    Student *s = &mgr->students[mgr->count];
    s->id = id;
    strncpy(s->name, name, MAX_NAME_LEN - 1);
    s->name[MAX_NAME_LEN - 1] = '\0';
    s->score = score;
    s->age = age;
    
    mgr->count++;
    return 0;
}

// 查找学生
Student* find_student(StudentManager *mgr, int id) {
    for (int i = 0; i < mgr->count; i++) {
        if (mgr->students[i].id == id) {
            return &mgr->students[i];
        }
    }
    return NULL;
}

// 显示所有学生
void display_students(StudentManager *mgr) {
    printf("\n学生列表:\n");
    printf("学号\t姓名\t\t成绩\t年龄\n");
    printf("----------------------------------------\n");
    
    for (int i = 0; i < mgr->count; i++) {
        Student *s = &mgr->students[i];
        printf("%d\t%-10s\t%.1f\t%d\n", s->id, s->name, s->score, s->age);
    }
}

// 计算平均分
float calculate_average(StudentManager *mgr) {
    if (mgr->count == 0) return 0.0;
    
    float total = 0;
    for (int i = 0; i < mgr->count; i++) {
        total += mgr->students[i].score;
    }
    return total / mgr->count;
}

void student_management_demo() {
    StudentManager mgr;
    init_manager(&mgr);
    
    // 添加学生
    add_student(&mgr, 1001, "张三", 85.5, 20);
    add_student(&mgr, 1002, "李四", 92.0, 19);
    add_student(&mgr, 1003, "王五", 78.5, 21);
    add_student(&mgr, 1004, "赵六", 88.0, 20);
    
    // 显示所有学生
    display_students(&mgr);
    
    // 查找特定学生
    Student *student = find_student(&mgr, 1002);
    if (student) {
        printf("\n找到学生: %s, 成绩: %.1f\n", student->name, student->score);
    }
    
    // 计算平均分
    printf("班级平均分: %.1f\n", calculate_average(&mgr));
}
```

### 5.2 配置文件解析器

```c
typedef enum {
    CONFIG_STRING,
    CONFIG_INT,
    CONFIG_FLOAT,
    CONFIG_BOOL
} ConfigType;

typedef struct {
    char key[50];
    ConfigType type;
    union {
        char str_val[100];
        int int_val;
        float float_val;
        int bool_val;
    } value;
} ConfigItem;

typedef struct {
    ConfigItem items[50];
    int count;
} Config;

void config_demo() {
    Config config = {0};
    
    // 添加配置项
    strcpy(config.items[0].key, "server_name");
    config.items[0].type = CONFIG_STRING;
    strcpy(config.items[0].value.str_val, "MyServer");
    
    strcpy(config.items[1].key, "port");
    config.items[1].type = CONFIG_INT;
    config.items[1].value.int_val = 8080;
    
    strcpy(config.items[2].key, "timeout");
    config.items[2].type = CONFIG_FLOAT;
    config.items[2].value.float_val = 30.5;
    
    strcpy(config.items[3].key, "debug");
    config.items[3].type = CONFIG_BOOL;
    config.items[3].value.bool_val = 1;
    
    config.count = 4;
    
    // 显示配置
    printf("配置信息:\n");
    for (int i = 0; i < config.count; i++) {
        ConfigItem *item = &config.items[i];
        printf("%s = ", item->key);
        
        switch (item->type) {
            case CONFIG_STRING:
                printf("%s\n", item->value.str_val);
                break;
            case CONFIG_INT:
                printf("%d\n", item->value.int_val);
                break;
            case CONFIG_FLOAT:
                printf("%.1f\n", item->value.float_val);
                break;
            case CONFIG_BOOL:
                printf("%s\n", item->value.bool_val ? "true" : "false");
                break;
        }
    }
}
```

## 6. 最佳实践

### 6.1 结构体设计原则

1. **合理的成员顺序**：将相同类型的成员放在一起，减少内存填充
2. **使用typedef**：简化类型名，提高代码可读性
3. **初始化检查**：总是初始化结构体成员
4. **内存对齐考虑**：了解编译器的对齐规则

```c
// 不好的设计（内存浪费）
struct BadDesign {
    char a;     // 1字节
    int b;      // 4字节，前面填充3字节
    char c;     // 1字节
    int d;      // 4字节，前面填充3字节
};  // 总共16字节

// 好的设计（内存紧凑）
struct GoodDesign {
    int b;      // 4字节
    int d;      // 4字节
    char a;     // 1字节
    char c;     // 1字节
    // 尾部填充2字节
};  // 总共12字节

void memory_alignment_demo() {
    printf("BadDesign大小: %zu字节\n", sizeof(struct BadDesign));
    printf("GoodDesign大小: %zu字节\n", sizeof(struct GoodDesign));
}
```

### 6.2 联合体使用建议

1. **总是使用标记联合体**：确保类型安全
2. **小心字节序问题**：在不同平台间传输数据时
3. **避免未定义行为**：不要读取未设置的联合体成员

### 6.3 枚举使用建议

1. **使用有意义的名称**：提高代码可读性
2. **显式指定重要值**：特别是用于文件格式或协议的枚举
3. **提供转换函数**：枚举与字符串之间的转换
4. **使用typedef**：简化类型名

## 总结

复合数据类型是C语言中构建复杂程序的重要工具：

1. **结构体**：用于组织相关数据，是面向对象编程的基础
2. **联合体**：实现内存共享，适用于变体数据和内存优化
3. **枚举**：提供类型安全的常量定义，提高代码可读性
4. **位域**：实现位级控制，适用于硬件编程和内存优化

掌握这些复合数据类型的正确使用方法，能够帮助你编写更加结构化、可维护和高效的C程序。在实际开发中，要根据具体需求选择合适的数据类型，并遵循最佳实践来确保代码质量。
