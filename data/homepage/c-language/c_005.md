# 结构体、联合与枚举：构造数据模型

目标：熟悉结构体、联合与枚举的语法与语义，掌握对齐与填充、位域、灵活数组成员、初始化与拷贝规则。

## 1. 结构体 struct
- 聚合多种类型的字段；支持嵌套
- 初始化：聚合初始化、指定初始化（C99）、零初始化
- 拷贝是按字节拷贝（浅拷贝）；注意指针成员的所有权
- 对齐与填充影响 sizeof；可使用#pragma pack（非可移植）谨慎控制

## 2. 联合 union
- 成员共享同一块内存；一次只存放一个有效成员
- 常用于类型覆盖或节省内存；需小心未定义行为（读取未激活成员）

## 3. 枚举 enum
- 命名整型常量集合；底层类型为int（实现相关）
- 可指定枚举值；与switch配合提升可读性

## 4. 位域与对齐
- 位域用于紧凑表示；类型通常为unsigned
- 可移植性受实现影响：位序、对齐、溢出行为

## 5. 灵活数组成员（C99）
- 结构体最后一个成员可声明为不定长：int data[];
- 需配合动态分配与自定义大小；sizeof不含灵活成员空间

示例：
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    size_t len;
    int data[]; // 灵活数组成员
} IntVec;

IntVec* intvec_new(size_t n) {
    IntVec *p = malloc(sizeof *p + n * sizeof(int));
    if (!p) return NULL;
    p->len = n;
    return p;
}
```

## 6. 练习
- 设计一个学生信息结构体，包含姓名指针、年龄、成绩数组，编写初始化与销毁函数。
- 用枚举与switch实现日志级别（DEBUG/INFO/WARN/ERROR）。
- 实验不同字段顺序对结构体sizeof的影响。

## 更多示例

示例A：位域使用
```c
struct Flags {
    unsigned a:1;
    unsigned b:2;
    unsigned c:5;
};
```
注意：位域布局（高位低位、对齐）是实现定义，跨平台需谨慎。

示例B：灵活数组成员的创建与销毁
```c
#include <stdlib.h>
#include <string.h>

typedef struct {
    size_t len;
    char data[];
} Str;

Str* str_new(const char *s){
    size_t n = strlen(s);
    Str *p = malloc(sizeof *p + n + 1);
    if(!p) return NULL;
    p->len = n;
    memcpy(p->data, s, n+1);
    return p;
}
```

示例C：结构体对齐实验
```c
#include <stdio.h>
struct A{ char c; int i; short s; };   // 可能较大
struct B{ int i; short s; char c; };   // 可能更紧凑
int main(void){ printf("%zu %zu\n", sizeof(struct A), sizeof(struct B)); }
```

## 练习参考答案（节选）
- 学生信息结构体：姓名用动态分配的char*，提供init/destroy拷贝语义。
- 日志级别枚举：配合switch输出字符串，确保default处理未知级别。

## 参考资料
- C 标准关于位域与对齐的条款；不同ABI文档（如System V AMD64 ABI）对布局约定。