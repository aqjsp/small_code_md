# C语言工程实践与软件工程

## 1. 现代C语言项目架构设计

### 1.1 分层架构设计模式

现代C语言项目需要清晰的分层架构来管理复杂性和提高可维护性。

```c
// include/core/architecture.h
#ifndef ARCHITECTURE_H
#define ARCHITECTURE_H

#include <stdint.h>
#include <stdbool.h>

// 架构层次定义
typedef enum {
    LAYER_PRESENTATION = 0,  // 表示层
    LAYER_APPLICATION,       // 应用层
    LAYER_DOMAIN,           // 领域层
    LAYER_INFRASTRUCTURE,   // 基础设施层
    LAYER_COUNT
} layer_type_t;

// 组件接口定义
typedef struct component_interface {
    const char* name;
    const char* version;
    layer_type_t layer;
    
    // 生命周期管理
    int (*initialize)(void* config);
    int (*start)(void);
    int (*stop)(void);
    int (*cleanup)(void);
    
    // 健康检查
    bool (*health_check)(void);
    
    // 依赖管理
    const char** dependencies;
    size_t dependency_count;
} component_interface_t;

// 依赖注入容器
typedef struct di_container {
    component_interface_t** components;
    size_t component_count;
    size_t capacity;
    
    // 组件实例映射
    void** instances;
    bool* initialized;
} di_container_t;

// 架构管理器
typedef struct architecture_manager {
    di_container_t container;
    layer_type_t current_layer;
    
    // 层间通信
    int (*send_message)(layer_type_t from, layer_type_t to, 
                       const void* message, size_t size);
    
    // 事件总线
    void (*publish_event)(const char* event_type, const void* data);
    void (*subscribe_event)(const char* event_type, 
                           void (*handler)(const void* data));
} architecture_manager_t;

// API声明
architecture_manager_t* arch_manager_create(void);
void arch_manager_destroy(architecture_manager_t* manager);
int arch_register_component(architecture_manager_t* manager, 
                           component_interface_t* component);
int arch_initialize_system(architecture_manager_t* manager);
int arch_start_system(architecture_manager_t* manager);
int arch_stop_system(architecture_manager_t* manager);

#endif // ARCHITECTURE_H
```

```c
// src/core/architecture.c
#include "core/architecture.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// 依赖注入容器实现
static di_container_t* di_container_create(size_t initial_capacity) {
    di_container_t* container = malloc(sizeof(di_container_t));
    if (!container) return NULL;
    
    container->components = malloc(sizeof(component_interface_t*) * initial_capacity);
    container->instances = malloc(sizeof(void*) * initial_capacity);
    container->initialized = malloc(sizeof(bool) * initial_capacity);
    
    if (!container->components || !container->instances || !container->initialized) {
        free(container->components);
        free(container->instances);
        free(container->initialized);
        free(container);
        return NULL;
    }
    
    container->component_count = 0;
    container->capacity = initial_capacity;
    
    // 初始化状态
    for (size_t i = 0; i < initial_capacity; i++) {
        container->components[i] = NULL;
        container->instances[i] = NULL;
        container->initialized[i] = false;
    }
    
    return container;
}

// 拓扑排序解决依赖关系
static int resolve_dependencies(architecture_manager_t* manager) {
    di_container_t* container = &manager->container;
    bool* visited = calloc(container->component_count, sizeof(bool));
    bool* in_stack = calloc(container->component_count, sizeof(bool));
    int* init_order = malloc(sizeof(int) * container->component_count);
    int order_index = 0;
    
    if (!visited || !in_stack || !init_order) {
        free(visited);
        free(in_stack);
        free(init_order);
        return -1;
    }
    
    // DFS拓扑排序
    bool has_cycle = false;
    
    for (size_t i = 0; i < container->component_count && !has_cycle; i++) {
        if (!visited[i]) {
            // 简化的DFS实现（实际项目中需要完整的循环检测）
            visited[i] = true;
            init_order[order_index++] = i;
        }
    }
    
    // 按依赖顺序初始化组件
    for (int i = 0; i < order_index; i++) {
        int comp_idx = init_order[i];
        component_interface_t* comp = container->components[comp_idx];
        
        if (comp->initialize) {
            int result = comp->initialize(NULL);
            if (result != 0) {
                printf("Failed to initialize component: %s\n", comp->name);
                free(visited);
                free(in_stack);
                free(init_order);
                return result;
            }
            container->initialized[comp_idx] = true;
        }
    }
    
    free(visited);
    free(in_stack);
    free(init_order);
    return 0;
}

// 架构管理器实现
architecture_manager_t* arch_manager_create(void) {
    architecture_manager_t* manager = malloc(sizeof(architecture_manager_t));
    if (!manager) return NULL;
    
    // 初始化依赖注入容器
    di_container_t* container = di_container_create(16);
    if (!container) {
        free(manager);
        return NULL;
    }
    
    manager->container = *container;
    free(container);
    manager->current_layer = LAYER_INFRASTRUCTURE;
    
    return manager;
}

int arch_register_component(architecture_manager_t* manager, 
                           component_interface_t* component) {
    if (!manager || !component) return -1;
    
    di_container_t* container = &manager->container;
    
    // 扩容检查
    if (container->component_count >= container->capacity) {
        size_t new_capacity = container->capacity * 2;
        
        component_interface_t** new_components = realloc(container->components,
            sizeof(component_interface_t*) * new_capacity);
        void** new_instances = realloc(container->instances,
            sizeof(void*) * new_capacity);
        bool* new_initialized = realloc(container->initialized,
            sizeof(bool) * new_capacity);
            
        if (!new_components || !new_instances || !new_initialized) {
            return -1;
        }
        
        container->components = new_components;
        container->instances = new_instances;
        container->initialized = new_initialized;
        container->capacity = new_capacity;
    }
    
    // 注册组件
    container->components[container->component_count] = component;
    container->instances[container->component_count] = NULL;
    container->initialized[container->component_count] = false;
    container->component_count++;
    
    printf("Registered component: %s (Layer: %d)\n", component->name, component->layer);
    return 0;
}

int arch_initialize_system(architecture_manager_t* manager) {
    if (!manager) return -1;
    
    printf("Initializing system architecture...\n");
    return resolve_dependencies(manager);
}

int arch_start_system(architecture_manager_t* manager) {
    if (!manager) return -1;
    
    printf("Starting system components...\n");
    di_container_t* container = &manager->container;
    
    for (size_t i = 0; i < container->component_count; i++) {
        component_interface_t* comp = container->components[i];
        if (container->initialized[i] && comp->start) {
            int result = comp->start();
            if (result != 0) {
                printf("Failed to start component: %s\n", comp->name);
                return result;
            }
        }
    }
    
    return 0;
}

void arch_manager_destroy(architecture_manager_t* manager) {
    if (!manager) return;
    
    // 停止所有组件
    di_container_t* container = &manager->container;
    for (size_t i = 0; i < container->component_count; i++) {
        component_interface_t* comp = container->components[i];
        if (container->initialized[i] && comp->stop) {
            comp->stop();
        }
        if (comp->cleanup) {
            comp->cleanup();
        }
    }
    
    free(container->components);
    free(container->instances);
    free(container->initialized);
    free(manager);
}
```

### 1.2 模块化设计与插件系统

```c
// include/core/plugin_system.h
#ifndef PLUGIN_SYSTEM_H
#define PLUGIN_SYSTEM_H

#include <stdint.h>
#include <stdbool.h>

// 插件接口版本
#define PLUGIN_API_VERSION 1

// 插件类型
typedef enum {
    PLUGIN_TYPE_FILTER = 0,
    PLUGIN_TYPE_HANDLER,
    PLUGIN_TYPE_MIDDLEWARE,
    PLUGIN_TYPE_EXTENSION,
    PLUGIN_TYPE_COUNT
} plugin_type_t;

// 插件元数据
typedef struct plugin_metadata {
    const char* name;
    const char* version;
    const char* author;
    const char* description;
    plugin_type_t type;
    uint32_t api_version;
    
    // 依赖信息
    const char** dependencies;
    size_t dependency_count;
    
    // 配置schema
    const char* config_schema;
} plugin_metadata_t;

// 插件接口
typedef struct plugin_interface {
    plugin_metadata_t metadata;
    
    // 生命周期
    int (*load)(const char* config);
    int (*unload)(void);
    int (*reload)(const char* config);
    
    // 功能接口
    int (*process)(const void* input, void** output, size_t* output_size);
    
    // 状态查询
    bool (*is_active)(void);
    const char* (*get_status)(void);
    
    // 配置管理
    int (*set_config)(const char* key, const char* value);
    const char* (*get_config)(const char* key);
} plugin_interface_t;

// 插件管理器
typedef struct plugin_manager {
    plugin_interface_t** plugins;
    size_t plugin_count;
    size_t capacity;
    
    // 插件索引
    struct {
        const char* name;
        size_t index;
    }* name_index;
    
    // 类型分组
    size_t* type_groups[PLUGIN_TYPE_COUNT];
    size_t type_counts[PLUGIN_TYPE_COUNT];
    
    // 事件系统
    void (*on_plugin_loaded)(const char* plugin_name);
    void (*on_plugin_unloaded)(const char* plugin_name);
    void (*on_plugin_error)(const char* plugin_name, const char* error);
} plugin_manager_t;

// API声明
plugin_manager_t* plugin_manager_create(void);
void plugin_manager_destroy(plugin_manager_t* manager);
int plugin_register(plugin_manager_t* manager, plugin_interface_t* plugin);
int plugin_unregister(plugin_manager_t* manager, const char* name);
plugin_interface_t* plugin_find(plugin_manager_t* manager, const char* name);
int plugin_load_all(plugin_manager_t* manager);
int plugin_unload_all(plugin_manager_t* manager);

// 插件链处理
typedef struct plugin_chain {
    plugin_interface_t** plugins;
    size_t count;
    plugin_type_t type;
} plugin_chain_t;

plugin_chain_t* plugin_chain_create(plugin_type_t type);
void plugin_chain_destroy(plugin_chain_t* chain);
int plugin_chain_add(plugin_chain_t* chain, plugin_interface_t* plugin);
int plugin_chain_process(plugin_chain_t* chain, const void* input, 
                        void** output, size_t* output_size);

#endif // PLUGIN_SYSTEM_H
```

---

## 2. 企业级构建系统实现

### 2.1 CMake高级构建配置

```cmake
# CMakeLists.txt - 企业级项目构建配置
cmake_minimum_required(VERSION 3.16)

# 项目信息
project(EnterpriseWebServer
    VERSION 1.0.0
    DESCRIPTION "Enterprise-grade C Web Server"
    LANGUAGES C CXX
)

# 设置C标准
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)
set(CMAKE_C_EXTENSIONS OFF)

# 构建类型配置
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release)
endif()

# 编译器特定配置
if(CMAKE_C_COMPILER_ID STREQUAL "GNU")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wpedantic")
    set(CMAKE_C_FLAGS_DEBUG "-g -O0 -DDEBUG -fsanitize=address")
    set(CMAKE_C_FLAGS_RELEASE "-O3 -DNDEBUG -march=native")
    set(CMAKE_C_FLAGS_RELWITHDEBINFO "-O2 -g -DNDEBUG")
elseif(CMAKE_C_COMPILER_ID STREQUAL "Clang")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wpedantic")
    set(CMAKE_C_FLAGS_DEBUG "-g -O0 -DDEBUG -fsanitize=address")
    set(CMAKE_C_FLAGS_RELEASE "-O3 -DNDEBUG")
endif()

# 平台特定配置
if(WIN32)
    add_definitions(-D_WIN32_WINNT=0x0601)
    set(PLATFORM_LIBS ws2_32 wsock32)
elseif(UNIX)
    set(PLATFORM_LIBS pthread m dl)
    if(${CMAKE_SYSTEM_NAME} MATCHES "Linux")
        set(PLATFORM_LIBS ${PLATFORM_LIBS} rt)
    endif()
endif()

# 包查找
find_package(PkgConfig REQUIRED)
find_package(Threads REQUIRED)

# 可选依赖
option(ENABLE_SSL "Enable SSL/TLS support" ON)
option(ENABLE_COMPRESSION "Enable compression support" ON)
option(ENABLE_TESTING "Enable testing" ON)
option(ENABLE_BENCHMARKS "Enable benchmarks" OFF)
option(ENABLE_PROFILING "Enable profiling support" OFF)

if(ENABLE_SSL)
    find_package(OpenSSL REQUIRED)
    add_definitions(-DENABLE_SSL)
endif()

if(ENABLE_COMPRESSION)
    find_package(ZLIB REQUIRED)
    add_definitions(-DENABLE_COMPRESSION)
endif()

# 包含目录
include_directories(
    ${CMAKE_SOURCE_DIR}/include
    ${CMAKE_SOURCE_DIR}/src
    ${CMAKE_BINARY_DIR}/generated
)

# 源文件组织
file(GLOB_RECURSE CORE_SOURCES "src/core/*.c")
file(GLOB_RECURSE HTTP_SOURCES "src/http/*.c")
file(GLOB_RECURSE NETWORK_SOURCES "src/network/*.c")
file(GLOB_RECURSE UTILS_SOURCES "src/utils/*.c")

# 核心库
add_library(webserver_core STATIC
    ${CORE_SOURCES}
    ${HTTP_SOURCES}
    ${NETWORK_SOURCES}
    ${UTILS_SOURCES}
)

target_link_libraries(webserver_core
    ${PLATFORM_LIBS}
    Threads::Threads
)

if(ENABLE_SSL)
    target_link_libraries(webserver_core OpenSSL::SSL OpenSSL::Crypto)
endif()

if(ENABLE_COMPRESSION)
    target_link_libraries(webserver_core ZLIB::ZLIB)
endif()

# 主程序
add_executable(webserver src/main.c)
target_link_libraries(webserver webserver_core)

# 插件系统
file(GLOB PLUGIN_SOURCES "src/plugins/*.c")
foreach(PLUGIN_SOURCE ${PLUGIN_SOURCES})
    get_filename_component(PLUGIN_NAME ${PLUGIN_SOURCE} NAME_WE)
    add_library(${PLUGIN_NAME} SHARED ${PLUGIN_SOURCE})
    target_link_libraries(${PLUGIN_NAME} webserver_core)
    set_target_properties(${PLUGIN_NAME} PROPERTIES
        PREFIX ""
        SUFFIX ".so"
    )
endforeach()

# 测试配置
if(ENABLE_TESTING)
    enable_testing()
    add_subdirectory(tests)
endif()

# 基准测试
if(ENABLE_BENCHMARKS)
    add_subdirectory(benchmarks)
endif()

# 安装配置
install(TARGETS webserver
    RUNTIME DESTINATION bin
)

install(TARGETS webserver_core
    ARCHIVE DESTINATION lib
    LIBRARY DESTINATION lib
)

install(DIRECTORY include/
    DESTINATION include
    FILES_MATCHING PATTERN "*.h"
)

# 配置文件生成
configure_file(
    "${CMAKE_SOURCE_DIR}/config/config.h.in"
    "${CMAKE_BINARY_DIR}/generated/config.h"
)

# CPack配置
set(CPACK_PACKAGE_NAME "enterprise-webserver")
set(CPACK_PACKAGE_VERSION ${PROJECT_VERSION})
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY ${PROJECT_DESCRIPTION})
set(CPACK_PACKAGE_VENDOR "Enterprise Solutions Inc.")
set(CPACK_PACKAGE_CONTACT "support@enterprise.com")

if(WIN32)
    set(CPACK_GENERATOR "NSIS")
elseif(UNIX)
    set(CPACK_GENERATOR "DEB;RPM;TGZ")
endif()

include(CPack)
```

### 2.2 包管理与依赖管理

```c
// include/build/package_manager.h
#ifndef PACKAGE_MANAGER_H
#define PACKAGE_MANAGER_H

#include <stdint.h>
#include <stdbool.h>

// 版本信息
typedef struct version {
    uint32_t major;
    uint32_t minor;
    uint32_t patch;
    const char* prerelease;
    const char* build;
} version_t;

// 依赖约束
typedef enum {
    CONSTRAINT_EXACT,      // ==
    CONSTRAINT_GREATER,    // >
    CONSTRAINT_GREATER_EQ, // >=
    CONSTRAINT_LESS,       // <
    CONSTRAINT_LESS_EQ,    // <=
    CONSTRAINT_COMPATIBLE, // ~
    CONSTRAINT_PESSIMISTIC // ^
} constraint_type_t;

typedef struct dependency_constraint {
    constraint_type_t type;
    version_t version;
} dependency_constraint_t;

// 包信息
typedef struct package_info {
    const char* name;
    version_t version;
    const char* description;
    const char* homepage;
    const char* license;
    
    // 依赖关系
    struct {
        const char* name;
        dependency_constraint_t constraint;
    }* dependencies;
    size_t dependency_count;
    
    // 构建信息
    const char* build_system;  // cmake, make, autotools
    const char* build_flags;
    const char** source_files;
    size_t source_file_count;
    
    // 安装信息
    const char* install_prefix;
    const char** headers;
    size_t header_count;
    const char** libraries;
    size_t library_count;
} package_info_t;

// 包管理器
typedef struct package_manager {
    // 包注册表
    package_info_t** packages;
    size_t package_count;
    size_t capacity;
    
    // 安装路径
    const char* install_root;
    const char* cache_dir;
    const char* build_dir;
    
    // 配置
    bool verbose;
    bool force_rebuild;
    int parallel_jobs;
} package_manager_t;

// 依赖解析结果
typedef struct dependency_resolution {
    package_info_t** install_order;
    size_t package_count;
    bool has_conflicts;
    const char* conflict_message;
} dependency_resolution_t;

// API声明
package_manager_t* package_manager_create(const char* install_root);
void package_manager_destroy(package_manager_t* manager);

int package_register(package_manager_t* manager, package_info_t* package);
package_info_t* package_find(package_manager_t* manager, const char* name);

dependency_resolution_t* resolve_dependencies(package_manager_t* manager,
                                            const char** package_names,
                                            size_t count);
void dependency_resolution_destroy(dependency_resolution_t* resolution);

int package_install(package_manager_t* manager, const char* name);
int package_uninstall(package_manager_t* manager, const char* name);
int package_update(package_manager_t* manager, const char* name);

// 版本比较
int version_compare(const version_t* a, const version_t* b);
bool constraint_satisfied(const version_t* version, 
                         const dependency_constraint_t* constraint);

#endif // PACKAGE_MANAGER_H
```

---

## 3. 代码质量工程体系

### 3.1 静态代码分析框架

```c
// include/quality/static_analyzer.h
#ifndef STATIC_ANALYZER_H
#define STATIC_ANALYZER_H

#include <stdint.h>
#include <stdbool.h>

// 分析规则类型
typedef enum {
    RULE_TYPE_SYNTAX,        // 语法检查
    RULE_TYPE_STYLE,         // 代码风格
    RULE_TYPE_SECURITY,      // 安全检查
    RULE_TYPE_PERFORMANCE,   // 性能检查
    RULE_TYPE_MAINTAINABILITY, // 可维护性
    RULE_TYPE_COMPLEXITY,    // 复杂度分析
    RULE_TYPE_COUNT
} rule_type_t;

// 严重级别
typedef enum {
    SEVERITY_INFO = 0,
    SEVERITY_WARNING,
    SEVERITY_ERROR,
    SEVERITY_CRITICAL
} severity_level_t;

// 分析问题
typedef struct analysis_issue {
    rule_type_t type;
    severity_level_t severity;
    const char* rule_id;
    const char* message;
    
    // 位置信息
    const char* file_path;
    uint32_t line_number;
    uint32_t column_number;
    
    // 上下文
    const char* code_snippet;
    const char* suggestion;
    
    // 元数据
    double confidence;  // 0.0 - 1.0
    const char* category;
} analysis_issue_t;

// 分析规则
typedef struct analysis_rule {
    const char* id;
    const char* name;
    const char* description;
    rule_type_t type;
    severity_level_t default_severity;
    
    // 规则实现
    bool (*check)(const char* source_code, const char* file_path,
                  analysis_issue_t** issues, size_t* issue_count);
    
    // 配置
    bool enabled;
    severity_level_t severity;
    void* config_data;
} analysis_rule_t;

// 静态分析器
typedef struct static_analyzer {
    analysis_rule_t** rules;
    size_t rule_count;
    size_t capacity;
    
    // 配置
    bool fail_on_error;
    bool fail_on_warning;
    severity_level_t min_severity;
    
    // 统计信息
    struct {
        size_t files_analyzed;
        size_t lines_analyzed;
        size_t issues_found[SEVERITY_CRITICAL + 1];
        double analysis_time;
    } stats;
} static_analyzer_t;

// 分析结果
typedef struct analysis_result {
    analysis_issue_t** issues;
    size_t issue_count;
    
    // 统计信息
    size_t issues_by_severity[SEVERITY_CRITICAL + 1];
    size_t issues_by_type[RULE_TYPE_COUNT];
    
    // 质量指标
    double code_quality_score;  // 0.0 - 100.0
    double maintainability_index;
    double technical_debt_ratio;
} analysis_result_t;

// API声明
static_analyzer_t* static_analyzer_create(void);
void static_analyzer_destroy(static_analyzer_t* analyzer);

int analyzer_add_rule(static_analyzer_t* analyzer, analysis_rule_t* rule);
int analyzer_remove_rule(static_analyzer_t* analyzer, const char* rule_id);
int analyzer_configure_rule(static_analyzer_t* analyzer, const char* rule_id,
                           severity_level_t severity, bool enabled);

analysis_result_t* analyze_file(static_analyzer_t* analyzer, const char* file_path);
analysis_result_t* analyze_directory(static_analyzer_t* analyzer, const char* dir_path);
void analysis_result_destroy(analysis_result_t* result);

// 报告生成
int generate_report_text(const analysis_result_t* result, const char* output_path);
int generate_report_json(const analysis_result_t* result, const char* output_path);
int generate_report_html(const analysis_result_t* result, const char* output_path);

#endif // STATIC_ANALYZER_H
```

```c
// src/quality/static_analyzer.c
#include "quality/static_analyzer.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

// 内置分析规则实现

// 缓冲区溢出检查
static bool check_buffer_overflow(const char* source_code, const char* file_path,
                                 analysis_issue_t** issues, size_t* issue_count) {
    *issues = NULL;
    *issue_count = 0;
    
    // 简化的缓冲区溢出检查
    const char* dangerous_functions[] = {
        "strcpy", "strcat", "sprintf", "gets", "scanf"
    };
    size_t dangerous_count = sizeof(dangerous_functions) / sizeof(char*);
    
    analysis_issue_t* found_issues = NULL;
    size_t found_count = 0;
    
    for (size_t i = 0; i < dangerous_count; i++) {
        const char* func = dangerous_functions[i];
        const char* pos = source_code;
        uint32_t line = 1;
        
        while ((pos = strstr(pos, func)) != NULL) {
            // 计算行号
            const char* line_start = source_code;
            while (line_start < pos) {
                if (*line_start == '\n') line++;
                line_start++;
            }
            
            // 创建问题记录
            found_issues = realloc(found_issues, 
                sizeof(analysis_issue_t) * (found_count + 1));
            if (!found_issues) return false;
            
            analysis_issue_t* issue = &found_issues[found_count];
            issue->type = RULE_TYPE_SECURITY;
            issue->severity = SEVERITY_WARNING;
            issue->rule_id = "SEC001";
            
            // 分配消息字符串
            char* message = malloc(256);
            snprintf(message, 256, "Potentially unsafe function '%s' detected", func);
            issue->message = message;
            
            issue->file_path = strdup(file_path);
            issue->line_number = line;
            issue->column_number = pos - line_start + 1;
            issue->confidence = 0.8;
            issue->category = "Security";
            
            char* suggestion = malloc(512);
            snprintf(suggestion, 512, 
                "Consider using safer alternatives like strncpy, strncat, snprintf");
            issue->suggestion = suggestion;
            
            found_count++;
            pos += strlen(func);
        }
    }
    
    *issues = found_issues;
    *issue_count = found_count;
    return true;
}

// 复杂度分析
static bool check_cyclomatic_complexity(const char* source_code, const char* file_path,
                                       analysis_issue_t** issues, size_t* issue_count) {
    *issues = NULL;
    *issue_count = 0;
    
    // 简化的圈复杂度计算
    const char* complexity_keywords[] = {
        "if", "else", "while", "for", "switch", "case", "&&", "||", "?"
    };
    size_t keyword_count = sizeof(complexity_keywords) / sizeof(char*);
    
    int complexity = 1;  // 基础复杂度
    const char* pos = source_code;
    
    for (size_t i = 0; i < keyword_count; i++) {
        const char* keyword = complexity_keywords[i];
        pos = source_code;
        
        while ((pos = strstr(pos, keyword)) != NULL) {
            complexity++;
            pos += strlen(keyword);
        }
    }
    
    // 如果复杂度过高，创建问题记录
    if (complexity > 10) {
        analysis_issue_t* issue = malloc(sizeof(analysis_issue_t));
        if (!issue) return false;
        
        issue->type = RULE_TYPE_COMPLEXITY;
        issue->severity = complexity > 20 ? SEVERITY_ERROR : SEVERITY_WARNING;
        issue->rule_id = "COMP001";
        
        char* message = malloc(256);
        snprintf(message, 256, "High cyclomatic complexity: %d", complexity);
        issue->message = message;
        
        issue->file_path = strdup(file_path);
        issue->line_number = 1;
        issue->column_number = 1;
        issue->confidence = 0.9;
        issue->category = "Complexity";
        
        char* suggestion = malloc(256);
        snprintf(suggestion, 256, 
            "Consider refactoring to reduce complexity (target: < 10)");
        issue->suggestion = suggestion;
        
        *issues = issue;
        *issue_count = 1;
    }
    
    return true;
}

// 静态分析器实现
static_analyzer_t* static_analyzer_create(void) {
    static_analyzer_t* analyzer = malloc(sizeof(static_analyzer_t));
    if (!analyzer) return NULL;
    
    analyzer->rules = malloc(sizeof(analysis_rule_t*) * 16);
    if (!analyzer->rules) {
        free(analyzer);
        return NULL;
    }
    
    analyzer->rule_count = 0;
    analyzer->capacity = 16;
    analyzer->fail_on_error = true;
    analyzer->fail_on_warning = false;
    analyzer->min_severity = SEVERITY_INFO;
    
    // 初始化统计信息
    memset(&analyzer->stats, 0, sizeof(analyzer->stats));
    
    // 添加内置规则
    analysis_rule_t* buffer_rule = malloc(sizeof(analysis_rule_t));
    buffer_rule->id = "SEC001";
    buffer_rule->name = "Buffer Overflow Check";
    buffer_rule->description = "Detects potentially unsafe buffer operations";
    buffer_rule->type = RULE_TYPE_SECURITY;
    buffer_rule->default_severity = SEVERITY_WARNING;
    buffer_rule->check = check_buffer_overflow;
    buffer_rule->enabled = true;
    buffer_rule->severity = SEVERITY_WARNING;
    buffer_rule->config_data = NULL;
    
    analyzer_add_rule(analyzer, buffer_rule);
    
    analysis_rule_t* complexity_rule = malloc(sizeof(analysis_rule_t));
    complexity_rule->id = "COMP001";
    complexity_rule->name = "Cyclomatic Complexity";
    complexity_rule->description = "Measures code complexity";
    complexity_rule->type = RULE_TYPE_COMPLEXITY;
    complexity_rule->default_severity = SEVERITY_WARNING;
    complexity_rule->check = check_cyclomatic_complexity;
    complexity_rule->enabled = true;
    complexity_rule->severity = SEVERITY_WARNING;
    complexity_rule->config_data = NULL;
    
    analyzer_add_rule(analyzer, complexity_rule);
    
    return analyzer;
}

int analyzer_add_rule(static_analyzer_t* analyzer, analysis_rule_t* rule) {
    if (!analyzer || !rule) return -1;
    
    // 扩容检查
    if (analyzer->rule_count >= analyzer->capacity) {
        size_t new_capacity = analyzer->capacity * 2;
        analysis_rule_t** new_rules = realloc(analyzer->rules,
            sizeof(analysis_rule_t*) * new_capacity);
        if (!new_rules) return -1;
        
        analyzer->rules = new_rules;
        analyzer->capacity = new_capacity;
    }
    
    analyzer->rules[analyzer->rule_count++] = rule;
    return 0;
}

analysis_result_t* analyze_file(static_analyzer_t* analyzer, const char* file_path) {
    if (!analyzer || !file_path) return NULL;
    
    // 读取文件内容
    FILE* file = fopen(file_path, "r");
    if (!file) return NULL;
    
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    char* source_code = malloc(file_size + 1);
    if (!source_code) {
        fclose(file);
        return NULL;
    }
    
    fread(source_code, 1, file_size, file);
    source_code[file_size] = '\0';
    fclose(file);
    
    // 创建分析结果
    analysis_result_t* result = malloc(sizeof(analysis_result_t));
    if (!result) {
        free(source_code);
        return NULL;
    }
    
    result->issues = NULL;
    result->issue_count = 0;
    memset(result->issues_by_severity, 0, sizeof(result->issues_by_severity));
    memset(result->issues_by_type, 0, sizeof(result->issues_by_type));
    
    // 执行所有启用的规则
    clock_t start_time = clock();
    
    for (size_t i = 0; i < analyzer->rule_count; i++) {
        analysis_rule_t* rule = analyzer->rules[i];
        if (!rule->enabled) continue;
        
        analysis_issue_t* rule_issues = NULL;
        size_t rule_issue_count = 0;
        
        if (rule->check(source_code, file_path, &rule_issues, &rule_issue_count)) {
            // 合并问题
            if (rule_issue_count > 0) {
                result->issues = realloc(result->issues,
                    sizeof(analysis_issue_t*) * (result->issue_count + rule_issue_count));
                
                for (size_t j = 0; j < rule_issue_count; j++) {
                    result->issues[result->issue_count + j] = &rule_issues[j];
                    
                    // 更新统计
                    result->issues_by_severity[rule_issues[j].severity]++;
                    result->issues_by_type[rule_issues[j].type]++;
                }
                
                result->issue_count += rule_issue_count;
            }
        }
    }
    
    clock_t end_time = clock();
    analyzer->stats.analysis_time += ((double)(end_time - start_time)) / CLOCKS_PER_SEC;
    analyzer->stats.files_analyzed++;
    
    // 计算质量指标
    size_t total_issues = result->issue_count;
    size_t critical_issues = result->issues_by_severity[SEVERITY_CRITICAL];
    size_t error_issues = result->issues_by_severity[SEVERITY_ERROR];
    
    // 简化的质量评分算法
    result->code_quality_score = 100.0;
    if (total_issues > 0) {
        result->code_quality_score -= (critical_issues * 20.0 + error_issues * 10.0 + 
                                      (total_issues - critical_issues - error_issues) * 2.0);
        if (result->code_quality_score < 0) result->code_quality_score = 0;
    }
    
    result->maintainability_index = result->code_quality_score;
    result->technical_debt_ratio = (double)total_issues / (file_size / 1000.0);
    
    free(source_code);
    return result;
}

void analysis_result_destroy(analysis_result_t* result) {
    if (!result) return;
    
    // 释放问题记录
    for (size_t i = 0; i < result->issue_count; i++) {
        analysis_issue_t* issue = result->issues[i];
        free((void*)issue->message);
        free((void*)issue->file_path);
        free((void*)issue->suggestion);
        free(issue);
    }
    
    free(result->issues);
    free(result);
}

int generate_report_text(const analysis_result_t* result, const char* output_path) {
    if (!result || !output_path) return -1;
    
    FILE* file = fopen(output_path, "w");
    if (!file) return -1;
    
    fprintf(file, "Static Analysis Report\n");
    fprintf(file, "======================\n\n");
    
    fprintf(file, "Summary:\n");
    fprintf(file, "  Total Issues: %zu\n", result->issue_count);
    fprintf(file, "  Critical: %zu\n", result->issues_by_severity[SEVERITY_CRITICAL]);
    fprintf(file, "  Errors: %zu\n", result->issues_by_severity[SEVERITY_ERROR]);
    fprintf(file, "  Warnings: %zu\n", result->issues_by_severity[SEVERITY_WARNING]);
    fprintf(file, "  Info: %zu\n", result->issues_by_severity[SEVERITY_INFO]);
    fprintf(file, "\n");
    
    fprintf(file, "Quality Metrics:\n");
    fprintf(file, "  Code Quality Score: %.1f/100\n", result->code_quality_score);
    fprintf(file, "  Maintainability Index: %.1f\n", result->maintainability_index);
    fprintf(file, "  Technical Debt Ratio: %.2f\n", result->technical_debt_ratio);
    fprintf(file, "\n");
    
    if (result->issue_count > 0) {
        fprintf(file, "Issues:\n");
        fprintf(file, "-------\n");
        
        for (size_t i = 0; i < result->issue_count; i++) {
            analysis_issue_t* issue = result->issues[i];
            
            const char* severity_str[] = {"INFO", "WARNING", "ERROR", "CRITICAL"};
            fprintf(file, "[%s] %s:%u:%u - %s (%s)\n",
                severity_str[issue->severity],
                issue->file_path,
                issue->line_number,
                issue->column_number,
                issue->message,
                issue->rule_id);
            
            if (issue->suggestion) {
                fprintf(file, "  Suggestion: %s\n", issue->suggestion);
            }
            fprintf(file, "\n");
        }
    }
    
    fclose(file);
    return 0;
}
```

### 3.2 单元测试框架

```c
// include/testing/unit_test.h
#ifndef UNIT_TEST_H
#define UNIT_TEST_H

#include <stdint.h>
#include <stdbool.h>
#include <setjmp.h>

// 测试状态
typedef enum {
    TEST_STATUS_PENDING = 0,
    TEST_STATUS_RUNNING,
    TEST_STATUS_PASSED,
    TEST_STATUS_FAILED,
    TEST_STATUS_SKIPPED,
    TEST_STATUS_ERROR
} test_status_t;

// 断言类型
typedef enum {
    ASSERT_TYPE_EQUAL = 0,
    ASSERT_TYPE_NOT_EQUAL,
    ASSERT_TYPE_TRUE,
    ASSERT_TYPE_FALSE,
    ASSERT_TYPE_NULL,
    ASSERT_TYPE_NOT_NULL,
    ASSERT_TYPE_GREATER,
    ASSERT_TYPE_LESS,
    ASSERT_TYPE_GREATER_EQUAL,
    ASSERT_TYPE_LESS_EQUAL,
    ASSERT_TYPE_STRING_EQUAL,
    ASSERT_TYPE_STRING_NOT_EQUAL,
    ASSERT_TYPE_MEMORY_EQUAL,
    ASSERT_TYPE_FLOAT_EQUAL
} assert_type_t;

// 测试失败信息
typedef struct test_failure {
    assert_type_t assert_type;
    const char* file;
    int line;
    const char* function;
    const char* expression;
    const char* message;
    
    // 期望值和实际值
    union {
        struct { long long expected; long long actual; } integer;
        struct { double expected; double actual; double tolerance; } floating;
        struct { const char* expected; const char* actual; } string;
        struct { const void* expected; const void* actual; size_t size; } memory;
    } values;
} test_failure_t;

// 测试用例
typedef struct test_case {
    const char* name;
    const char* description;
    void (*setup)(void);
    void (*teardown)(void);
    void (*test_function)(void);
    
    // 测试状态
    test_status_t status;
    double execution_time;
    test_failure_t* failure;
    
    // 元数据
    const char* category;
    const char* tags;
    int timeout_ms;
    bool skip;
} test_case_t;

// 测试套件
typedef struct test_suite {
    const char* name;
    const char* description;
    
    test_case_t** test_cases;
    size_t test_count;
    size_t capacity;
    
    // 套件级别的setup/teardown
    void (*suite_setup)(void);
    void (*suite_teardown)(void);
    
    // 统计信息
    size_t passed_count;
    size_t failed_count;
    size_t skipped_count;
    size_t error_count;
    double total_time;
} test_suite_t;

// 测试运行器
typedef struct test_runner {
    test_suite_t** suites;
    size_t suite_count;
    size_t capacity;
    
    // 配置
    bool verbose;
    bool stop_on_failure;
    const char* filter_pattern;
    const char* output_format;  // "text", "xml", "json"
    
    // 全局统计
    size_t total_tests;
    size_t total_passed;
    size_t total_failed;
    size_t total_skipped;
    size_t total_errors;
    double total_execution_time;
} test_runner_t;

// 测试上下文（用于异常处理）
typedef struct test_context {
    jmp_buf jump_buffer;
    test_failure_t* current_failure;
    bool in_test;
} test_context_t;

// 全局测试上下文
extern test_context_t g_test_context;

// API声明
test_runner_t* test_runner_create(void);
void test_runner_destroy(test_runner_t* runner);

test_suite_t* test_suite_create(const char* name, const char* description);
void test_suite_destroy(test_suite_t* suite);

test_case_t* test_case_create(const char* name, void (*test_function)(void));
void test_case_destroy(test_case_t* test_case);

int test_suite_add_case(test_suite_t* suite, test_case_t* test_case);
int test_runner_add_suite(test_runner_t* runner, test_suite_t* suite);

int test_runner_execute(test_runner_t* runner);
int test_runner_generate_report(test_runner_t* runner, const char* output_path);

// 断言宏
#define ASSERT_TRUE(expr) \
    do { \
        if (!(expr)) { \
            test_assert_fail(ASSERT_TYPE_TRUE, __FILE__, __LINE__, __func__, \
                           #expr, "Expected true but got false"); \
        } \
    } while(0)

#define ASSERT_FALSE(expr) \
    do { \
        if (expr) { \
            test_assert_fail(ASSERT_TYPE_FALSE, __FILE__, __LINE__, __func__, \
                           #expr, "Expected false but got true"); \
        } \
    } while(0)

#define ASSERT_EQUAL(expected, actual) \
    do { \
        if ((expected) != (actual)) { \
            test_assert_fail_integer(ASSERT_TYPE_EQUAL, __FILE__, __LINE__, __func__, \
                                   #expected " == " #actual, "Values are not equal", \
                                   (long long)(expected), (long long)(actual)); \
        } \
    } while(0)

#define ASSERT_NOT_EQUAL(expected, actual) \
    do { \
        if ((expected) == (actual)) { \
            test_assert_fail_integer(ASSERT_TYPE_NOT_EQUAL, __FILE__, __LINE__, __func__, \
                                   #expected " != " #actual, "Values are equal", \
                                   (long long)(expected), (long long)(actual)); \
        } \
    } while(0)

#define ASSERT_NULL(ptr) \
    do { \
        if ((ptr) != NULL) { \
            test_assert_fail(ASSERT_TYPE_NULL, __FILE__, __LINE__, __func__, \
                           #ptr, "Expected NULL pointer"); \
        } \
    } while(0)

#define ASSERT_NOT_NULL(ptr) \
    do { \
        if ((ptr) == NULL) { \
            test_assert_fail(ASSERT_TYPE_NOT_NULL, __FILE__, __LINE__, __func__, \
                           #ptr, "Expected non-NULL pointer"); \
        } \
    } while(0)

#define ASSERT_STRING_EQUAL(expected, actual) \
    do { \
        if (strcmp((expected), (actual)) != 0) { \
            test_assert_fail_string(ASSERT_TYPE_STRING_EQUAL, __FILE__, __LINE__, __func__, \
                                  #expected " == " #actual, "Strings are not equal", \
                                  (expected), (actual)); \
        } \
    } while(0)

#define ASSERT_FLOAT_EQUAL(expected, actual, tolerance) \
    do { \
        double diff = fabs((double)(expected) - (double)(actual)); \
        if (diff > (tolerance)) { \
            test_assert_fail_float(ASSERT_TYPE_FLOAT_EQUAL, __FILE__, __LINE__, __func__, \
                                 #expected " ≈ " #actual, "Floating point values differ", \
                                 (double)(expected), (double)(actual), (tolerance)); \
        } \
    } while(0)

// 测试定义宏
#define TEST_CASE(name) \
    void test_##name(void); \
    test_case_t test_case_##name = { \
        .name = #name, \
        .test_function = test_##name, \
        .status = TEST_STATUS_PENDING \
    }; \
    void test_##name(void)

#define TEST_SUITE(name) \
    test_suite_t test_suite_##name = { \
        .name = #name, \
        .test_cases = NULL, \
        .test_count = 0, \
        .capacity = 0 \
    }

// 内部函数
void test_assert_fail(assert_type_t type, const char* file, int line,
                     const char* function, const char* expression,
                     const char* message);
void test_assert_fail_integer(assert_type_t type, const char* file, int line,
                            const char* function, const char* expression,
                            const char* message, long long expected, long long actual);
void test_assert_fail_string(assert_type_t type, const char* file, int line,
                           const char* function, const char* expression,
                           const char* message, const char* expected, const char* actual);
void test_assert_fail_float(assert_type_t type, const char* file, int line,
                          const char* function, const char* expression,
                          const char* message, double expected, double actual, double tolerance);

#endif // UNIT_TEST_H
```

---

## 4. 性能工程与系统监控

### 4.1 性能分析框架

```c
// include/performance/profiler.h
#ifndef PROFILER_H
#define PROFILER_H

#include <stdint.h>
#include <stdbool.h>
#include <time.h>

// 性能计数器类型
typedef enum {
    COUNTER_TYPE_TIME = 0,      // 时间计数
    COUNTER_TYPE_MEMORY,        // 内存使用
    COUNTER_TYPE_CPU,           // CPU使用率
    COUNTER_TYPE_IO,            // I/O操作
    COUNTER_TYPE_NETWORK,       // 网络流量
    COUNTER_TYPE_CUSTOM,        // 自定义计数器
    COUNTER_TYPE_COUNT
} counter_type_t;

// 性能计数器
typedef struct performance_counter {
    const char* name;
    counter_type_t type;
    
    // 统计数据
    uint64_t count;
    uint64_t total_value;
    uint64_t min_value;
    uint64_t max_value;
    double average_value;
    
    // 时间戳
    struct timespec start_time;
    struct timespec last_update;
    
    // 配置
    bool enabled;
    uint64_t sample_interval;  // 采样间隔（微秒）
} performance_counter_t;

// 性能事件
typedef struct performance_event {
    const char* name;
    const char* category;
    counter_type_t type;
    
    struct timespec timestamp;
    uint64_t value;
    
    // 上下文信息
    const char* thread_name;
    uint32_t thread_id;
    const char* function_name;
    const char* file_name;
    uint32_t line_number;
    
    // 自定义数据
    void* custom_data;
    size_t custom_data_size;
} performance_event_t;

// 性能分析器
typedef struct profiler {
    // 计数器管理
    performance_counter_t** counters;
    size_t counter_count;
    size_t counter_capacity;
    
    // 事件缓冲区
    performance_event_t* event_buffer;
    size_t event_buffer_size;
    size_t event_buffer_capacity;
    size_t event_buffer_head;
    
    // 配置
    bool enabled;
    bool real_time_mode;
    uint32_t flush_interval_ms;
    const char* output_file;
    
    // 统计信息
    uint64_t total_events;
    uint64_t dropped_events;
    struct timespec start_time;
    
    // 线程安全
    void* mutex;  // 实际使用时应该是pthread_mutex_t*
} profiler_t;

// 性能报告
typedef struct performance_report {
    // 时间范围
    struct timespec start_time;
    struct timespec end_time;
    double duration_seconds;
    
    // 计数器摘要
    struct {
        const char* name;
        counter_type_t type;
        uint64_t count;
        double average;
        uint64_t min;
        uint64_t max;
        double std_deviation;
    }* counter_summaries;
    size_t counter_count;
    
    // 热点分析
    struct {
        const char* function_name;
        const char* file_name;
        uint64_t call_count;
        double total_time;
        double average_time;
        double percentage;
    }* hotspots;
    size_t hotspot_count;
    
    // 内存分析
    struct {
        uint64_t peak_usage;
        uint64_t total_allocated;
        uint64_t total_freed;
        uint64_t current_usage;
        uint32_t allocation_count;
        uint32_t free_count;
        uint32_t leak_count;
    } memory_stats;
    
    // 性能建议
    struct {
        const char* category;
        const char* description;
        const char* suggestion;
        int priority;  // 1-10, 10最高
    }* recommendations;
    size_t recommendation_count;
} performance_report_t;

// API声明
profiler_t* profiler_create(void);
void profiler_destroy(profiler_t* profiler);

int profiler_start(profiler_t* profiler);
int profiler_stop(profiler_t* profiler);
int profiler_reset(profiler_t* profiler);

performance_counter_t* profiler_create_counter(profiler_t* profiler,
                                             const char* name,
                                             counter_type_t type);
int profiler_update_counter(profiler_t* profiler, const char* name, uint64_t value);
int profiler_increment_counter(profiler_t* profiler, const char* name);

int profiler_record_event(profiler_t* profiler, const performance_event_t* event);
int profiler_flush_events(profiler_t* profiler);

performance_report_t* profiler_generate_report(profiler_t* profiler);
void performance_report_destroy(performance_report_t* report);

int profiler_export_report(const performance_report_t* report, 
                          const char* format, const char* output_path);

// 便利宏
#define PROFILE_FUNCTION_START(profiler, func_name) \
    do { \
        performance_event_t event = { \
            .name = func_name "_start", \
            .category = "function", \
            .type = COUNTER_TYPE_TIME, \
            .function_name = __func__, \
            .file_name = __FILE__, \
            .line_number = __LINE__ \
        }; \
        clock_gettime(CLOCK_MONOTONIC, &event.timestamp); \
        profiler_record_event(profiler, &event); \
    } while(0)

#define PROFILE_FUNCTION_END(profiler, func_name) \
    do { \
        performance_event_t event = { \
            .name = func_name "_end", \
            .category = "function", \
            .type = COUNTER_TYPE_TIME, \
            .function_name = __func__, \
            .file_name = __FILE__, \
            .line_number = __LINE__ \
        }; \
        clock_gettime(CLOCK_MONOTONIC, &event.timestamp); \
        profiler_record_event(profiler, &event); \
    } while(0)

#define PROFILE_MEMORY_ALLOC(profiler, size) \
    do { \
        performance_event_t event = { \
            .name = "memory_alloc", \
            .category = "memory", \
            .type = COUNTER_TYPE_MEMORY, \
            .value = size, \
            .function_name = __func__, \
            .file_name = __FILE__, \
            .line_number = __LINE__ \
        }; \
        clock_gettime(CLOCK_MONOTONIC, &event.timestamp); \
        profiler_record_event(profiler, &event); \
    } while(0)

#define PROFILE_MEMORY_FREE(profiler, size) \
    do { \
        performance_event_t event = { \
            .name = "memory_free", \
            .category = "memory", \
            .type = COUNTER_TYPE_MEMORY, \
            .value = size, \
            .function_name = __func__, \
            .file_name = __FILE__, \
            .line_number = __LINE__ \
        }; \
        clock_gettime(CLOCK_MONOTONIC, &event.timestamp); \
        profiler_record_event(profiler, &event); \
    } while(0)

// 自动性能分析（RAII风格）
typedef struct auto_profiler {
    profiler_t* profiler;
    const char* name;
    struct timespec start_time;
} auto_profiler_t;

#define AUTO_PROFILE(profiler, name) \
    auto_profiler_t __auto_prof_##__LINE__ = { \
        .profiler = profiler, \
        .name = name \
    }; \
    clock_gettime(CLOCK_MONOTONIC, &__auto_prof_##__LINE__.start_time); \
    __attribute__((cleanup(auto_profiler_cleanup))) auto_profiler_t* __auto_prof_ptr_##__LINE__ = &__auto_prof_##__LINE__

void auto_profiler_cleanup(auto_profiler_t** profiler);

#endif // PROFILER_H
```

### 4.2 系统监控实现

```c
// include/monitoring/system_monitor.h
#ifndef SYSTEM_MONITOR_H
#define SYSTEM_MONITOR_H

#include <stdint.h>
#include <stdbool.h>
#include <time.h>

// 系统资源类型
typedef enum {
    RESOURCE_TYPE_CPU = 0,
    RESOURCE_TYPE_MEMORY,
    RESOURCE_TYPE_DISK,
    RESOURCE_TYPE_NETWORK,
    RESOURCE_TYPE_PROCESS,
    RESOURCE_TYPE_THREAD,
    RESOURCE_TYPE_COUNT
} resource_type_t;

// CPU信息
typedef struct cpu_info {
    uint32_t core_count;
    double usage_percent;
    double load_average[3];  // 1分钟、5分钟、15分钟负载
    uint64_t user_time;
    uint64_t system_time;
    uint64_t idle_time;
    uint64_t iowait_time;
} cpu_info_t;

// 内存信息
typedef struct memory_info {
    uint64_t total_memory;
    uint64_t available_memory;
    uint64_t used_memory;
    uint64_t free_memory;
    uint64_t cached_memory;
    uint64_t buffer_memory;
    double usage_percent;
    uint64_t swap_total;
    uint64_t swap_used;
    uint64_t swap_free;
} memory_info_t;

// 磁盘信息
typedef struct disk_info {
    char device_name[64];
    char mount_point[256];
    char filesystem_type[32];
    uint64_t total_space;
    uint64_t available_space;
    uint64_t used_space;
    double usage_percent;
    uint64_t read_bytes;
    uint64_t write_bytes;
    uint32_t read_operations;
    uint32_t write_operations;
} disk_info_t;

// 网络信息
typedef struct network_info {
    char interface_name[32];
    uint64_t bytes_received;
    uint64_t bytes_sent;
    uint64_t packets_received;
    uint64_t packets_sent;
    uint32_t errors_received;
    uint32_t errors_sent;
    uint32_t drops_received;
    uint32_t drops_sent;
    bool is_up;
    uint32_t speed_mbps;
} network_info_t;

// 进程信息
typedef struct process_info {
    uint32_t pid;
    uint32_t ppid;
    char name[256];
    char state;
    uint64_t memory_usage;
    double cpu_usage;
    uint64_t start_time;
    uint32_t thread_count;
    uint32_t priority;
    uint32_t nice_value;
} process_info_t;

// 系统监控器
typedef struct system_monitor {
    bool is_running;
    uint32_t update_interval_ms;
    
    // 资源信息
    cpu_info_t cpu_info;
    memory_info_t memory_info;
    disk_info_t* disk_info;
    size_t disk_count;
    network_info_t* network_info;
    size_t network_count;
    process_info_t* process_info;
    size_t process_count;
    
    // 历史数据
    struct {
        double* cpu_history;
        double* memory_history;
        size_t history_size;
        size_t history_index;
    } history;
    
    // 回调函数
    void (*on_resource_update)(resource_type_t type, void* data);
    void (*on_threshold_exceeded)(resource_type_t type, double value, double threshold);
} system_monitor_t;

// 系统监控API
system_monitor_t* system_monitor_create(uint32_t update_interval_ms);
void system_monitor_destroy(system_monitor_t* monitor);

bool system_monitor_start(system_monitor_t* monitor);
void system_monitor_stop(system_monitor_t* monitor);

bool system_monitor_update(system_monitor_t* monitor);
bool system_monitor_get_cpu_info(system_monitor_t* monitor, cpu_info_t* info);
bool system_monitor_get_memory_info(system_monitor_t* monitor, memory_info_t* info);
bool system_monitor_get_disk_info(system_monitor_t* monitor, disk_info_t** info, size_t* count);
bool system_monitor_get_network_info(system_monitor_t* monitor, network_info_t** info, size_t* count);
bool system_monitor_get_process_info(system_monitor_t* monitor, process_info_t** info, size_t* count);

// 阈值监控
typedef struct threshold_config {
    resource_type_t resource_type;
    double warning_threshold;
    double critical_threshold;
    bool enabled;
} threshold_config_t;

bool system_monitor_set_threshold(system_monitor_t* monitor, const threshold_config_t* config);
bool system_monitor_check_thresholds(system_monitor_t* monitor);

#endif // SYSTEM_MONITOR_H
```

## 5. 实际项目：企业级项目管理系统

### 5.1 项目架构设计

```c
// include/project/project_manager.h
#ifndef PROJECT_MANAGER_H
#define PROJECT_MANAGER_H

#include "core/architecture.h"
#include "build/cmake_generator.h"
#include "quality/static_analyzer.h"
#include "quality/unit_test.h"
#include "performance/profiler.h"
#include "monitoring/system_monitor.h"

// 项目类型
typedef enum {
    PROJECT_TYPE_EXECUTABLE = 0,
    PROJECT_TYPE_STATIC_LIBRARY,
    PROJECT_TYPE_SHARED_LIBRARY,
    PROJECT_TYPE_HEADER_ONLY,
    PROJECT_TYPE_PLUGIN,
    PROJECT_TYPE_COUNT
} project_type_t;

// 项目配置
typedef struct project_config {
    char name[128];
    char version[32];
    char description[512];
    char author[128];
    char license[64];
    project_type_t type;
    
    // 构建配置
    char build_system[32];  // cmake, make, ninja等
    char compiler[32];      // gcc, clang, msvc等
    char c_standard[8];     // c99, c11, c17, c23等
    
    // 依赖管理
    dependency_t* dependencies;
    size_t dependency_count;
    
    // 质量配置
    bool enable_static_analysis;
    bool enable_unit_tests;
    bool enable_performance_profiling;
    bool enable_system_monitoring;
    
    // 路径配置
    char source_dir[256];
    char include_dir[256];
    char build_dir[256];
    char test_dir[256];
    char docs_dir[256];
} project_config_t;

// 项目管理器
typedef struct project_manager {
    project_config_t config;
    architecture_t* architecture;
    cmake_generator_t* cmake_generator;
    static_analyzer_t* analyzer;
    test_framework_t* test_framework;
    profiler_t* profiler;
    system_monitor_t* monitor;
    
    // 项目状态
    bool is_initialized;
    bool is_configured;
    bool is_built;
    
    // 统计信息
    struct {
        size_t source_file_count;
        size_t header_file_count;
        size_t test_file_count;
        size_t total_lines;
        size_t code_lines;
        size_t comment_lines;
        size_t blank_lines;
    } statistics;
} project_manager_t;

// 项目管理API
project_manager_t* project_manager_create(const project_config_t* config);
void project_manager_destroy(project_manager_t* manager);

// 项目生命周期管理
bool project_manager_initialize(project_manager_t* manager);
bool project_manager_configure(project_manager_t* manager);
bool project_manager_build(project_manager_t* manager);
bool project_manager_test(project_manager_t* manager);
bool project_manager_install(project_manager_t* manager);
bool project_manager_package(project_manager_t* manager);
bool project_manager_clean(project_manager_t* manager);

// 代码质量管理
bool project_manager_analyze_code(project_manager_t* manager);
bool project_manager_run_tests(project_manager_t* manager);
bool project_manager_profile_performance(project_manager_t* manager);
bool project_manager_monitor_system(project_manager_t* manager);

// 项目统计和报告
bool project_manager_update_statistics(project_manager_t* manager);
bool project_manager_generate_report(project_manager_t* manager, const char* output_path);

#endif // PROJECT_MANAGER_H
```

### 5.2 完整实现示例

```c
// src/project/project_manager.c
#include "project/project_manager.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <sys/stat.h>
#include <dirent.h>

// 创建项目管理器
project_manager_t* project_manager_create(const project_config_t* config) {
    if (!config) return NULL;
    
    project_manager_t* manager = calloc(1, sizeof(project_manager_t));
    if (!manager) return NULL;
    
    // 复制配置
    memcpy(&manager->config, config, sizeof(project_config_t));
    
    // 创建子系统
    manager->architecture = architecture_create();
    manager->cmake_generator = cmake_generator_create();
    manager->analyzer = static_analyzer_create();
    manager->test_framework = test_framework_create();
    manager->profiler = profiler_create();
    manager->monitor = system_monitor_create(1000);  // 1秒更新间隔
    
    if (!manager->architecture || !manager->cmake_generator || 
        !manager->analyzer || !manager->test_framework || 
        !manager->profiler || !manager->monitor) {
        project_manager_destroy(manager);
        return NULL;
    }
    
    return manager;
}

// 销毁项目管理器
void project_manager_destroy(project_manager_t* manager) {
    if (!manager) return;
    
    architecture_destroy(manager->architecture);
    cmake_generator_destroy(manager->cmake_generator);
    static_analyzer_destroy(manager->analyzer);
    test_framework_destroy(manager->test_framework);
    profiler_destroy(manager->profiler);
    system_monitor_destroy(manager->monitor);
    
    free(manager);
}

// 初始化项目
bool project_manager_initialize(project_manager_t* manager) {
    if (!manager || manager->is_initialized) return false;
    
    // 创建项目目录结构
    const char* directories[] = {
        manager->config.source_dir,
        manager->config.include_dir,
        manager->config.build_dir,
        manager->config.test_dir,
        manager->config.docs_dir
    };
    
    for (size_t i = 0; i < sizeof(directories) / sizeof(char*); i++) {
        struct stat st = {0};
        if (stat(directories[i], &st) == -1) {
            if (mkdir(directories[i], 0755) != 0) {
                return false;
            }
        }
    }
    
    // 初始化架构
    if (!architecture_initialize(manager->architecture)) {
        return false;
    }
    
    // 生成初始CMakeLists.txt
    cmake_config_t cmake_config = {
        .project_name = manager->config.name,
        .version = manager->config.version,
        .c_standard = manager->config.c_standard,
        .build_type = "Debug"
    };
    
    if (!cmake_generator_generate(manager->cmake_generator, &cmake_config, "CMakeLists.txt")) {
        return false;
    }
    
    manager->is_initialized = true;
    return true;
}

// 配置项目
bool project_manager_configure(project_manager_t* manager) {
    if (!manager || !manager->is_initialized || manager->is_configured) {
        return false;
    }
    
    // 配置依赖管理
    for (size_t i = 0; i < manager->config.dependency_count; i++) {
        dependency_t* dep = &manager->config.dependencies[i];
        if (!dependency_manager_resolve(NULL, dep)) {
            printf("Failed to resolve dependency: %s\n", dep->name);
            return false;
        }
    }
    
    // 配置静态分析
    if (manager->config.enable_static_analysis) {
        analysis_config_t analysis_config = {
            .enable_security_checks = true,
            .enable_performance_checks = true,
            .enable_style_checks = true,
            .max_complexity = 10,
            .max_function_length = 50
        };
        
        if (!static_analyzer_configure(manager->analyzer, &analysis_config)) {
            return false;
        }
    }
    
    // 配置测试框架
    if (manager->config.enable_unit_tests) {
        test_config_t test_config = {
            .test_directory = manager->config.test_dir,
            .output_format = TEST_OUTPUT_XML,
            .enable_coverage = true,
            .timeout_seconds = 30
        };
        
        if (!test_framework_configure(manager->test_framework, &test_config)) {
            return false;
        }
    }
    
    manager->is_configured = true;
    return true;
}

// 构建项目
bool project_manager_build(project_manager_t* manager) {
    if (!manager || !manager->is_configured) return false;
    
    // 启动性能监控
    if (manager->config.enable_performance_profiling) {
        profiler_start(manager->profiler);
    }
    
    // 启动系统监控
    if (manager->config.enable_system_monitoring) {
        system_monitor_start(manager->monitor);
    }
    
    // 执行构建命令
    char build_command[512];
    snprintf(build_command, sizeof(build_command), 
        "cd %s && cmake .. && make -j$(nproc)", 
        manager->config.build_dir);
    
    int result = system(build_command);
    
    // 停止监控
    if (manager->config.enable_performance_profiling) {
        profiler_stop(manager->profiler);
    }
    
    if (manager->config.enable_system_monitoring) {
        system_monitor_stop(manager->monitor);
    }
    
    if (result == 0) {
        manager->is_built = true;
        project_manager_update_statistics(manager);
        return true;
    }
    
    return false;
}

// 运行测试
bool project_manager_test(project_manager_t* manager) {
    if (!manager || !manager->is_built || !manager->config.enable_unit_tests) {
        return false;
    }
    
    // 运行所有测试
    test_result_t result;
    if (!test_framework_run_all(manager->test_framework, &result)) {
        return false;
    }
    
    // 输出测试结果
    printf("Test Results:\n");
    printf("  Total: %zu\n", result.total_tests);
    printf("  Passed: %zu\n", result.passed_tests);
    printf("  Failed: %zu\n", result.failed_tests);
    printf("  Skipped: %zu\n", result.skipped_tests);
    printf("  Success Rate: %.2f%%\n", 
        (double)result.passed_tests / result.total_tests * 100.0);
    
    return result.failed_tests == 0;
}

// 更新项目统计信息
bool project_manager_update_statistics(project_manager_t* manager) {
    if (!manager) return false;
    
    // 重置统计信息
    memset(&manager->statistics, 0, sizeof(manager->statistics));
    
    // 统计源文件
    DIR* source_dir = opendir(manager->config.source_dir);
    if (source_dir) {
        struct dirent* entry;
        while ((entry = readdir(source_dir)) != NULL) {
            if (strstr(entry->d_name, ".c")) {
                manager->statistics.source_file_count++;
            }
        }
        closedir(source_dir);
    }
    
    // 统计头文件
    DIR* include_dir = opendir(manager->config.include_dir);
    if (include_dir) {
        struct dirent* entry;
        while ((entry = readdir(include_dir)) != NULL) {
            if (strstr(entry->d_name, ".h")) {
                manager->statistics.header_file_count++;
            }
        }
        closedir(include_dir);
    }
    
    // 统计测试文件
    DIR* test_dir = opendir(manager->config.test_dir);
    if (test_dir) {
        struct dirent* entry;
        while ((entry = readdir(test_dir)) != NULL) {
            if (strstr(entry->d_name, "test_") && strstr(entry->d_name, ".c")) {
                manager->statistics.test_file_count++;
            }
        }
        closedir(test_dir);
    }
    
    return true;
}

// 生成项目报告
bool project_manager_generate_report(project_manager_t* manager, const char* output_path) {
    if (!manager || !output_path) return false;
    
    FILE* report = fopen(output_path, "w");
    if (!report) return false;
    
    // 生成HTML报告
    fprintf(report, "<!DOCTYPE html>\n");
    fprintf(report, "<html><head><title>Project Report: %s</title></head><body>\n", 
        manager->config.name);
    
    // 项目基本信息
    fprintf(report, "<h1>Project: %s</h1>\n", manager->config.name);
    fprintf(report, "<p>Version: %s</p>\n", manager->config.version);
    fprintf(report, "<p>Description: %s</p>\n", manager->config.description);
    fprintf(report, "<p>Author: %s</p>\n", manager->config.author);
    fprintf(report, "<p>License: %s</p>\n", manager->config.license);
    
    // 统计信息
    fprintf(report, "<h2>Statistics</h2>\n");
    fprintf(report, "<ul>\n");
    fprintf(report, "<li>Source Files: %zu</li>\n", manager->statistics.source_file_count);
    fprintf(report, "<li>Header Files: %zu</li>\n", manager->statistics.header_file_count);
    fprintf(report, "<li>Test Files: %zu</li>\n", manager->statistics.test_file_count);
    fprintf(report, "<li>Total Lines: %zu</li>\n", manager->statistics.total_lines);
    fprintf(report, "<li>Code Lines: %zu</li>\n", manager->statistics.code_lines);
    fprintf(report, "</ul>\n");
    
    // 构建状态
    fprintf(report, "<h2>Build Status</h2>\n");
    fprintf(report, "<p>Initialized: %s</p>\n", manager->is_initialized ? "Yes" : "No");
    fprintf(report, "<p>Configured: %s</p>\n", manager->is_configured ? "Yes" : "No");
    fprintf(report, "<p>Built: %s</p>\n", manager->is_built ? "Yes" : "No");
    
    // 质量报告
    if (manager->config.enable_static_analysis) {
        fprintf(report, "<h2>Code Quality</h2>\n");
        
        analysis_result_t analysis_result;
        if (static_analyzer_get_results(manager->analyzer, &analysis_result)) {
            fprintf(report, "<p>Total Issues: %zu</p>\n", analysis_result.total_issues);
            fprintf(report, "<p>Critical Issues: %zu</p>\n", analysis_result.critical_issues);
            fprintf(report, "<p>Warning Issues: %zu</p>\n", analysis_result.warning_issues);
            fprintf(report, "<p>Info Issues: %zu</p>\n", analysis_result.info_issues);
        }
    }
    
    fprintf(report, "</body></html>\n");
    fclose(report);
    
    return true;
}
```

## 6. 主函数和综合演示

```c
// main.c - 企业级项目管理系统演示
#include "project/project_manager.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char* argv[]) {
    printf("=== 企业级C语言项目管理系统演示 ===\n\n");
    
    // 1. 创建项目配置
    project_config_t config = {
        .name = "MyProject",
        .version = "1.0.0",
        .description = "A sample C project demonstrating enterprise-level practices",
        .author = "Development Team",
        .license = "MIT",
        .type = PROJECT_TYPE_EXECUTABLE,
        .build_system = "cmake",
        .compiler = "gcc",
        .c_standard = "c17",
        .enable_static_analysis = true,
        .enable_unit_tests = true,
        .enable_performance_profiling = true,
        .enable_system_monitoring = true,
        .source_dir = "./src",
        .include_dir = "./include",
        .build_dir = "./build",
        .test_dir = "./tests",
        .docs_dir = "./docs"
    };
    
    // 2. 创建项目管理器
    printf("1. 创建项目管理器...\n");
    project_manager_t* manager = project_manager_create(&config);
    if (!manager) {
        fprintf(stderr, "Failed to create project manager\n");
        return EXIT_FAILURE;
    }
    printf("   ✓ 项目管理器创建成功\n\n");
    
    // 3. 初始化项目
    printf("2. 初始化项目结构...\n");
    if (!project_manager_initialize(manager)) {
        fprintf(stderr, "Failed to initialize project\n");
        project_manager_destroy(manager);
        return EXIT_FAILURE;
    }
    printf("   ✓ 项目目录结构创建完成\n");
    printf("   ✓ CMakeLists.txt生成完成\n\n");
    
    // 4. 配置项目
    printf("3. 配置项目环境...\n");
    if (!project_manager_configure(manager)) {
        fprintf(stderr, "Failed to configure project\n");
        project_manager_destroy(manager);
        return EXIT_FAILURE;
    }
    printf("   ✓ 依赖管理配置完成\n");
    printf("   ✓ 静态分析配置完成\n");
    printf("   ✓ 测试框架配置完成\n\n");
    
    // 5. 代码质量分析演示
    printf("4. 执行代码质量分析...\n");
    if (project_manager_analyze_code(manager)) {
        printf("   ✓ 静态代码分析完成\n");
        
        analysis_result_t result;
        if (static_analyzer_get_results(manager->analyzer, &result)) {
            printf("   - 发现问题总数: %zu\n", result.total_issues);
            printf("   - 严重问题: %zu\n", result.critical_issues);
            printf("   - 警告问题: %zu\n", result.warning_issues);
            printf("   - 信息问题: %zu\n", result.info_issues);
        }
    }
    printf("\n");
    
    // 6. 性能分析演示
    printf("5. 性能分析演示...\n");
    if (manager->config.enable_performance_profiling) {
        profiler_start(manager->profiler);
        
        // 模拟一些性能测试
        PROFILE_FUNCTION_ENTRY(manager->profiler, "demo_function");
        
        // 模拟计算密集型操作
        volatile long sum = 0;
        for (int i = 0; i < 1000000; i++) {
            sum += i * i;
        }
        
        PROFILE_FUNCTION_EXIT(manager->profiler, "demo_function");
        
        // 模拟内存分配
        void* ptr = malloc(1024);
        PROFILE_MEMORY_ALLOC(manager->profiler, 1024);
        free(ptr);
        PROFILE_MEMORY_FREE(manager->profiler, 1024);
        
        profiler_stop(manager->profiler);
        
        // 生成性能报告
        if (profiler_generate_report(manager->profiler, "./performance_report.json")) {
            printf("   ✓ 性能分析完成，报告已生成\n");
        }
    }
    printf("\n");
    
    // 7. 系统监控演示
    printf("6. 系统资源监控...\n");
    if (manager->config.enable_system_monitoring) {
        system_monitor_start(manager->monitor);
        
        // 获取系统信息
        cpu_info_t cpu_info;
        memory_info_t memory_info;
        
        if (system_monitor_get_cpu_info(manager->monitor, &cpu_info)) {
            printf("   - CPU核心数: %u\n", cpu_info.core_count);
            printf("   - CPU使用率: %.2f%%\n", cpu_info.usage_percent);
        }
        
        if (system_monitor_get_memory_info(manager->monitor, &memory_info)) {
            printf("   - 总内存: %.2f GB\n", memory_info.total_memory / (1024.0 * 1024.0 * 1024.0));
            printf("   - 可用内存: %.2f GB\n", memory_info.available_memory / (1024.0 * 1024.0 * 1024.0));
            printf("   - 内存使用率: %.2f%%\n", memory_info.usage_percent);
        }
        
        system_monitor_stop(manager->monitor);
    }
    printf("\n");
    
    // 8. 更新项目统计
    printf("7. 更新项目统计信息...\n");
    if (project_manager_update_statistics(manager)) {
        printf("   - 源文件数量: %zu\n", manager->statistics.source_file_count);
        printf("   - 头文件数量: %zu\n", manager->statistics.header_file_count);
        printf("   - 测试文件数量: %zu\n", manager->statistics.test_file_count);
        printf("   ✓ 统计信息更新完成\n");
    }
    printf("\n");
    
    // 9. 生成项目报告
    printf("8. 生成项目报告...\n");
    if (project_manager_generate_report(manager, "./project_report.html")) {
        printf("   ✓ 项目报告已生成: ./project_report.html\n");
    }
    printf("\n");
    
    // 10. 清理资源
    printf("9. 清理资源...\n");
    project_manager_destroy(manager);
    printf("   ✓ 资源清理完成\n\n");
    
    printf("=== 企业级项目管理系统演示完成 ===\n");
    printf("本演示展示了以下核心功能：\n");
    printf("• 模块化架构设计和依赖管理\n");
    printf("• 自动化构建系统（CMake）\n");
    printf("• 静态代码分析和质量检查\n");
    printf("• 单元测试框架集成\n");
    printf("• 性能分析和优化工具\n");
    printf("• 系统资源监控\n");
    printf("• 项目统计和报告生成\n");
    printf("• 企业级项目管理流程\n\n");
    
    return EXIT_SUCCESS;
}
```

## 7. 总结

### 7.1 核心知识点回顾

本章深入探讨了C语言工程实践与软件工程的核心内容：

**1. 现代项目架构设计**
- 分层架构和组件化设计
- 依赖注入和控制反转
- 插件系统和模块化开发
- 接口设计和抽象层

**2. 企业级构建系统**
- CMake高级配置和跨平台构建
- 包管理和依赖解析
- 自动化构建流程
- 版本控制和发布管理

**3. 代码质量工程**
- 静态代码分析框架
- 单元测试和集成测试
- 代码覆盖率和质量度量
- 持续集成和持续部署

**4. 性能工程和监控**
- 性能分析和性能调优
- 系统资源监控
- 性能基准测试
- 实时监控和告警系统

### 7.2 实践项目价值

通过企业级项目管理系统的实现，我们学习了：

- **工程化思维**：如何将软件工程理论应用到C语言项目中
- **系统性设计**：如何设计可扩展、可维护的大型系统
- **质量保证**：如何建立完整的质量保证体系
- **性能优化**：如何进行系统性的性能分析和优化
- **项目管理**：如何管理复杂的C语言项目

### 7.3 学习建议

**进阶学习方向：**

1. **深入学习软件架构**
   - 微服务架构在C语言中的应用
   - 事件驱动架构和响应式编程
   - 领域驱动设计（DDD）

2. **掌握DevOps实践**
   - 容器化部署（Docker）
   - 自动化测试和部署
   - 监控和日志系统

3. **性能工程专精**
   - 高性能计算优化
   - 并发和并行编程
   - 系统调优和性能分析

4. **开源项目贡献**
   - 参与知名开源C项目
   - 学习优秀项目的工程实践
   - 建立个人技术影响力

通过本章的学习，你已经掌握了C语言企业级开发的核心技能，能够设计和实现高质量、高性能的系统级应用。继续实践和深入学习，你将成为优秀的系统软件工程师。
