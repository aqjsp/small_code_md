# C语言数据类型与变量详解

## 学习目标

通过本章学习，你将掌握：
- C语言基本数据类型的特点和使用方法
- 变量的声明、初始化和作用域规则
- 类型转换的机制和最佳实践
- 常量定义和使用的规范方法
- 变量生命周期和内存管理基础

## 1. 现代C类型系统深度解析

### 1.1 类型系统设计哲学

C语言采用**静态强类型系统**，体现了系统编程语言的核心设计理念：

```c
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <assert.h>

// 类型安全的设计模式
typedef struct {
    uint32_t id;
    bool is_valid;
    char name[32];
} user_t;

// 类型安全的构造函数
user_t create_user(uint32_t id, const char* name) {
    assert(name != NULL);
    user_t user = {
        .id = id,
        .is_valid = true,
        .name = {0}  // 零初始化
    };
    
    // 安全的字符串复制
    size_t name_len = strlen(name);
    if (name_len < sizeof(user.name)) {
        memcpy(user.name, name, name_len);
    }
    
    return user;
}

void type_system_philosophy_demo(void) {
    // 编译时类型检查
    user_t alice = create_user(1001, "Alice");
    
    // 类型安全的操作
    printf("用户信息: ID=%u, 姓名=%s, 有效=%s\n",
           alice.id, alice.name, alice.is_valid ? "是" : "否");
    
    // 静态断言 - 编译时检查
    _Static_assert(sizeof(user_t) <= 64, "用户结构体过大");
    
    printf("类型系统特性:\n");
    printf("  - 编译时类型检查: 防止类型错误\n");
    printf("  - 零成本抽象: 运行时无额外开销\n");
    printf("  - 内存透明: 直接映射硬件特性\n");
}
```

### 1.2 内存模型与数据表示

深入理解数据在内存中的存储方式，是编写高效程序的关键：

```c
#include <stdint.h>
#include <string.h>

// 内存布局分析工具
typedef union {
    uint32_t as_uint32;
    uint16_t as_uint16[2];
    uint8_t  as_bytes[4];
    struct {
        uint8_t byte0, byte1, byte2, byte3;
    } as_struct;
} memory_view_t;

void memory_layout_analysis(void) {
    memory_view_t data = { .as_uint32 = 0x12345678 };
    
    printf("内存布局分析 (值: 0x%08X):\n", data.as_uint32);
    printf("  按字节访问: [0x%02X, 0x%02X, 0x%02X, 0x%02X]\n",
           data.as_bytes[0], data.as_bytes[1], 
           data.as_bytes[2], data.as_bytes[3]);
    
    printf("  按16位访问: [0x%04X, 0x%04X]\n",
           data.as_uint16[0], data.as_uint16[1]);
    
    printf("  结构体访问: {%02X, %02X, %02X, %02X}\n",
           data.as_struct.byte0, data.as_struct.byte1,
           data.as_struct.byte2, data.as_struct.byte3);
    
    // 字节序检测
    const char* endianness = (data.as_bytes[0] == 0x78) ? "小端序" : "大端序";
    printf("  系统字节序: %s\n", endianness);
    
    // 对齐分析
    struct alignment_test {
        char c;      // 1字节
        int i;       // 4字节，可能有填充
        double d;    // 8字节，可能有填充
    };
    
    printf("\n内存对齐分析:\n");
    printf("  char偏移: %zu, int偏移: %zu, double偏移: %zu\n",
           offsetof(struct alignment_test, c),
           offsetof(struct alignment_test, i),
           offsetof(struct alignment_test, d));
    printf("  结构体总大小: %zu字节\n", sizeof(struct alignment_test));
}
```

### 1.3 类型安全编程模式

```c
#include <errno.h>
#include <limits.h>

// 类型安全的错误处理
typedef enum {
    RESULT_OK = 0,
    RESULT_OVERFLOW,
    RESULT_UNDERFLOW,
    RESULT_INVALID_INPUT
} result_code_t;

typedef struct {
    result_code_t code;
    int32_t value;
} safe_int_result_t;

// 安全的加法操作
safe_int_result_t safe_add_int32(int32_t a, int32_t b) {
    safe_int_result_t result = {RESULT_OK, 0};
    
    // 溢出检查
    if (a > 0 && b > INT32_MAX - a) {
        result.code = RESULT_OVERFLOW;
        return result;
    }
    if (a < 0 && b < INT32_MIN - a) {
        result.code = RESULT_UNDERFLOW;
        return result;
    }
    
    result.value = a + b;
    return result;
}

void type_safe_programming_demo(void) {
    printf("类型安全编程示例:\n");
    
    // 测试正常情况
    safe_int_result_t r1 = safe_add_int32(100, 200);
    if (r1.code == RESULT_OK) {
        printf("  100 + 200 = %d\n", r1.value);
    }
    
    // 测试溢出情况
    safe_int_result_t r2 = safe_add_int32(INT32_MAX, 1);
    if (r2.code == RESULT_OVERFLOW) {
        printf("  检测到整数溢出\n");
    }
    
    // 类型安全的字符串处理
    char buffer[16];
    const char* source = "Hello, World!";
    
    if (strlen(source) < sizeof(buffer)) {
        strcpy(buffer, source);
        printf("  安全复制: %s\n", buffer);
    } else {
        printf("  缓冲区太小，拒绝复制\n");
    }
}
```

## 2. 现代数据类型体系

### 2.1 整数类型的现代化选择

#### 2.1.1 固定宽度类型 - 现代C的首选

```c
#include <stdint.h>
#include <inttypes.h>
#include <limits.h>

// 现代整数类型使用指南
typedef struct {
    const char* type_name;
    size_t size_bytes;
    const char* use_case;
    const char* format_specifier;
} integer_type_info_t;

static const integer_type_info_t integer_types[] = {
    {"int8_t",   1, "小范围计数器、状态码", "%" PRId8},
    {"uint8_t",  1, "字节数据、像素值", "%" PRIu8},
    {"int16_t",  2, "音频采样、温度值", "%" PRId16},
    {"uint16_t", 2, "端口号、小ID", "%" PRIu16},
    {"int32_t",  4, "通用整数、时间戳", "%" PRId32},
    {"uint32_t", 4, "文件大小、哈希值", "%" PRIu32},
    {"int64_t",  8, "大数值、高精度时间", "%" PRId64},
    {"uint64_t", 8, "大文件、内存地址", "%" PRIu64}
};

void modern_integer_types_demo(void) {
    printf("现代整数类型选择指南:\n");
    printf("%-10s %-6s %-20s %s\n", "类型", "大小", "典型用途", "格式符");
    printf("%-10s %-6s %-20s %s\n", "----", "----", "--------", "------");
    
    for (size_t i = 0; i < sizeof(integer_types)/sizeof(integer_types[0]); i++) {
        const integer_type_info_t* info = &integer_types[i];
        printf("%-10s %-6zu %-20s %s\n", 
               info->type_name, info->size_bytes, 
               info->use_case, info->format_specifier);
    }
    
    // 实际应用示例
    printf("\n实际应用示例:\n");
    
    // 网络编程
    uint16_t port = 8080;
    uint32_t ip_addr = 0xC0A80001;  // 192.168.0.1
    printf("  网络: 端口=%" PRIu16 ", IP=0x%" PRIX32 "\n", port, ip_addr);
    
    // 文件处理
    uint64_t file_size = 1024ULL * 1024 * 1024 * 4;  // 4GB
    printf("  文件: 大小=%" PRIu64 " 字节\n", file_size);
    
    // 时间处理
    int64_t timestamp_ms = 1640995200000LL;  // 毫秒时间戳
    printf("  时间: 时间戳=%" PRId64 " ms\n", timestamp_ms);
}
```

#### 2.1.2 特殊用途整数类型

```c
#include <stddef.h>
#include <stdint.h>

void special_integer_types_demo(void) {
    printf("特殊用途整数类型:\n");
    
    // size_t - 数组索引和内存大小
    size_t array_size = 1000;
    size_t memory_usage = sizeof(int) * array_size;
    printf("  size_t: 数组大小=%zu, 内存使用=%zu字节\n", 
           array_size, memory_usage);
    
    // ptrdiff_t - 指针差值
    int arr[10];
    ptrdiff_t ptr_diff = &arr[9] - &arr[0];
    printf("  ptrdiff_t: 指针差值=%td\n", ptr_diff);
    
    // intptr_t/uintptr_t - 指针与整数转换
    int value = 42;
    intptr_t ptr_as_int = (intptr_t)&value;
    int* int_as_ptr = (int*)ptr_as_int;
    printf("  intptr_t: 指针转整数=0x%" PRIXPTR ", 恢复值=%d\n", 
           ptr_as_int, *int_as_ptr);
    
    // 最小/最快类型
    int_least32_t least32 = 1000000;    // 至少32位的最小类型
    int_fast16_t fast16 = 5000;         // 至少16位的最快类型
    printf("  least32=%d, fast16=%d\n", least32, fast16);
    
    // 最大整数类型
    intmax_t max_int = INTMAX_MAX;
    printf("  intmax_t最大值: %" PRIdMAX "\n", max_int);
}
```

### 2.2 浮点类型的精密控制

```c
#include <float.h>
#include <math.h>
#include <fenv.h>

void advanced_floating_point_demo(void) {
    printf("浮点类型深度分析:\n");
    
    // 精度比较
    printf("\n精度特性:\n");
    printf("  float:       %d位有效数字, 指数范围: %d到%d\n", 
           FLT_DIG, FLT_MIN_EXP, FLT_MAX_EXP);
    printf("  double:      %d位有效数字, 指数范围: %d到%d\n", 
           DBL_DIG, DBL_MIN_EXP, DBL_MAX_EXP);
    printf("  long double: %d位有效数字, 指数范围: %d到%d\n", 
           LDBL_DIG, LDBL_MIN_EXP, LDBL_MAX_EXP);
    
    // 特殊值处理
    printf("\n特殊值处理:\n");
    double pos_inf = INFINITY;
    double neg_inf = -INFINITY;
    double not_a_number = NAN;
    double zero = 0.0;
    double neg_zero = -0.0;
    
    printf("  正无穷: %f, 负无穷: %f\n", pos_inf, neg_inf);
    printf("  NaN: %f, 零: %f, 负零: %f\n", not_a_number, zero, neg_zero);
    printf("  NaN检测: %s, 无穷检测: %s\n",
           isnan(not_a_number) ? "是NaN" : "不是NaN",
           isinf(pos_inf) ? "是无穷" : "不是无穷");
    
    // 精度问题演示
    printf("\n精度问题与解决方案:\n");
    float f1 = 0.1f, f2 = 0.2f, f3 = 0.3f;
    float sum = f1 + f2;
    
    printf("  0.1f + 0.2f = %.10f\n", sum);
    printf("  直接比较: %s\n", (sum == f3) ? "相等" : "不相等");
    
    // epsilon比较
    const float EPSILON = FLT_EPSILON * 10;
    printf("  epsilon比较: %s (epsilon=%.2e)\n",
           (fabsf(sum - f3) < EPSILON) ? "相等" : "不相等", EPSILON);
    
    // 浮点环境控制
    printf("\n浮点环境控制:\n");
    feclearexcept(FE_ALL_EXCEPT);
    
    double overflow_test = DBL_MAX * 2.0;
    if (fetestexcept(FE_OVERFLOW)) {
        printf("  检测到浮点溢出\n");
    }
    
    printf("  当前舍入模式: ");
    switch (fegetround()) {
        case FE_TONEAREST:  printf("四舍五入\n"); break;
        case FE_DOWNWARD:   printf("向下舍入\n"); break;
        case FE_UPWARD:     printf("向上舍入\n"); break;
        case FE_TOWARDZERO: printf("向零舍入\n"); break;
        default:            printf("未知\n"); break;
    }
}
```

### 2.3 字符类型与编码处理

```c
#include <ctype.h>
#include <locale.h>
#include <wchar.h>

void modern_character_handling_demo(void) {
    printf("现代字符处理:\n");
    
    // 基本字符类型
    char ascii_char = 'A';
    unsigned char byte_value = 200;
    signed char signed_byte = -100;
    
    printf("\n字符类型变体:\n");
    printf("  char 'A': 值=%d, 大小=%zu字节\n", ascii_char, sizeof(ascii_char));
    printf("  unsigned char: 值=%u, 范围=0到%u\n", byte_value, UCHAR_MAX);
    printf("  signed char: 值=%d, 范围=%d到%d\n", signed_byte, SCHAR_MIN, SCHAR_MAX);
    
    // 字符分类和转换
    printf("\n字符分类函数:\n");
    char test_chars[] = {'A', 'a', '5', ' ', '\n', '@'};
    const char* descriptions[] = {"大写字母", "小写字母", "数字", "空格", "换行", "符号"};
    
    for (size_t i = 0; i < sizeof(test_chars); i++) {
        char c = test_chars[i];
        printf("  '%c' (%s): ", (c == '\n') ? '\\n' : c, descriptions[i]);
        printf("字母=%s, 数字=%s, 空白=%s, 标点=%s\n",
               isalpha(c) ? "是" : "否",
               isdigit(c) ? "是" : "否", 
               isspace(c) ? "是" : "否",
               ispunct(c) ? "是" : "否");
    }
    
    // 宽字符支持
    printf("\n宽字符支持:\n");
    setlocale(LC_ALL, "");  // 设置本地化
    
    wchar_t wide_char = L'中';
    wchar_t wide_string[] = L"Hello, 世界!";
    
    printf("  宽字符大小: %zu字节\n", sizeof(wchar_t));
    printf("  宽字符值: %lc (Unicode: U+%04X)\n", wide_char, (unsigned)wide_char);
    printf("  宽字符串长度: %zu字符\n", wcslen(wide_string));
    
    // UTF-8处理示例
    printf("\nUTF-8编码处理:\n");
    const char utf8_string[] = "Hello, 世界! 🌍";
    printf("  UTF-8字符串: %s\n", utf8_string);
    printf("  字节长度: %zu, 字符长度需要专门计算\n", strlen(utf8_string));
}
```

## 3. 现代变量管理与内存安全

### 3.1 变量生命周期的深度理解

```c
#include <stdlib.h>
#include <string.h>

// 生命周期演示结构
typedef struct {
    int id;
    char name[32];
    double value;
} demo_object_t;

// 全局变量 - 程序生命周期
static demo_object_t global_object = {1, "Global", 100.0};
static size_t object_counter = 0;

// 构造和析构函数模拟
demo_object_t* create_object(int id, const char* name, double value) {
    demo_object_t* obj = malloc(sizeof(demo_object_t));
    if (obj == NULL) {
        return NULL;
    }
    
    obj->id = id;
    strncpy(obj->name, name, sizeof(obj->name) - 1);
    obj->name[sizeof(obj->name) - 1] = '\0';
    obj->value = value;
    
    object_counter++;
    printf("  创建对象: ID=%d, 名称=%s, 计数=%zu\n", 
           obj->id, obj->name, object_counter);
    
    return obj;
}

void destroy_object(demo_object_t** obj) {
    if (obj && *obj) {
        printf("  销毁对象: ID=%d, 名称=%s\n", (*obj)->id, (*obj)->name);
        free(*obj);
        *obj = NULL;  // 防止悬空指针
        object_counter--;
    }
}

void variable_lifetime_demo(void) {
    printf("变量生命周期管理:\n");
    
    // 自动变量 - 栈分配
    demo_object_t stack_object = {2, "Stack", 200.0};
    printf("  栈对象: ID=%d, 地址=%p\n", stack_object.id, (void*)&stack_object);
    
    // 静态局部变量 - 程序生命周期，函数作用域
    static demo_object_t static_object = {3, "Static", 300.0};
    static_object.value += 10.0;  // 保持状态
    printf("  静态对象: ID=%d, 值=%.1f\n", static_object.id, static_object.value);
    
    // 动态分配 - 手动管理
    demo_object_t* heap_object = create_object(4, "Heap", 400.0);
    if (heap_object) {
        printf("  堆对象: ID=%d, 地址=%p\n", heap_object->id, (void*)heap_object);
        destroy_object(&heap_object);
    }
    
    printf("  全局对象: ID=%d, 地址=%p\n", global_object.id, (void*)&global_object);
    printf("  当前对象计数: %zu\n", object_counter);
}
```

### 3.2 现代存储类别与优化

```c
#include <stdatomic.h>
#include <threads.h>

// 线程局部存储
_Thread_local int thread_counter = 0;

// 原子变量
_Atomic int atomic_counter = 0;

// 寄存器提示
void register_optimization_demo(void) {
    printf("存储类别优化:\n");
    
    // 寄存器变量 - 编译器优化提示
    register int loop_var;
    register const int limit = 1000000;
    
    // 性能关键循环
    clock_t start = clock();
    for (loop_var = 0; loop_var < limit; loop_var++) {
        // 空循环，测试寄存器优化效果
    }
    clock_t end = clock();
    
    printf("  寄存器优化循环: %d次, 耗时: %.2fms\n", 
           limit, ((double)(end - start) / CLOCKS_PER_SEC) * 1000);
    
    // 线程局部存储
    thread_counter++;
    printf("  线程局部计数器: %d\n", thread_counter);
    
    // 原子操作
    int old_value = atomic_fetch_add(&atomic_counter, 1);
    printf("  原子计数器: 旧值=%d, 新值=%d\n", 
           old_value, atomic_load(&atomic_counter));
}
```

### 3.3 安全初始化模式

```c
#include <string.h>
#include <assert.h>

// 安全初始化宏
#define SAFE_INIT(type) {0}
#define ARRAY_INIT(arr, val) memset(arr, val, sizeof(arr))

// 初始化验证
typedef struct {
    uint32_t magic;     // 魔数，验证初始化
    bool initialized;
    int data[10];
    char name[64];
} safe_struct_t;

#define STRUCT_MAGIC 0xDEADBEEF

// 安全的结构体初始化
safe_struct_t create_safe_struct(const char* name) {
    safe_struct_t s = SAFE_INIT(safe_struct_t);
    
    s.magic = STRUCT_MAGIC;
    s.initialized = true;
    
    // 安全的字符串复制
    if (name) {
        size_t name_len = strlen(name);
        size_t copy_len = (name_len < sizeof(s.name) - 1) ? 
                         name_len : sizeof(s.name) - 1;
        memcpy(s.name, name, copy_len);
        s.name[copy_len] = '\0';
    }
    
    // 初始化数组
    for (size_t i = 0; i < sizeof(s.data)/sizeof(s.data[0]); i++) {
        s.data[i] = (int)i;
    }
    
    return s;
}

// 验证结构体完整性
bool validate_struct(const safe_struct_t* s) {
    return s && 
           s->magic == STRUCT_MAGIC && 
           s->initialized;
}

void safe_initialization_demo(void) {
    printf("安全初始化模式:\n");
    
    // 基本类型安全初始化
    int safe_int = 0;                    // 显式初始化
    double safe_double = 0.0;            // 显式初始化
    char safe_char = '\0';               // 显式初始化
    
    // 数组安全初始化
    int safe_array[10] = {0};            // 全部初始化为0
    char safe_buffer[256] = {0};         // 字符串缓冲区清零
    
    // 结构体安全初始化
    safe_struct_t my_struct = create_safe_struct("TestStruct");
    
    printf("  基本类型: int=%d, double=%.1f, char='%c'\n", 
           safe_int, safe_double, safe_char);
    printf("  数组首元素: %d, 缓冲区首字符: %d\n", 
           safe_array[0], safe_buffer[0]);
    
    if (validate_struct(&my_struct)) {
        printf("  结构体验证: 通过, 名称='%s'\n", my_struct.name);
    } else {
        printf("  结构体验证: 失败\n");
    }
    
    // C99指定初始化器
    safe_struct_t designated_init = {
        .magic = STRUCT_MAGIC,
        .initialized = true,
        .name = "Designated",
        .data = {1, 2, 3}  // 部分初始化，其余为0
    };
    
    printf("  指定初始化: 名称='%s', data[0]=%d, data[9]=%d\n",
           designated_init.name, designated_init.data[0], designated_init.data[9]);
}
```

### 3.4 作用域管理与命名空间模拟

```c
// 命名空间模拟 - 使用前缀
typedef struct {
    int value;
} math_vector_t;

typedef struct {
    char* data;
    size_t length;
} string_vector_t;

// 数学命名空间
namespace_math_vector_t math_create_vector(int value) {
    math_vector_t v = {value};
    return v;
}

void math_print_vector(const math_vector_t* v) {
    printf("Math Vector: %d\n", v->value);
}

// 字符串命名空间
string_vector_t string_create_vector(const char* data) {
    string_vector_t v = {0};
    if (data) {
        v.length = strlen(data);
        v.data = malloc(v.length + 1);
        if (v.data) {
            strcpy(v.data, data);
        }
    }
    return v;
}

void string_destroy_vector(string_vector_t* v) {
    if (v && v->data) {
        free(v->data);
        v->data = NULL;
        v->length = 0;
    }
}

void scope_management_demo(void) {
    printf("作用域管理演示:\n");
    
    // 块作用域变量
    {
        int block_var = 100;
        printf("  块作用域: block_var = %d\n", block_var);
        
        // 内层块
        {
            int inner_var = 200;
            block_var += inner_var;  // 可以访问外层变量
            printf("  内层块: inner_var = %d, block_var = %d\n", 
                   inner_var, block_var);
        }
        // inner_var 在此处不可访问
        
        printf("  外层块: block_var = %d\n", block_var);
    }
    // block_var 在此处不可访问
    
    // 命名空间模拟
    math_vector_t math_vec = math_create_vector(42);
    string_vector_t str_vec = string_create_vector("Hello");
    
    printf("  命名空间模拟:\n");
    printf("    ");
    math_print_vector(&math_vec);
    printf("    String Vector: '%s' (长度: %zu)\n", 
           str_vec.data ? str_vec.data : "NULL", str_vec.length);
    
    string_destroy_vector(&str_vec);
}
```

## 4. 现代类型转换与安全编程

### 4.1 类型转换的深度分析

```c
#include <stdint.h>
#include <limits.h>
#include <float.h>
#include <errno.h>

// 安全转换结果结构
typedef enum {
    CONVERSION_SUCCESS,
    CONVERSION_OVERFLOW,
    CONVERSION_UNDERFLOW,
    CONVERSION_PRECISION_LOSS,
    CONVERSION_INVALID
} conversion_result_t;

typedef struct {
    conversion_result_t status;
    union {
        int64_t i64;
        uint64_t u64;
        double f64;
        char str[32];
    } value;
    char error_msg[128];
} safe_conversion_t;

// 安全整数转换
safe_conversion_t safe_int_convert(int64_t value, int target_bits, bool is_signed) {
    safe_conversion_t result = {CONVERSION_SUCCESS, {0}, {0}};
    
    if (is_signed) {
        int64_t min_val = -(1LL << (target_bits - 1));
        int64_t max_val = (1LL << (target_bits - 1)) - 1;
        
        if (value < min_val) {
            result.status = CONVERSION_UNDERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "值 %lld 小于 %d 位有符号整数最小值 %lld", 
                    value, target_bits, min_val);
        } else if (value > max_val) {
            result.status = CONVERSION_OVERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "值 %lld 大于 %d 位有符号整数最大值 %lld", 
                    value, target_bits, max_val);
        } else {
            result.value.i64 = value;
        }
    } else {
        uint64_t max_val = (1ULL << target_bits) - 1;
        
        if (value < 0) {
            result.status = CONVERSION_UNDERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "负值 %lld 不能转换为无符号整数", value);
        } else if ((uint64_t)value > max_val) {
            result.status = CONVERSION_OVERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "值 %lld 大于 %d 位无符号整数最大值 %llu", 
                    value, target_bits, max_val);
        } else {
            result.value.u64 = (uint64_t)value;
        }
    }
    
    return result;
}

// 安全浮点转换
safe_conversion_t safe_float_convert(double value, bool to_float) {
    safe_conversion_t result = {CONVERSION_SUCCESS, {0}, {0}};
    
    if (to_float) {
        if (value > FLT_MAX) {
            result.status = CONVERSION_OVERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "值 %g 超出 float 最大值 %g", value, FLT_MAX);
        } else if (value < -FLT_MAX) {
            result.status = CONVERSION_UNDERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "值 %g 超出 float 最小值 %g", value, -FLT_MAX);
        } else if (fabs(value) < FLT_MIN && value != 0.0) {
            result.status = CONVERSION_PRECISION_LOSS;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "值 %g 可能丢失精度，float 最小正值为 %g", value, FLT_MIN);
            result.value.f64 = value;
        } else {
            result.value.f64 = value;
        }
    } else {
        result.value.f64 = value;
    }
    
    return result;
}

void safe_conversion_demo(void) {
    printf("安全类型转换演示:\n");
    
    // 整数转换测试
    int64_t test_values[] = {-129, -128, 127, 128, 32767, 32768, -32769};
    size_t num_tests = sizeof(test_values) / sizeof(test_values[0]);
    
    printf("  8位有符号整数转换:\n");
    for (size_t i = 0; i < num_tests; i++) {
        safe_conversion_t result = safe_int_convert(test_values[i], 8, true);
        printf("    %lld -> ", test_values[i]);
        if (result.status == CONVERSION_SUCCESS) {
            printf("成功: %lld\n", result.value.i64);
        } else {
            printf("失败: %s\n", result.error_msg);
        }
    }
    
    // 浮点转换测试
    double float_tests[] = {3.4e38, 3.5e38, 1.2e-38, 1.0e-45};
    printf("  double 到 float 转换:\n");
    for (size_t i = 0; i < 4; i++) {
        safe_conversion_t result = safe_float_convert(float_tests[i], true);
        printf("    %g -> ", float_tests[i]);
        if (result.status == CONVERSION_SUCCESS) {
            printf("成功: %g\n", result.value.f64);
        } else {
            printf("%s: %s\n", 
                   result.status == CONVERSION_PRECISION_LOSS ? "警告" : "失败",
                   result.error_msg);
        }
    }
}
```

### 4.2 现代字面量与常量定义

```c
#include <stddef.h>

// 现代常量定义方式
typedef enum {
    // 使用枚举定义整数常量
    BUFFER_SIZE = 1024,
    MAX_CONNECTIONS = 100,
    TIMEOUT_SECONDS = 30,
    
    // 位标志
    FLAG_READ    = 1 << 0,  // 0x01
    FLAG_WRITE   = 1 << 1,  // 0x02
    FLAG_EXECUTE = 1 << 2,  // 0x04
    FLAG_ALL     = FLAG_READ | FLAG_WRITE | FLAG_EXECUTE
} constants_t;

// 类型安全的常量
static const size_t ARRAY_CAPACITY = 256;
static const double PI = 3.14159265358979323846;
static const char* const DEFAULT_CONFIG_FILE = "config.ini";

// 编译时常量表达式 (C11)
#define STATIC_ASSERT(cond, msg) _Static_assert(cond, msg)

// 验证常量的合理性
STATIC_ASSERT(BUFFER_SIZE > 0, "缓冲区大小必须为正数");
STATIC_ASSERT(MAX_CONNECTIONS <= 1000, "连接数不应超过1000");
STATIC_ASSERT(sizeof(void*) == sizeof(uintptr_t), "指针大小不匹配");

// 字面量演示
void modern_literals_demo(void) {
    printf("现代字面量与常量:\n");
    
    // 整数字面量 (C23 增强)
    int decimal = 42;
    int octal = 052;           // 八进制
    int hex = 0x2A;            // 十六进制
    int binary = 0b101010;     // 二进制 (C23)
    
    // 数字分隔符 (C23)
    long large_num = 1'000'000;
    uint64_t big_hex = 0xFF'FF'FF'FF;
    
    // 浮点字面量
    double scientific = 1.23e-4;
    double hex_float = 0x1.FFFFFEp+62;  // 十六进制浮点
    
    // 字符字面量
    char ascii_char = 'A';
    char escape_char = '\n';
    char hex_char = '\x41';     // 十六进制转义
    char unicode = '\u0041';    // Unicode转义
    
    // 字符串字面量
    const char* simple_str = "Hello";
    const char* multiline_str = "Line 1\n"
                               "Line 2\n"
                               "Line 3";
    
    // 宽字符和UTF字符串
    const wchar_t* wide_str = L"宽字符串";
    const char* utf8_str = u8"UTF-8 字符串";
    const char16_t* utf16_str = u"UTF-16 字符串";
    const char32_t* utf32_str = U"UTF-32 字符串";
    
    printf("  整数字面量: %d, %d, %d, %d\n", decimal, octal, hex, binary);
    printf("  大数字: %ld, 0x%lX\n", large_num, big_hex);
    printf("  浮点数: %g, %a\n", scientific, hex_float);
    printf("  字符: '%c', '\\x%02X', '\\u%04X'\n", ascii_char, hex_char, unicode);
    printf("  字符串: \"%s\"\n", simple_str);
    printf("  多行字符串:\n%s", multiline_str);
    
    // 常量使用
    printf("  枚举常量: BUFFER_SIZE=%d, FLAG_ALL=0x%X\n", 
           BUFFER_SIZE, FLAG_ALL);
    printf("  类型安全常量: 容量=%zu, π=%.6f\n", ARRAY_CAPACITY, PI);
    printf("  字符串常量: \"%s\"\n", DEFAULT_CONFIG_FILE);
}
```

### 4.3 符号常量的最佳实践

```c
// 传统宏定义的问题和改进
#define OLD_MAX(a, b) ((a) > (b) ? (a) : (b))  // 可能重复求值

// 现代类型安全宏
#define SAFE_MAX(a, b) ({          \
    __typeof__(a) _a = (a);        \
    __typeof__(b) _b = (b);        \
    (_a > _b) ? _a : _b;           \
})

// 条件编译常量
#ifdef DEBUG
    #define LOG_LEVEL 3
    #define ENABLE_ASSERTIONS 1
#else
    #define LOG_LEVEL 1
    #define ENABLE_ASSERTIONS 0
#endif

// 平台相关常量
#if defined(_WIN32)
    #define PATH_SEPARATOR '\\'
    #define LINE_ENDING "\r\n"
#elif defined(__unix__) || defined(__APPLE__)
    #define PATH_SEPARATOR '/'
    #define LINE_ENDING "\n"
#else
    #error "不支持的平台"
#endif

// 功能测试宏
#if __STDC_VERSION__ >= 201112L
    #define HAS_C11_FEATURES 1
    #define THREAD_LOCAL _Thread_local
#else
    #define HAS_C11_FEATURES 0
    #define THREAD_LOCAL static
#endif

// 配置结构体
typedef struct {
    const char* name;
    int value;
    const char* description;
} config_item_t;

static const config_item_t CONFIG_ITEMS[] = {
    {"buffer_size", BUFFER_SIZE, "默认缓冲区大小"},
    {"max_connections", MAX_CONNECTIONS, "最大连接数"},
    {"timeout", TIMEOUT_SECONDS, "超时时间(秒)"},
    {"log_level", LOG_LEVEL, "日志级别"},
    {NULL, 0, NULL}  // 哨兵值
};

void symbolic_constants_demo(void) {
    printf("符号常量最佳实践:\n");
    
    // 宏使用对比
    int x = 10, y = 20;
    printf("  传统宏 OLD_MAX(%d, %d) = %d\n", x, y, OLD_MAX(x, y));
    printf("  安全宏 SAFE_MAX(%d, %d) = %d\n", x, y, SAFE_MAX(x, y));
    
    // 条件编译结果
    printf("  编译配置:\n");
    printf("    调试模式: %s\n", DEBUG ? "开启" : "关闭");
    printf("    日志级别: %d\n", LOG_LEVEL);
    printf("    断言: %s\n", ENABLE_ASSERTIONS ? "启用" : "禁用");
    
    // 平台相关
    printf("  平台配置:\n");
    printf("    路径分隔符: '%c'\n", PATH_SEPARATOR);
    printf("    行结束符: \"%s\" (长度: %zu)\n", 
           LINE_ENDING, strlen(LINE_ENDING));
    
    // C标准特性
    printf("  C标准特性:\n");
    printf("    C11特性: %s\n", HAS_C11_FEATURES ? "支持" : "不支持");
    
    // 配置项遍历
    printf("  配置项列表:\n");
    for (const config_item_t* item = CONFIG_ITEMS; item->name; item++) {
        printf("    %s = %d (%s)\n", 
               item->name, item->value, item->description);
    }
}
```

### 4.4 变量作用域的现代管理

```c
#include <pthread.h>

// 全局作用域管理
typedef struct {
    const char* module_name;
    int (*init_func)(void);
    void (*cleanup_func)(void);
    bool initialized;
} module_registry_t;

// 模块初始化函数
static int network_init(void) {
    printf("    网络模块初始化\n");
    return 0;
}

static void network_cleanup(void) {
    printf("    网络模块清理\n");
}

static int database_init(void) {
    printf("    数据库模块初始化\n");
    return 0;
}

static void database_cleanup(void) {
    printf("    数据库模块清理\n");
}

// 模块注册表
static module_registry_t g_modules[] = {
    {"network", network_init, network_cleanup, false},
    {"database", database_init, database_cleanup, false},
    {NULL, NULL, NULL, false}
};

// 线程局部存储
THREAD_LOCAL int thread_id = 0;
THREAD_LOCAL char thread_name[32] = {0};

// 作用域管理函数
void initialize_modules(void) {
    printf("  模块初始化:\n");
    for (module_registry_t* mod = g_modules; mod->module_name; mod++) {
        if (!mod->initialized && mod->init_func) {
            if (mod->init_func() == 0) {
                mod->initialized = true;
            }
        }
    }
}

void cleanup_modules(void) {
    printf("  模块清理:\n");
    for (module_registry_t* mod = g_modules; mod->module_name; mod++) {
        if (mod->initialized && mod->cleanup_func) {
            mod->cleanup_func();
            mod->initialized = false;
        }
    }
}

// RAII模式模拟
typedef struct {
    void* resource;
    void (*destructor)(void*);
} scoped_resource_t;

#define SCOPED_RESOURCE(var, res, dtor) \
    scoped_resource_t var __attribute__((cleanup(cleanup_scoped_resource))) = \
        {(res), (dtor)}

static void cleanup_scoped_resource(scoped_resource_t* res) {
    if (res && res->resource && res->destructor) {
        res->destructor(res->resource);
    }
}

static void free_wrapper(void* ptr) {
    free(ptr);
    printf("    自动释放内存\n");
}

void scope_management_advanced_demo(void) {
    printf("高级作用域管理:\n");
    
    // 模块生命周期管理
    initialize_modules();
    
    // 线程局部存储
    thread_id = 12345;
    snprintf(thread_name, sizeof(thread_name), "WorkerThread-%d", thread_id);
    printf("  线程信息: ID=%d, 名称='%s'\n", thread_id, thread_name);
    
    // 块作用域与自动清理
    {
        printf("  进入作用域块\n");
        
        // 自动内存管理 (需要GCC扩展)
        #ifdef __GNUC__
        char* buffer = malloc(256);
        if (buffer) {
            strcpy(buffer, "自动管理的内存");
            printf("    分配内存: '%s'\n", buffer);
            
            SCOPED_RESOURCE(scoped_buf, buffer, free_wrapper);
            // buffer 将在作用域结束时自动释放
        }
        #else
        printf("    (自动清理需要GCC编译器支持)\n");
        #endif
        
        printf("  离开作用域块\n");
    }
    
    cleanup_modules();
}
```

## 5. 现代C语言实践指南与性能优化

### 5.1 智能类型选择策略

```c
#include <stdint.h>
#include <stdbool.h>
#include <time.h>

// 类型选择决策树
typedef enum {
    TYPE_CHOICE_RANGE,      // 基于数据范围
    TYPE_CHOICE_PERFORMANCE,// 基于性能需求
    TYPE_CHOICE_PORTABILITY,// 基于可移植性
    TYPE_CHOICE_SAFETY      // 基于安全性
} type_choice_criteria_t;

// 类型选择建议结构
typedef struct {
    const char* use_case;
    const char* recommended_type;
    const char* reason;
    size_t size_bytes;
    const char* range_info;
} type_recommendation_t;

static const type_recommendation_t TYPE_RECOMMENDATIONS[] = {
    // 整数类型建议
    {"像素值/颜色分量", "uint8_t", "范围0-255，节省内存", 1, "0 到 255"},
    {"音频采样", "int16_t", "CD质量音频标准", 2, "-32,768 到 32,767"},
    {"文件大小", "uint64_t", "支持大文件", 8, "0 到 18EB"},
    {"数组索引", "size_t", "与系统指针大小匹配", sizeof(size_t), "0 到 SIZE_MAX"},
    {"循环计数器", "int", "CPU原生类型，性能最佳", sizeof(int), "通常32位"},
    {"网络协议长度", "uint32_t", "网络字节序兼容", 4, "0 到 4GB"},
    {"时间戳(毫秒)", "uint64_t", "足够未来几千年", 8, "0 到 584,942,417年"},
    {"错误码", "int", "兼容系统调用约定", sizeof(int), "负数表示错误"},
    
    // 浮点类型建议
    {"3D坐标", "float", "GPU友好，精度足够", 4, "±3.4e38, 7位精度"},
    {"科学计算", "double", "高精度需求", 8, "±1.8e308, 15位精度"},
    {"金融计算", "long double", "最高精度", sizeof(long double), "平台相关"},
    
    {NULL, NULL, NULL, 0, NULL}
};

// 性能基准测试
typedef struct {
    const char* type_name;
    size_t iterations;
    double time_ms;
    double ops_per_sec;
} performance_result_t;

performance_result_t benchmark_integer_types(void) {
    const size_t ITERATIONS = 10000000;
    clock_t start, end;
    
    // 测试int性能
    start = clock();
    volatile int int_sum = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        int_sum += i;
    }
    end = clock();
    
    double time_ms = ((double)(end - start) / CLOCKS_PER_SEC) * 1000;
    double ops_per_sec = ITERATIONS / (time_ms / 1000);
    
    return (performance_result_t){
        "int", ITERATIONS, time_ms, ops_per_sec
    };
}

void intelligent_type_selection_demo(void) {
    printf("智能类型选择策略:\n");
    
    // 显示类型建议表
    printf("  类型选择建议表:\n");
    printf("  %-20s %-15s %-8s %-25s %s\n", 
           "用途", "推荐类型", "大小", "范围", "理由");
    printf("  %s\n", "--------------------------------------------------------------------------------");
    
    for (const type_recommendation_t* rec = TYPE_RECOMMENDATIONS; rec->use_case; rec++) {
        printf("  %-20s %-15s %zu字节   %-25s %s\n",
               rec->use_case, rec->recommended_type, rec->size_bytes,
               rec->range_info, rec->reason);
    }
    
    // 性能基准测试
    printf("\n  性能基准测试:\n");
    performance_result_t result = benchmark_integer_types();
    printf("    %s: %.2f ms, %.0f ops/sec\n", 
           result.type_name, result.time_ms, result.ops_per_sec);
    
    // 内存对齐分析
    printf("\n  内存对齐分析:\n");
    struct unaligned_struct {
        char c;      // 1字节
        double d;    // 8字节
        char c2;     // 1字节
    };
    
    struct aligned_struct {
        double d;    // 8字节
        char c;      // 1字节
        char c2;     // 1字节
        // 6字节填充
    };
    
    printf("    未优化结构体: %zu字节\n", sizeof(struct unaligned_struct));
    printf("    优化后结构体: %zu字节\n", sizeof(struct aligned_struct));
    printf("    节省内存: %zu字节\n", 
           sizeof(struct unaligned_struct) - sizeof(struct aligned_struct));
}
```

### 5.2 安全编程模式与错误处理

```c
#include <errno.h>
#include <assert.h>

// 错误处理枚举
typedef enum {
    RESULT_SUCCESS = 0,
    RESULT_NULL_POINTER,
    RESULT_INVALID_ARGUMENT,
    RESULT_BUFFER_OVERFLOW,
    RESULT_MEMORY_ERROR,
    RESULT_CONVERSION_ERROR
} result_code_t;

// 结果包装器
#define RESULT_TYPE(T) struct { result_code_t code; T value; }

typedef RESULT_TYPE(int) int_result_t;
typedef RESULT_TYPE(double) double_result_t;

// 安全的字符串到整数转换
int_result_t safe_str_to_int(const char* str) {
    int_result_t result = {RESULT_SUCCESS, 0};
    
    if (!str) {
        result.code = RESULT_NULL_POINTER;
        return result;
    }
    
    char* endptr;
    errno = 0;
    long val = strtol(str, &endptr, 10);
    
    if (errno == ERANGE || val > INT_MAX || val < INT_MIN) {
        result.code = RESULT_CONVERSION_ERROR;
        return result;
    }
    
    if (endptr == str || *endptr != '\0') {
        result.code = RESULT_INVALID_ARGUMENT;
        return result;
    }
    
    result.value = (int)val;
    return result;
}

// 安全的数组访问
#define SAFE_ARRAY_ACCESS(arr, idx, len, default_val) \
    (((idx) >= 0 && (idx) < (len)) ? (arr)[idx] : (default_val))

// 边界检查宏
#define CHECK_BOUNDS(idx, len) \
    do { \
        if ((idx) < 0 || (idx) >= (len)) { \
            fprintf(stderr, "数组越界: 索引%d, 长度%d, 文件%s, 行%d\n", \
                    (int)(idx), (int)(len), __FILE__, __LINE__); \
            abort(); \
        } \
    } while(0)

// 内存安全分配器
void* safe_malloc(size_t size, const char* purpose) {
    if (size == 0) {
        fprintf(stderr, "警告: 尝试分配0字节内存 (%s)\n", purpose);
        return NULL;
    }
    
    void* ptr = malloc(size);
    if (!ptr) {
        fprintf(stderr, "内存分配失败: %zu字节 (%s)\n", size, purpose);
        exit(EXIT_FAILURE);
    }
    
    // 调试模式下清零内存
    #ifdef DEBUG
    memset(ptr, 0, size);
    printf("分配内存: %p, %zu字节 (%s)\n", ptr, size, purpose);
    #endif
    
    return ptr;
}

void safe_free(void** ptr) {
    if (ptr && *ptr) {
        #ifdef DEBUG
        printf("释放内存: %p\n", *ptr);
        #endif
        free(*ptr);
        *ptr = NULL;  // 防止悬空指针
    }
}

void safety_patterns_demo(void) {
    printf("安全编程模式演示:\n");
    
    // 安全转换测试
    const char* test_strings[] = {"123", "-456", "abc", "999999999999", NULL};
    printf("  安全字符串转换:\n");
    
    for (size_t i = 0; i < sizeof(test_strings)/sizeof(test_strings[0]); i++) {
        int_result_t result = safe_str_to_int(test_strings[i]);
        printf("    \"%s\" -> ", test_strings[i] ? test_strings[i] : "NULL");
        
        switch (result.code) {
            case RESULT_SUCCESS:
                printf("成功: %d\n", result.value);
                break;
            case RESULT_NULL_POINTER:
                printf("错误: 空指针\n");
                break;
            case RESULT_INVALID_ARGUMENT:
                printf("错误: 无效参数\n");
                break;
            case RESULT_CONVERSION_ERROR:
                printf("错误: 转换失败\n");
                break;
            default:
                printf("错误: 未知错误\n");
        }
    }
    
    // 安全数组访问
    printf("\n  安全数组访问:\n");
    int test_array[] = {10, 20, 30, 40, 50};
    size_t array_len = sizeof(test_array) / sizeof(test_array[0]);
    
    int indices[] = {0, 2, 5, -1};
    for (size_t i = 0; i < sizeof(indices)/sizeof(indices[0]); i++) {
        int idx = indices[i];
        int value = SAFE_ARRAY_ACCESS(test_array, idx, array_len, -1);
        printf("    索引%d: %s -> %d\n", idx, 
               (idx >= 0 && idx < array_len) ? "有效" : "无效", value);
    }
    
    // 安全内存管理
    printf("\n  安全内存管理:\n");
    char* buffer = (char*)safe_malloc(256, "测试缓冲区");
    strcpy(buffer, "安全分配的内存");
    printf("    缓冲区内容: '%s'\n", buffer);
    safe_free((void**)&buffer);
    printf("    缓冲区已安全释放，指针: %p\n", (void*)buffer);
}
```

### 5.3 现代调试与分析工具集成

```c
#include <stdarg.h>

// 调试级别
typedef enum {
    DEBUG_LEVEL_ERROR = 0,
    DEBUG_LEVEL_WARN  = 1,
    DEBUG_LEVEL_INFO  = 2,
    DEBUG_LEVEL_DEBUG = 3,
    DEBUG_LEVEL_TRACE = 4
} debug_level_t;

// 全局调试级别
static debug_level_t g_debug_level = DEBUG_LEVEL_INFO;

// 彩色输出宏
#define COLOR_RED     "\033[31m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_RESET   "\033[0m"

// 高级调试宏
#define DEBUG_PRINT(level, fmt, ...) \
    do { \
        if ((level) <= g_debug_level) { \
            const char* color = ""; \
            const char* level_str = ""; \
            switch(level) { \
                case DEBUG_LEVEL_ERROR: color = COLOR_RED; level_str = "ERROR"; break; \
                case DEBUG_LEVEL_WARN:  color = COLOR_YELLOW; level_str = "WARN "; break; \
                case DEBUG_LEVEL_INFO:  color = COLOR_GREEN; level_str = "INFO "; break; \
                case DEBUG_LEVEL_DEBUG: color = COLOR_BLUE; level_str = "DEBUG"; break; \
                case DEBUG_LEVEL_TRACE: color = COLOR_MAGENTA; level_str = "TRACE"; break; \
            } \
            fprintf(stderr, "%s[%s]%s %s:%d %s() - " fmt "%s\n", \
                    color, level_str, COLOR_RESET, \
                    __FILE__, __LINE__, __func__, ##__VA_ARGS__, COLOR_RESET); \
        } \
    } while(0)

// 性能分析宏
#define PROFILE_START(name) \
    clock_t _profile_start_##name = clock(); \
    DEBUG_PRINT(DEBUG_LEVEL_TRACE, "开始性能分析: %s", #name)

#define PROFILE_END(name) \
    do { \
        clock_t _profile_end_##name = clock(); \
        double _profile_time_##name = ((double)(_profile_end_##name - _profile_start_##name)) / CLOCKS_PER_SEC * 1000; \
        DEBUG_PRINT(DEBUG_LEVEL_INFO, "性能分析 %s: %.2f ms", #name, _profile_time_##name); \
    } while(0)

// 内存泄漏检测 (简化版)
#ifdef DEBUG_MEMORY
static size_t g_allocated_bytes = 0;
static size_t g_allocation_count = 0;

void* debug_malloc(size_t size, const char* file, int line) {
    void* ptr = malloc(size);
    if (ptr) {
        g_allocated_bytes += size;
        g_allocation_count++;
        DEBUG_PRINT(DEBUG_LEVEL_TRACE, "分配内存: %p, %zu字节 (总计: %zu字节, %zu次分配) at %s:%d", 
                   ptr, size, g_allocated_bytes, g_allocation_count, file, line);
    }
    return ptr;
}

void debug_free(void* ptr, const char* file, int line) {
    if (ptr) {
        g_allocation_count--;
        DEBUG_PRINT(DEBUG_LEVEL_TRACE, "释放内存: %p (剩余: %zu次分配) at %s:%d", 
                   ptr, g_allocation_count, file, line);
        free(ptr);
    }
}

#define malloc(size) debug_malloc(size, __FILE__, __LINE__)
#define free(ptr) debug_free(ptr, __FILE__, __LINE__)
#endif

// 断言增强
#define ASSERT_MSG(condition, msg, ...) \
    do { \
        if (!(condition)) { \
            DEBUG_PRINT(DEBUG_LEVEL_ERROR, "断言失败: " #condition); \
            DEBUG_PRINT(DEBUG_LEVEL_ERROR, msg, ##__VA_ARGS__); \
            abort(); \
        } \
    } while(0)

// 静态分析友好的代码
void modern_debugging_demo(void) {
    printf("现代调试与分析工具演示:\n");
    
    // 设置调试级别
    g_debug_level = DEBUG_LEVEL_TRACE;
    
    DEBUG_PRINT(DEBUG_LEVEL_INFO, "开始调试演示");
    DEBUG_PRINT(DEBUG_LEVEL_DEBUG, "调试级别设置为: %d", g_debug_level);
    
    // 性能分析示例
    PROFILE_START(sorting);
    
    // 模拟一些工作
    int test_array[] = {64, 34, 25, 12, 22, 11, 90};
    size_t n = sizeof(test_array) / sizeof(test_array[0]);
    
    DEBUG_PRINT(DEBUG_LEVEL_DEBUG, "排序数组，大小: %zu", n);
    
    // 简单冒泡排序
    for (size_t i = 0; i < n-1; i++) {
        for (size_t j = 0; j < n-i-1; j++) {
            if (test_array[j] > test_array[j+1]) {
                int temp = test_array[j];
                test_array[j] = test_array[j+1];
                test_array[j+1] = temp;
            }
        }
    }
    
    PROFILE_END(sorting);
    
    // 断言测试
    ASSERT_MSG(test_array[0] <= test_array[1], "数组未正确排序");
    DEBUG_PRINT(DEBUG_LEVEL_INFO, "排序验证通过");
    
    // 内存分析示例
    #ifdef DEBUG_MEMORY
    char* buffer1 = malloc(100);
    char* buffer2 = malloc(200);
    free(buffer1);
    free(buffer2);
    
    if (g_allocation_count == 0) {
        DEBUG_PRINT(DEBUG_LEVEL_INFO, "内存泄漏检测: 通过");
    } else {
        DEBUG_PRINT(DEBUG_LEVEL_WARN, "内存泄漏检测: 发现%zu个未释放的分配", g_allocation_count);
    }
    #endif
    
    DEBUG_PRINT(DEBUG_LEVEL_INFO, "调试演示完成");
}
```

### 5.4 跨平台兼容性与现代C标准特性

```c
// 平台检测宏
#if defined(_WIN32) || defined(_WIN64)
    #define PLATFORM_WINDOWS
    #include <windows.h>
#elif defined(__linux__)
    #define PLATFORM_LINUX
    #include <unistd.h>
#elif defined(__APPLE__)
    #define PLATFORM_MACOS
    #include <unistd.h>
#else
    #define PLATFORM_UNKNOWN
#endif

// C标准版本检测
#if __STDC_VERSION__ >= 202311L
    #define C_STANDARD "C23"
    #define HAS_C23_FEATURES 1
#elif __STDC_VERSION__ >= 201710L
    #define C_STANDARD "C18"
    #define HAS_C18_FEATURES 1
#elif __STDC_VERSION__ >= 201112L
    #define C_STANDARD "C11"
    #define HAS_C11_FEATURES 1
#elif __STDC_VERSION__ >= 199901L
    #define C_STANDARD "C99"
    #define HAS_C99_FEATURES 1
#else
    #define C_STANDARD "C90"
#endif

// 编译器特性检测
#ifdef __GNUC__
    #define COMPILER_GCC
    #define FORCE_INLINE __attribute__((always_inline)) inline
    #define NO_RETURN __attribute__((noreturn))
    #define DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
    #define COMPILER_MSVC
    #define FORCE_INLINE __forceinline
    #define NO_RETURN __declspec(noreturn)
    #define DEPRECATED __declspec(deprecated)
#else
    #define FORCE_INLINE inline
    #define NO_RETURN
    #define DEPRECATED
#endif

// 现代C特性使用
#ifdef HAS_C11_FEATURES
    #include <stdatomic.h>
    #include <threads.h>
    
    // 原子操作示例
    _Atomic int atomic_counter = 0;
    
    // 线程局部存储
    _Thread_local int thread_local_var = 0;
    
    // 静态断言
    _Static_assert(sizeof(int) >= 4, "int类型至少需要4字节");
    
    // 泛型宏 (C11)
    #define MAX(x, y) _Generic((x), \
        int: max_int, \
        float: max_float, \
        double: max_double, \
        default: max_generic \
    )(x, y)
    
    int max_int(int a, int b) { return a > b ? a : b; }
    float max_float(float a, float b) { return a > b ? a : b; }
    double max_double(double a, double b) { return a > b ? a : b; }
    void* max_generic(void* a, void* b) { return a; } // 占位符
#endif

// 跨平台时间函数
double get_time_seconds(void) {
    #ifdef PLATFORM_WINDOWS
        LARGE_INTEGER frequency, counter;
        QueryPerformanceFrequency(&frequency);
        QueryPerformanceCounter(&counter);
        return (double)counter.QuadPart / frequency.QuadPart;
    #else
        struct timespec ts;
        clock_gettime(CLOCK_MONOTONIC, &ts);
        return ts.tv_sec + ts.tv_nsec / 1e9;
    #endif
}

void cross_platform_demo(void) {
    printf("跨平台兼容性与现代C特性演示:\n");
    
    // 平台信息
    printf("  平台信息:\n");
    #ifdef PLATFORM_WINDOWS
        printf("    操作系统: Windows\n");
    #elif defined(PLATFORM_LINUX)
        printf("    操作系统: Linux\n");
    #elif defined(PLATFORM_MACOS)
        printf("    操作系统: macOS\n");
    #else
        printf("    操作系统: 未知\n");
    #endif
    
    // 编译器信息
    printf("  编译器信息:\n");
    #ifdef COMPILER_GCC
        printf("    编译器: GCC %d.%d.%d\n", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);
    #elif defined(COMPILER_MSVC)
        printf("    编译器: MSVC %d\n", _MSC_VER);
    #else
        printf("    编译器: 未知\n");
    #endif
    
    // C标准信息
    printf("    C标准: %s\n", C_STANDARD);
    printf("    __STDC_VERSION__: %ld\n", __STDC_VERSION__);
    
    // 类型大小信息
    printf("  类型大小信息:\n");
    printf("    char: %zu字节\n", sizeof(char));
    printf("    int: %zu字节\n", sizeof(int));
    printf("    long: %zu字节\n", sizeof(long));
    printf("    long long: %zu字节\n", sizeof(long long));
    printf("    void*: %zu字节\n", sizeof(void*));
    printf("    size_t: %zu字节\n", sizeof(size_t));
    
    // 现代C特性演示
    #ifdef HAS_C11_FEATURES
        printf("  C11特性演示:\n");
        
        // 原子操作
        int old_value = atomic_fetch_add(&atomic_counter, 5);
        printf("    原子操作: 旧值=%d, 新值=%d\n", old_value, atomic_load(&atomic_counter));
        
        // 线程局部存储
        thread_local_var = 42;
        printf("    线程局部变量: %d\n", thread_local_var);
        
        // 泛型宏
        printf("    泛型宏: MAX(10, 20) = %d\n", MAX(10, 20));
        printf("    泛型宏: MAX(3.14f, 2.71f) = %.2f\n", MAX(3.14f, 2.71f));
    #else
        printf("  C11特性: 不支持\n");
    #endif
    
    // 高精度时间
    double start_time = get_time_seconds();
    // 模拟一些工作
    volatile int dummy = 0;
    for (int i = 0; i < 1000000; i++) {
        dummy += i;
    }
    double end_time = get_time_seconds();
    printf("  高精度计时: %.6f秒\n", end_time - start_time);
}
```

## 6. 总结与进阶方向

### 6.1 核心知识点总结

通过本章的学习，我们深入掌握了现代C语言数据类型与变量管理的核心概念：

#### 类型系统精要
- **现代类型选择**: 使用`stdint.h`固定宽度类型确保跨平台一致性
- **内存模型理解**: 掌握数据在内存中的表示和对齐规则
- **类型安全编程**: 运用编译时检查和运行时验证确保类型安全

#### 变量管理最佳实践
- **生命周期管理**: 理解自动、静态、动态存储的特点和适用场景
- **作用域控制**: 合理使用块作用域和命名空间模拟技术
- **安全初始化**: 采用防御性编程模式避免未定义行为

#### 现代C特性应用
- **C11/C18/C23特性**: 原子操作、线程局部存储、泛型宏等
- **跨平台兼容**: 条件编译和特性检测技术
- **调试与分析**: 集成现代工具链进行性能分析和错误检测

### 6.2 实践应用指南

```c
// 综合示例：现代C数据类型最佳实践
#include <stdint.h>
#include <stdbool.h>
#include <stdatomic.h>

// 1. 类型安全的配置系统
typedef struct {
    uint32_t magic;           // 魔数验证
    uint16_t version;         // 版本号
    bool debug_enabled;       // 调试开关
    size_t buffer_size;       // 缓冲区大小
    double timeout_seconds;   // 超时时间
} config_t;

#define CONFIG_MAGIC 0xDEADBEEF
#define CONFIG_VERSION 1

// 安全的配置初始化
config_t create_safe_config(void) {
    return (config_t) {
        .magic = CONFIG_MAGIC,
        .version = CONFIG_VERSION,
        .debug_enabled = false,
        .buffer_size = 4096,
        .timeout_seconds = 30.0
    };
}

// 2. 高性能计数器系统
typedef struct {
    _Atomic uint64_t value;
    _Atomic uint64_t operations;
    const char* name;
} atomic_counter_t;

void counter_increment(atomic_counter_t* counter) {
    if (counter) {
        atomic_fetch_add(&counter->value, 1);
        atomic_fetch_add(&counter->operations, 1);
    }
}

uint64_t counter_get_value(const atomic_counter_t* counter) {
    return counter ? atomic_load(&counter->value) : 0;
}

// 3. 内存安全的字符串处理
typedef struct {
    char* data;
    size_t length;
    size_t capacity;
    uint32_t checksum;
} safe_string_t;

safe_string_t* safe_string_create(const char* initial) {
    if (!initial) return NULL;
    
    size_t len = strlen(initial);
    safe_string_t* str = malloc(sizeof(safe_string_t));
    if (!str) return NULL;
    
    str->capacity = len + 1;
    str->data = malloc(str->capacity);
    if (!str->data) {
        free(str);
        return NULL;
    }
    
    strcpy(str->data, initial);
    str->length = len;
    str->checksum = 0; // 简化的校验和
    
    return str;
}

void safe_string_destroy(safe_string_t** str) {
    if (str && *str) {
        free((*str)->data);
        (*str)->data = NULL;
        free(*str);
        *str = NULL;
    }
}
```

### 6.3 性能优化策略

#### 内存布局优化
```c
// 优化前：内存浪费
struct inefficient_struct {
    char flag;        // 1字节
    double value;     // 8字节 (7字节填充)
    int count;        // 4字节
    char status;      // 1字节 (3字节填充)
};  // 总计：24字节

// 优化后：紧凑布局
struct efficient_struct {
    double value;     // 8字节
    int count;        // 4字节
    char flag;        // 1字节
    char status;      // 1字节
    // 2字节填充
};  // 总计：16字节，节省33%内存
```

#### 缓存友好的数据结构
```c
// 数组结构（缓存友好）
typedef struct {
    size_t count;
    int* values;      // 连续内存
    char* flags;      // 连续内存
} aos_data_t;        // Array of Structures

// 结构数组（可能导致缓存未命中）
typedef struct {
    int value;
    char flag;
} soa_item_t;

typedef struct {
    size_t count;
    soa_item_t* items; // 交错内存访问
} soa_data_t;         // Structure of Arrays
```

### 6.4 进阶学习路径

#### 深入系统编程
1. **内存管理进阶**
   - 自定义内存分配器
   - 内存池技术
   - 垃圾回收算法

2. **并发编程**
   - 原子操作深入
   - 无锁数据结构
   - 内存模型理解

3. **性能优化**
   - CPU缓存优化
   - SIMD指令集
   - 编译器优化技术

#### 现代C生态系统
1. **构建系统**
   - CMake高级特性
   - 包管理工具
   - 持续集成

2. **调试与分析**
   - Valgrind内存检测
   - AddressSanitizer
   - 性能分析工具

3. **代码质量**
   - 静态分析工具
   - 单元测试框架
   - 代码覆盖率

### 6.5 学习检查清单

#### 基础掌握 ✓
- [ ] 理解所有基本数据类型的特点和用途
- [ ] 掌握变量声明、初始化和作用域规则
- [ ] 熟练使用类型转换和常量定义
- [ ] 了解内存对齐和结构体布局

#### 进阶应用 ✓
- [ ] 能够选择合适的数据类型解决实际问题
- [ ] 掌握安全编程模式和错误处理
- [ ] 理解现代C标准特性和跨平台编程
- [ ] 具备性能优化和调试能力

#### 实战项目 ✓
- [ ] 实现一个类型安全的配置系统
- [ ] 开发高性能的数据结构库
- [ ] 构建跨平台的工具程序
- [ ] 参与开源C项目贡献

通过系统学习和实践，你将具备现代C语言数据类型与变量管理的专业能力，为后续的高级主题学习打下坚实基础。记住，优秀的C程序员不仅要掌握语法，更要理解底层原理，培养系统思维和工程实践能力。

