# Cè¯­è¨€æ•°æ®ç±»å‹ä¸å˜é‡è¯¦è§£

## å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å°†æŒæ¡ï¼š
- Cè¯­è¨€åŸºæœ¬æ•°æ®ç±»å‹çš„ç‰¹ç‚¹å’Œä½¿ç”¨æ–¹æ³•
- å˜é‡çš„å£°æ˜ã€åˆå§‹åŒ–å’Œä½œç”¨åŸŸè§„åˆ™
- ç±»å‹è½¬æ¢çš„æœºåˆ¶å’Œæœ€ä½³å®è·µ
- å¸¸é‡å®šä¹‰å’Œä½¿ç”¨çš„è§„èŒƒæ–¹æ³•
- å˜é‡ç”Ÿå‘½å‘¨æœŸå’Œå†…å­˜ç®¡ç†åŸºç¡€

## 1. ç°ä»£Cç±»å‹ç³»ç»Ÿæ·±åº¦è§£æ

### 1.1 ç±»å‹ç³»ç»Ÿè®¾è®¡å“²å­¦

Cè¯­è¨€é‡‡ç”¨**é™æ€å¼ºç±»å‹ç³»ç»Ÿ**ï¼Œä½“ç°äº†ç³»ç»Ÿç¼–ç¨‹è¯­è¨€çš„æ ¸å¿ƒè®¾è®¡ç†å¿µï¼š

```c
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <assert.h>

// ç±»å‹å®‰å…¨çš„è®¾è®¡æ¨¡å¼
typedef struct {
    uint32_t id;
    bool is_valid;
    char name[32];
} user_t;

// ç±»å‹å®‰å…¨çš„æ„é€ å‡½æ•°
user_t create_user(uint32_t id, const char* name) {
    assert(name != NULL);
    user_t user = {
        .id = id,
        .is_valid = true,
        .name = {0}  // é›¶åˆå§‹åŒ–
    };
    
    // å®‰å…¨çš„å­—ç¬¦ä¸²å¤åˆ¶
    size_t name_len = strlen(name);
    if (name_len < sizeof(user.name)) {
        memcpy(user.name, name, name_len);
    }
    
    return user;
}

void type_system_philosophy_demo(void) {
    // ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
    user_t alice = create_user(1001, "Alice");
    
    // ç±»å‹å®‰å…¨çš„æ“ä½œ
    printf("ç”¨æˆ·ä¿¡æ¯: ID=%u, å§“å=%s, æœ‰æ•ˆ=%s\n",
           alice.id, alice.name, alice.is_valid ? "æ˜¯" : "å¦");
    
    // é™æ€æ–­è¨€ - ç¼–è¯‘æ—¶æ£€æŸ¥
    _Static_assert(sizeof(user_t) <= 64, "ç”¨æˆ·ç»“æ„ä½“è¿‡å¤§");
    
    printf("ç±»å‹ç³»ç»Ÿç‰¹æ€§:\n");
    printf("  - ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥: é˜²æ­¢ç±»å‹é”™è¯¯\n");
    printf("  - é›¶æˆæœ¬æŠ½è±¡: è¿è¡Œæ—¶æ— é¢å¤–å¼€é”€\n");
    printf("  - å†…å­˜é€æ˜: ç›´æ¥æ˜ å°„ç¡¬ä»¶ç‰¹æ€§\n");
}
```

### 1.2 å†…å­˜æ¨¡å‹ä¸æ•°æ®è¡¨ç¤º

æ·±å…¥ç†è§£æ•°æ®åœ¨å†…å­˜ä¸­çš„å­˜å‚¨æ–¹å¼ï¼Œæ˜¯ç¼–å†™é«˜æ•ˆç¨‹åºçš„å…³é”®ï¼š

```c
#include <stdint.h>
#include <string.h>

// å†…å­˜å¸ƒå±€åˆ†æå·¥å…·
typedef union {
    uint32_t as_uint32;
    uint16_t as_uint16[2];
    uint8_t  as_bytes[4];
    struct {
        uint8_t byte0, byte1, byte2, byte3;
    } as_struct;
} memory_view_t;

void memory_layout_analysis(void) {
    memory_view_t data = { .as_uint32 = 0x12345678 };
    
    printf("å†…å­˜å¸ƒå±€åˆ†æ (å€¼: 0x%08X):\n", data.as_uint32);
    printf("  æŒ‰å­—èŠ‚è®¿é—®: [0x%02X, 0x%02X, 0x%02X, 0x%02X]\n",
           data.as_bytes[0], data.as_bytes[1], 
           data.as_bytes[2], data.as_bytes[3]);
    
    printf("  æŒ‰16ä½è®¿é—®: [0x%04X, 0x%04X]\n",
           data.as_uint16[0], data.as_uint16[1]);
    
    printf("  ç»“æ„ä½“è®¿é—®: {%02X, %02X, %02X, %02X}\n",
           data.as_struct.byte0, data.as_struct.byte1,
           data.as_struct.byte2, data.as_struct.byte3);
    
    // å­—èŠ‚åºæ£€æµ‹
    const char* endianness = (data.as_bytes[0] == 0x78) ? "å°ç«¯åº" : "å¤§ç«¯åº";
    printf("  ç³»ç»Ÿå­—èŠ‚åº: %s\n", endianness);
    
    // å¯¹é½åˆ†æ
    struct alignment_test {
        char c;      // 1å­—èŠ‚
        int i;       // 4å­—èŠ‚ï¼Œå¯èƒ½æœ‰å¡«å……
        double d;    // 8å­—èŠ‚ï¼Œå¯èƒ½æœ‰å¡«å……
    };
    
    printf("\nå†…å­˜å¯¹é½åˆ†æ:\n");
    printf("  charåç§»: %zu, intåç§»: %zu, doubleåç§»: %zu\n",
           offsetof(struct alignment_test, c),
           offsetof(struct alignment_test, i),
           offsetof(struct alignment_test, d));
    printf("  ç»“æ„ä½“æ€»å¤§å°: %zuå­—èŠ‚\n", sizeof(struct alignment_test));
}
```

### 1.3 ç±»å‹å®‰å…¨ç¼–ç¨‹æ¨¡å¼

```c
#include <errno.h>
#include <limits.h>

// ç±»å‹å®‰å…¨çš„é”™è¯¯å¤„ç†
typedef enum {
    RESULT_OK = 0,
    RESULT_OVERFLOW,
    RESULT_UNDERFLOW,
    RESULT_INVALID_INPUT
} result_code_t;

typedef struct {
    result_code_t code;
    int32_t value;
} safe_int_result_t;

// å®‰å…¨çš„åŠ æ³•æ“ä½œ
safe_int_result_t safe_add_int32(int32_t a, int32_t b) {
    safe_int_result_t result = {RESULT_OK, 0};
    
    // æº¢å‡ºæ£€æŸ¥
    if (a > 0 && b > INT32_MAX - a) {
        result.code = RESULT_OVERFLOW;
        return result;
    }
    if (a < 0 && b < INT32_MIN - a) {
        result.code = RESULT_UNDERFLOW;
        return result;
    }
    
    result.value = a + b;
    return result;
}

void type_safe_programming_demo(void) {
    printf("ç±»å‹å®‰å…¨ç¼–ç¨‹ç¤ºä¾‹:\n");
    
    // æµ‹è¯•æ­£å¸¸æƒ…å†µ
    safe_int_result_t r1 = safe_add_int32(100, 200);
    if (r1.code == RESULT_OK) {
        printf("  100 + 200 = %d\n", r1.value);
    }
    
    // æµ‹è¯•æº¢å‡ºæƒ…å†µ
    safe_int_result_t r2 = safe_add_int32(INT32_MAX, 1);
    if (r2.code == RESULT_OVERFLOW) {
        printf("  æ£€æµ‹åˆ°æ•´æ•°æº¢å‡º\n");
    }
    
    // ç±»å‹å®‰å…¨çš„å­—ç¬¦ä¸²å¤„ç†
    char buffer[16];
    const char* source = "Hello, World!";
    
    if (strlen(source) < sizeof(buffer)) {
        strcpy(buffer, source);
        printf("  å®‰å…¨å¤åˆ¶: %s\n", buffer);
    } else {
        printf("  ç¼“å†²åŒºå¤ªå°ï¼Œæ‹’ç»å¤åˆ¶\n");
    }
}
```

## 2. ç°ä»£æ•°æ®ç±»å‹ä½“ç³»

### 2.1 æ•´æ•°ç±»å‹çš„ç°ä»£åŒ–é€‰æ‹©

#### 2.1.1 å›ºå®šå®½åº¦ç±»å‹ - ç°ä»£Cçš„é¦–é€‰

```c
#include <stdint.h>
#include <inttypes.h>
#include <limits.h>

// ç°ä»£æ•´æ•°ç±»å‹ä½¿ç”¨æŒ‡å—
typedef struct {
    const char* type_name;
    size_t size_bytes;
    const char* use_case;
    const char* format_specifier;
} integer_type_info_t;

static const integer_type_info_t integer_types[] = {
    {"int8_t",   1, "å°èŒƒå›´è®¡æ•°å™¨ã€çŠ¶æ€ç ", "%" PRId8},
    {"uint8_t",  1, "å­—èŠ‚æ•°æ®ã€åƒç´ å€¼", "%" PRIu8},
    {"int16_t",  2, "éŸ³é¢‘é‡‡æ ·ã€æ¸©åº¦å€¼", "%" PRId16},
    {"uint16_t", 2, "ç«¯å£å·ã€å°ID", "%" PRIu16},
    {"int32_t",  4, "é€šç”¨æ•´æ•°ã€æ—¶é—´æˆ³", "%" PRId32},
    {"uint32_t", 4, "æ–‡ä»¶å¤§å°ã€å“ˆå¸Œå€¼", "%" PRIu32},
    {"int64_t",  8, "å¤§æ•°å€¼ã€é«˜ç²¾åº¦æ—¶é—´", "%" PRId64},
    {"uint64_t", 8, "å¤§æ–‡ä»¶ã€å†…å­˜åœ°å€", "%" PRIu64}
};

void modern_integer_types_demo(void) {
    printf("ç°ä»£æ•´æ•°ç±»å‹é€‰æ‹©æŒ‡å—:\n");
    printf("%-10s %-6s %-20s %s\n", "ç±»å‹", "å¤§å°", "å…¸å‹ç”¨é€”", "æ ¼å¼ç¬¦");
    printf("%-10s %-6s %-20s %s\n", "----", "----", "--------", "------");
    
    for (size_t i = 0; i < sizeof(integer_types)/sizeof(integer_types[0]); i++) {
        const integer_type_info_t* info = &integer_types[i];
        printf("%-10s %-6zu %-20s %s\n", 
               info->type_name, info->size_bytes, 
               info->use_case, info->format_specifier);
    }
    
    // å®é™…åº”ç”¨ç¤ºä¾‹
    printf("\nå®é™…åº”ç”¨ç¤ºä¾‹:\n");
    
    // ç½‘ç»œç¼–ç¨‹
    uint16_t port = 8080;
    uint32_t ip_addr = 0xC0A80001;  // 192.168.0.1
    printf("  ç½‘ç»œ: ç«¯å£=%" PRIu16 ", IP=0x%" PRIX32 "\n", port, ip_addr);
    
    // æ–‡ä»¶å¤„ç†
    uint64_t file_size = 1024ULL * 1024 * 1024 * 4;  // 4GB
    printf("  æ–‡ä»¶: å¤§å°=%" PRIu64 " å­—èŠ‚\n", file_size);
    
    // æ—¶é—´å¤„ç†
    int64_t timestamp_ms = 1640995200000LL;  // æ¯«ç§’æ—¶é—´æˆ³
    printf("  æ—¶é—´: æ—¶é—´æˆ³=%" PRId64 " ms\n", timestamp_ms);
}
```

#### 2.1.2 ç‰¹æ®Šç”¨é€”æ•´æ•°ç±»å‹

```c
#include <stddef.h>
#include <stdint.h>

void special_integer_types_demo(void) {
    printf("ç‰¹æ®Šç”¨é€”æ•´æ•°ç±»å‹:\n");
    
    // size_t - æ•°ç»„ç´¢å¼•å’Œå†…å­˜å¤§å°
    size_t array_size = 1000;
    size_t memory_usage = sizeof(int) * array_size;
    printf("  size_t: æ•°ç»„å¤§å°=%zu, å†…å­˜ä½¿ç”¨=%zuå­—èŠ‚\n", 
           array_size, memory_usage);
    
    // ptrdiff_t - æŒ‡é’ˆå·®å€¼
    int arr[10];
    ptrdiff_t ptr_diff = &arr[9] - &arr[0];
    printf("  ptrdiff_t: æŒ‡é’ˆå·®å€¼=%td\n", ptr_diff);
    
    // intptr_t/uintptr_t - æŒ‡é’ˆä¸æ•´æ•°è½¬æ¢
    int value = 42;
    intptr_t ptr_as_int = (intptr_t)&value;
    int* int_as_ptr = (int*)ptr_as_int;
    printf("  intptr_t: æŒ‡é’ˆè½¬æ•´æ•°=0x%" PRIXPTR ", æ¢å¤å€¼=%d\n", 
           ptr_as_int, *int_as_ptr);
    
    // æœ€å°/æœ€å¿«ç±»å‹
    int_least32_t least32 = 1000000;    // è‡³å°‘32ä½çš„æœ€å°ç±»å‹
    int_fast16_t fast16 = 5000;         // è‡³å°‘16ä½çš„æœ€å¿«ç±»å‹
    printf("  least32=%d, fast16=%d\n", least32, fast16);
    
    // æœ€å¤§æ•´æ•°ç±»å‹
    intmax_t max_int = INTMAX_MAX;
    printf("  intmax_tæœ€å¤§å€¼: %" PRIdMAX "\n", max_int);
}
```

### 2.2 æµ®ç‚¹ç±»å‹çš„ç²¾å¯†æ§åˆ¶

```c
#include <float.h>
#include <math.h>
#include <fenv.h>

void advanced_floating_point_demo(void) {
    printf("æµ®ç‚¹ç±»å‹æ·±åº¦åˆ†æ:\n");
    
    // ç²¾åº¦æ¯”è¾ƒ
    printf("\nç²¾åº¦ç‰¹æ€§:\n");
    printf("  float:       %dä½æœ‰æ•ˆæ•°å­—, æŒ‡æ•°èŒƒå›´: %dåˆ°%d\n", 
           FLT_DIG, FLT_MIN_EXP, FLT_MAX_EXP);
    printf("  double:      %dä½æœ‰æ•ˆæ•°å­—, æŒ‡æ•°èŒƒå›´: %dåˆ°%d\n", 
           DBL_DIG, DBL_MIN_EXP, DBL_MAX_EXP);
    printf("  long double: %dä½æœ‰æ•ˆæ•°å­—, æŒ‡æ•°èŒƒå›´: %dåˆ°%d\n", 
           LDBL_DIG, LDBL_MIN_EXP, LDBL_MAX_EXP);
    
    // ç‰¹æ®Šå€¼å¤„ç†
    printf("\nç‰¹æ®Šå€¼å¤„ç†:\n");
    double pos_inf = INFINITY;
    double neg_inf = -INFINITY;
    double not_a_number = NAN;
    double zero = 0.0;
    double neg_zero = -0.0;
    
    printf("  æ­£æ— ç©·: %f, è´Ÿæ— ç©·: %f\n", pos_inf, neg_inf);
    printf("  NaN: %f, é›¶: %f, è´Ÿé›¶: %f\n", not_a_number, zero, neg_zero);
    printf("  NaNæ£€æµ‹: %s, æ— ç©·æ£€æµ‹: %s\n",
           isnan(not_a_number) ? "æ˜¯NaN" : "ä¸æ˜¯NaN",
           isinf(pos_inf) ? "æ˜¯æ— ç©·" : "ä¸æ˜¯æ— ç©·");
    
    // ç²¾åº¦é—®é¢˜æ¼”ç¤º
    printf("\nç²¾åº¦é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ:\n");
    float f1 = 0.1f, f2 = 0.2f, f3 = 0.3f;
    float sum = f1 + f2;
    
    printf("  0.1f + 0.2f = %.10f\n", sum);
    printf("  ç›´æ¥æ¯”è¾ƒ: %s\n", (sum == f3) ? "ç›¸ç­‰" : "ä¸ç›¸ç­‰");
    
    // epsilonæ¯”è¾ƒ
    const float EPSILON = FLT_EPSILON * 10;
    printf("  epsilonæ¯”è¾ƒ: %s (epsilon=%.2e)\n",
           (fabsf(sum - f3) < EPSILON) ? "ç›¸ç­‰" : "ä¸ç›¸ç­‰", EPSILON);
    
    // æµ®ç‚¹ç¯å¢ƒæ§åˆ¶
    printf("\næµ®ç‚¹ç¯å¢ƒæ§åˆ¶:\n");
    feclearexcept(FE_ALL_EXCEPT);
    
    double overflow_test = DBL_MAX * 2.0;
    if (fetestexcept(FE_OVERFLOW)) {
        printf("  æ£€æµ‹åˆ°æµ®ç‚¹æº¢å‡º\n");
    }
    
    printf("  å½“å‰èˆå…¥æ¨¡å¼: ");
    switch (fegetround()) {
        case FE_TONEAREST:  printf("å››èˆäº”å…¥\n"); break;
        case FE_DOWNWARD:   printf("å‘ä¸‹èˆå…¥\n"); break;
        case FE_UPWARD:     printf("å‘ä¸Šèˆå…¥\n"); break;
        case FE_TOWARDZERO: printf("å‘é›¶èˆå…¥\n"); break;
        default:            printf("æœªçŸ¥\n"); break;
    }
}
```

### 2.3 å­—ç¬¦ç±»å‹ä¸ç¼–ç å¤„ç†

```c
#include <ctype.h>
#include <locale.h>
#include <wchar.h>

void modern_character_handling_demo(void) {
    printf("ç°ä»£å­—ç¬¦å¤„ç†:\n");
    
    // åŸºæœ¬å­—ç¬¦ç±»å‹
    char ascii_char = 'A';
    unsigned char byte_value = 200;
    signed char signed_byte = -100;
    
    printf("\nå­—ç¬¦ç±»å‹å˜ä½“:\n");
    printf("  char 'A': å€¼=%d, å¤§å°=%zuå­—èŠ‚\n", ascii_char, sizeof(ascii_char));
    printf("  unsigned char: å€¼=%u, èŒƒå›´=0åˆ°%u\n", byte_value, UCHAR_MAX);
    printf("  signed char: å€¼=%d, èŒƒå›´=%dåˆ°%d\n", signed_byte, SCHAR_MIN, SCHAR_MAX);
    
    // å­—ç¬¦åˆ†ç±»å’Œè½¬æ¢
    printf("\nå­—ç¬¦åˆ†ç±»å‡½æ•°:\n");
    char test_chars[] = {'A', 'a', '5', ' ', '\n', '@'};
    const char* descriptions[] = {"å¤§å†™å­—æ¯", "å°å†™å­—æ¯", "æ•°å­—", "ç©ºæ ¼", "æ¢è¡Œ", "ç¬¦å·"};
    
    for (size_t i = 0; i < sizeof(test_chars); i++) {
        char c = test_chars[i];
        printf("  '%c' (%s): ", (c == '\n') ? '\\n' : c, descriptions[i]);
        printf("å­—æ¯=%s, æ•°å­—=%s, ç©ºç™½=%s, æ ‡ç‚¹=%s\n",
               isalpha(c) ? "æ˜¯" : "å¦",
               isdigit(c) ? "æ˜¯" : "å¦", 
               isspace(c) ? "æ˜¯" : "å¦",
               ispunct(c) ? "æ˜¯" : "å¦");
    }
    
    // å®½å­—ç¬¦æ”¯æŒ
    printf("\nå®½å­—ç¬¦æ”¯æŒ:\n");
    setlocale(LC_ALL, "");  // è®¾ç½®æœ¬åœ°åŒ–
    
    wchar_t wide_char = L'ä¸­';
    wchar_t wide_string[] = L"Hello, ä¸–ç•Œ!";
    
    printf("  å®½å­—ç¬¦å¤§å°: %zuå­—èŠ‚\n", sizeof(wchar_t));
    printf("  å®½å­—ç¬¦å€¼: %lc (Unicode: U+%04X)\n", wide_char, (unsigned)wide_char);
    printf("  å®½å­—ç¬¦ä¸²é•¿åº¦: %zuå­—ç¬¦\n", wcslen(wide_string));
    
    // UTF-8å¤„ç†ç¤ºä¾‹
    printf("\nUTF-8ç¼–ç å¤„ç†:\n");
    const char utf8_string[] = "Hello, ä¸–ç•Œ! ğŸŒ";
    printf("  UTF-8å­—ç¬¦ä¸²: %s\n", utf8_string);
    printf("  å­—èŠ‚é•¿åº¦: %zu, å­—ç¬¦é•¿åº¦éœ€è¦ä¸“é—¨è®¡ç®—\n", strlen(utf8_string));
}
```

## 3. ç°ä»£å˜é‡ç®¡ç†ä¸å†…å­˜å®‰å…¨

### 3.1 å˜é‡ç”Ÿå‘½å‘¨æœŸçš„æ·±åº¦ç†è§£

```c
#include <stdlib.h>
#include <string.h>

// ç”Ÿå‘½å‘¨æœŸæ¼”ç¤ºç»“æ„
typedef struct {
    int id;
    char name[32];
    double value;
} demo_object_t;

// å…¨å±€å˜é‡ - ç¨‹åºç”Ÿå‘½å‘¨æœŸ
static demo_object_t global_object = {1, "Global", 100.0};
static size_t object_counter = 0;

// æ„é€ å’Œææ„å‡½æ•°æ¨¡æ‹Ÿ
demo_object_t* create_object(int id, const char* name, double value) {
    demo_object_t* obj = malloc(sizeof(demo_object_t));
    if (obj == NULL) {
        return NULL;
    }
    
    obj->id = id;
    strncpy(obj->name, name, sizeof(obj->name) - 1);
    obj->name[sizeof(obj->name) - 1] = '\0';
    obj->value = value;
    
    object_counter++;
    printf("  åˆ›å»ºå¯¹è±¡: ID=%d, åç§°=%s, è®¡æ•°=%zu\n", 
           obj->id, obj->name, object_counter);
    
    return obj;
}

void destroy_object(demo_object_t** obj) {
    if (obj && *obj) {
        printf("  é”€æ¯å¯¹è±¡: ID=%d, åç§°=%s\n", (*obj)->id, (*obj)->name);
        free(*obj);
        *obj = NULL;  // é˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆ
        object_counter--;
    }
}

void variable_lifetime_demo(void) {
    printf("å˜é‡ç”Ÿå‘½å‘¨æœŸç®¡ç†:\n");
    
    // è‡ªåŠ¨å˜é‡ - æ ˆåˆ†é…
    demo_object_t stack_object = {2, "Stack", 200.0};
    printf("  æ ˆå¯¹è±¡: ID=%d, åœ°å€=%p\n", stack_object.id, (void*)&stack_object);
    
    // é™æ€å±€éƒ¨å˜é‡ - ç¨‹åºç”Ÿå‘½å‘¨æœŸï¼Œå‡½æ•°ä½œç”¨åŸŸ
    static demo_object_t static_object = {3, "Static", 300.0};
    static_object.value += 10.0;  // ä¿æŒçŠ¶æ€
    printf("  é™æ€å¯¹è±¡: ID=%d, å€¼=%.1f\n", static_object.id, static_object.value);
    
    // åŠ¨æ€åˆ†é… - æ‰‹åŠ¨ç®¡ç†
    demo_object_t* heap_object = create_object(4, "Heap", 400.0);
    if (heap_object) {
        printf("  å †å¯¹è±¡: ID=%d, åœ°å€=%p\n", heap_object->id, (void*)heap_object);
        destroy_object(&heap_object);
    }
    
    printf("  å…¨å±€å¯¹è±¡: ID=%d, åœ°å€=%p\n", global_object.id, (void*)&global_object);
    printf("  å½“å‰å¯¹è±¡è®¡æ•°: %zu\n", object_counter);
}
```

### 3.2 ç°ä»£å­˜å‚¨ç±»åˆ«ä¸ä¼˜åŒ–

```c
#include <stdatomic.h>
#include <threads.h>

// çº¿ç¨‹å±€éƒ¨å­˜å‚¨
_Thread_local int thread_counter = 0;

// åŸå­å˜é‡
_Atomic int atomic_counter = 0;

// å¯„å­˜å™¨æç¤º
void register_optimization_demo(void) {
    printf("å­˜å‚¨ç±»åˆ«ä¼˜åŒ–:\n");
    
    // å¯„å­˜å™¨å˜é‡ - ç¼–è¯‘å™¨ä¼˜åŒ–æç¤º
    register int loop_var;
    register const int limit = 1000000;
    
    // æ€§èƒ½å…³é”®å¾ªç¯
    clock_t start = clock();
    for (loop_var = 0; loop_var < limit; loop_var++) {
        // ç©ºå¾ªç¯ï¼Œæµ‹è¯•å¯„å­˜å™¨ä¼˜åŒ–æ•ˆæœ
    }
    clock_t end = clock();
    
    printf("  å¯„å­˜å™¨ä¼˜åŒ–å¾ªç¯: %dæ¬¡, è€—æ—¶: %.2fms\n", 
           limit, ((double)(end - start) / CLOCKS_PER_SEC) * 1000);
    
    // çº¿ç¨‹å±€éƒ¨å­˜å‚¨
    thread_counter++;
    printf("  çº¿ç¨‹å±€éƒ¨è®¡æ•°å™¨: %d\n", thread_counter);
    
    // åŸå­æ“ä½œ
    int old_value = atomic_fetch_add(&atomic_counter, 1);
    printf("  åŸå­è®¡æ•°å™¨: æ—§å€¼=%d, æ–°å€¼=%d\n", 
           old_value, atomic_load(&atomic_counter));
}
```

### 3.3 å®‰å…¨åˆå§‹åŒ–æ¨¡å¼

```c
#include <string.h>
#include <assert.h>

// å®‰å…¨åˆå§‹åŒ–å®
#define SAFE_INIT(type) {0}
#define ARRAY_INIT(arr, val) memset(arr, val, sizeof(arr))

// åˆå§‹åŒ–éªŒè¯
typedef struct {
    uint32_t magic;     // é­”æ•°ï¼ŒéªŒè¯åˆå§‹åŒ–
    bool initialized;
    int data[10];
    char name[64];
} safe_struct_t;

#define STRUCT_MAGIC 0xDEADBEEF

// å®‰å…¨çš„ç»“æ„ä½“åˆå§‹åŒ–
safe_struct_t create_safe_struct(const char* name) {
    safe_struct_t s = SAFE_INIT(safe_struct_t);
    
    s.magic = STRUCT_MAGIC;
    s.initialized = true;
    
    // å®‰å…¨çš„å­—ç¬¦ä¸²å¤åˆ¶
    if (name) {
        size_t name_len = strlen(name);
        size_t copy_len = (name_len < sizeof(s.name) - 1) ? 
                         name_len : sizeof(s.name) - 1;
        memcpy(s.name, name, copy_len);
        s.name[copy_len] = '\0';
    }
    
    // åˆå§‹åŒ–æ•°ç»„
    for (size_t i = 0; i < sizeof(s.data)/sizeof(s.data[0]); i++) {
        s.data[i] = (int)i;
    }
    
    return s;
}

// éªŒè¯ç»“æ„ä½“å®Œæ•´æ€§
bool validate_struct(const safe_struct_t* s) {
    return s && 
           s->magic == STRUCT_MAGIC && 
           s->initialized;
}

void safe_initialization_demo(void) {
    printf("å®‰å…¨åˆå§‹åŒ–æ¨¡å¼:\n");
    
    // åŸºæœ¬ç±»å‹å®‰å…¨åˆå§‹åŒ–
    int safe_int = 0;                    // æ˜¾å¼åˆå§‹åŒ–
    double safe_double = 0.0;            // æ˜¾å¼åˆå§‹åŒ–
    char safe_char = '\0';               // æ˜¾å¼åˆå§‹åŒ–
    
    // æ•°ç»„å®‰å…¨åˆå§‹åŒ–
    int safe_array[10] = {0};            // å…¨éƒ¨åˆå§‹åŒ–ä¸º0
    char safe_buffer[256] = {0};         // å­—ç¬¦ä¸²ç¼“å†²åŒºæ¸…é›¶
    
    // ç»“æ„ä½“å®‰å…¨åˆå§‹åŒ–
    safe_struct_t my_struct = create_safe_struct("TestStruct");
    
    printf("  åŸºæœ¬ç±»å‹: int=%d, double=%.1f, char='%c'\n", 
           safe_int, safe_double, safe_char);
    printf("  æ•°ç»„é¦–å…ƒç´ : %d, ç¼“å†²åŒºé¦–å­—ç¬¦: %d\n", 
           safe_array[0], safe_buffer[0]);
    
    if (validate_struct(&my_struct)) {
        printf("  ç»“æ„ä½“éªŒè¯: é€šè¿‡, åç§°='%s'\n", my_struct.name);
    } else {
        printf("  ç»“æ„ä½“éªŒè¯: å¤±è´¥\n");
    }
    
    // C99æŒ‡å®šåˆå§‹åŒ–å™¨
    safe_struct_t designated_init = {
        .magic = STRUCT_MAGIC,
        .initialized = true,
        .name = "Designated",
        .data = {1, 2, 3}  // éƒ¨åˆ†åˆå§‹åŒ–ï¼Œå…¶ä½™ä¸º0
    };
    
    printf("  æŒ‡å®šåˆå§‹åŒ–: åç§°='%s', data[0]=%d, data[9]=%d\n",
           designated_init.name, designated_init.data[0], designated_init.data[9]);
}
```

### 3.4 ä½œç”¨åŸŸç®¡ç†ä¸å‘½åç©ºé—´æ¨¡æ‹Ÿ

```c
// å‘½åç©ºé—´æ¨¡æ‹Ÿ - ä½¿ç”¨å‰ç¼€
typedef struct {
    int value;
} math_vector_t;

typedef struct {
    char* data;
    size_t length;
} string_vector_t;

// æ•°å­¦å‘½åç©ºé—´
namespace_math_vector_t math_create_vector(int value) {
    math_vector_t v = {value};
    return v;
}

void math_print_vector(const math_vector_t* v) {
    printf("Math Vector: %d\n", v->value);
}

// å­—ç¬¦ä¸²å‘½åç©ºé—´
string_vector_t string_create_vector(const char* data) {
    string_vector_t v = {0};
    if (data) {
        v.length = strlen(data);
        v.data = malloc(v.length + 1);
        if (v.data) {
            strcpy(v.data, data);
        }
    }
    return v;
}

void string_destroy_vector(string_vector_t* v) {
    if (v && v->data) {
        free(v->data);
        v->data = NULL;
        v->length = 0;
    }
}

void scope_management_demo(void) {
    printf("ä½œç”¨åŸŸç®¡ç†æ¼”ç¤º:\n");
    
    // å—ä½œç”¨åŸŸå˜é‡
    {
        int block_var = 100;
        printf("  å—ä½œç”¨åŸŸ: block_var = %d\n", block_var);
        
        // å†…å±‚å—
        {
            int inner_var = 200;
            block_var += inner_var;  // å¯ä»¥è®¿é—®å¤–å±‚å˜é‡
            printf("  å†…å±‚å—: inner_var = %d, block_var = %d\n", 
                   inner_var, block_var);
        }
        // inner_var åœ¨æ­¤å¤„ä¸å¯è®¿é—®
        
        printf("  å¤–å±‚å—: block_var = %d\n", block_var);
    }
    // block_var åœ¨æ­¤å¤„ä¸å¯è®¿é—®
    
    // å‘½åç©ºé—´æ¨¡æ‹Ÿ
    math_vector_t math_vec = math_create_vector(42);
    string_vector_t str_vec = string_create_vector("Hello");
    
    printf("  å‘½åç©ºé—´æ¨¡æ‹Ÿ:\n");
    printf("    ");
    math_print_vector(&math_vec);
    printf("    String Vector: '%s' (é•¿åº¦: %zu)\n", 
           str_vec.data ? str_vec.data : "NULL", str_vec.length);
    
    string_destroy_vector(&str_vec);
}
```

## 4. ç°ä»£ç±»å‹è½¬æ¢ä¸å®‰å…¨ç¼–ç¨‹

### 4.1 ç±»å‹è½¬æ¢çš„æ·±åº¦åˆ†æ

```c
#include <stdint.h>
#include <limits.h>
#include <float.h>
#include <errno.h>

// å®‰å…¨è½¬æ¢ç»“æœç»“æ„
typedef enum {
    CONVERSION_SUCCESS,
    CONVERSION_OVERFLOW,
    CONVERSION_UNDERFLOW,
    CONVERSION_PRECISION_LOSS,
    CONVERSION_INVALID
} conversion_result_t;

typedef struct {
    conversion_result_t status;
    union {
        int64_t i64;
        uint64_t u64;
        double f64;
        char str[32];
    } value;
    char error_msg[128];
} safe_conversion_t;

// å®‰å…¨æ•´æ•°è½¬æ¢
safe_conversion_t safe_int_convert(int64_t value, int target_bits, bool is_signed) {
    safe_conversion_t result = {CONVERSION_SUCCESS, {0}, {0}};
    
    if (is_signed) {
        int64_t min_val = -(1LL << (target_bits - 1));
        int64_t max_val = (1LL << (target_bits - 1)) - 1;
        
        if (value < min_val) {
            result.status = CONVERSION_UNDERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "å€¼ %lld å°äº %d ä½æœ‰ç¬¦å·æ•´æ•°æœ€å°å€¼ %lld", 
                    value, target_bits, min_val);
        } else if (value > max_val) {
            result.status = CONVERSION_OVERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "å€¼ %lld å¤§äº %d ä½æœ‰ç¬¦å·æ•´æ•°æœ€å¤§å€¼ %lld", 
                    value, target_bits, max_val);
        } else {
            result.value.i64 = value;
        }
    } else {
        uint64_t max_val = (1ULL << target_bits) - 1;
        
        if (value < 0) {
            result.status = CONVERSION_UNDERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "è´Ÿå€¼ %lld ä¸èƒ½è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°", value);
        } else if ((uint64_t)value > max_val) {
            result.status = CONVERSION_OVERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "å€¼ %lld å¤§äº %d ä½æ— ç¬¦å·æ•´æ•°æœ€å¤§å€¼ %llu", 
                    value, target_bits, max_val);
        } else {
            result.value.u64 = (uint64_t)value;
        }
    }
    
    return result;
}

// å®‰å…¨æµ®ç‚¹è½¬æ¢
safe_conversion_t safe_float_convert(double value, bool to_float) {
    safe_conversion_t result = {CONVERSION_SUCCESS, {0}, {0}};
    
    if (to_float) {
        if (value > FLT_MAX) {
            result.status = CONVERSION_OVERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "å€¼ %g è¶…å‡º float æœ€å¤§å€¼ %g", value, FLT_MAX);
        } else if (value < -FLT_MAX) {
            result.status = CONVERSION_UNDERFLOW;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "å€¼ %g è¶…å‡º float æœ€å°å€¼ %g", value, -FLT_MAX);
        } else if (fabs(value) < FLT_MIN && value != 0.0) {
            result.status = CONVERSION_PRECISION_LOSS;
            snprintf(result.error_msg, sizeof(result.error_msg),
                    "å€¼ %g å¯èƒ½ä¸¢å¤±ç²¾åº¦ï¼Œfloat æœ€å°æ­£å€¼ä¸º %g", value, FLT_MIN);
            result.value.f64 = value;
        } else {
            result.value.f64 = value;
        }
    } else {
        result.value.f64 = value;
    }
    
    return result;
}

void safe_conversion_demo(void) {
    printf("å®‰å…¨ç±»å‹è½¬æ¢æ¼”ç¤º:\n");
    
    // æ•´æ•°è½¬æ¢æµ‹è¯•
    int64_t test_values[] = {-129, -128, 127, 128, 32767, 32768, -32769};
    size_t num_tests = sizeof(test_values) / sizeof(test_values[0]);
    
    printf("  8ä½æœ‰ç¬¦å·æ•´æ•°è½¬æ¢:\n");
    for (size_t i = 0; i < num_tests; i++) {
        safe_conversion_t result = safe_int_convert(test_values[i], 8, true);
        printf("    %lld -> ", test_values[i]);
        if (result.status == CONVERSION_SUCCESS) {
            printf("æˆåŠŸ: %lld\n", result.value.i64);
        } else {
            printf("å¤±è´¥: %s\n", result.error_msg);
        }
    }
    
    // æµ®ç‚¹è½¬æ¢æµ‹è¯•
    double float_tests[] = {3.4e38, 3.5e38, 1.2e-38, 1.0e-45};
    printf("  double åˆ° float è½¬æ¢:\n");
    for (size_t i = 0; i < 4; i++) {
        safe_conversion_t result = safe_float_convert(float_tests[i], true);
        printf("    %g -> ", float_tests[i]);
        if (result.status == CONVERSION_SUCCESS) {
            printf("æˆåŠŸ: %g\n", result.value.f64);
        } else {
            printf("%s: %s\n", 
                   result.status == CONVERSION_PRECISION_LOSS ? "è­¦å‘Š" : "å¤±è´¥",
                   result.error_msg);
        }
    }
}
```

### 4.2 ç°ä»£å­—é¢é‡ä¸å¸¸é‡å®šä¹‰

```c
#include <stddef.h>

// ç°ä»£å¸¸é‡å®šä¹‰æ–¹å¼
typedef enum {
    // ä½¿ç”¨æšä¸¾å®šä¹‰æ•´æ•°å¸¸é‡
    BUFFER_SIZE = 1024,
    MAX_CONNECTIONS = 100,
    TIMEOUT_SECONDS = 30,
    
    // ä½æ ‡å¿—
    FLAG_READ    = 1 << 0,  // 0x01
    FLAG_WRITE   = 1 << 1,  // 0x02
    FLAG_EXECUTE = 1 << 2,  // 0x04
    FLAG_ALL     = FLAG_READ | FLAG_WRITE | FLAG_EXECUTE
} constants_t;

// ç±»å‹å®‰å…¨çš„å¸¸é‡
static const size_t ARRAY_CAPACITY = 256;
static const double PI = 3.14159265358979323846;
static const char* const DEFAULT_CONFIG_FILE = "config.ini";

// ç¼–è¯‘æ—¶å¸¸é‡è¡¨è¾¾å¼ (C11)
#define STATIC_ASSERT(cond, msg) _Static_assert(cond, msg)

// éªŒè¯å¸¸é‡çš„åˆç†æ€§
STATIC_ASSERT(BUFFER_SIZE > 0, "ç¼“å†²åŒºå¤§å°å¿…é¡»ä¸ºæ­£æ•°");
STATIC_ASSERT(MAX_CONNECTIONS <= 1000, "è¿æ¥æ•°ä¸åº”è¶…è¿‡1000");
STATIC_ASSERT(sizeof(void*) == sizeof(uintptr_t), "æŒ‡é’ˆå¤§å°ä¸åŒ¹é…");

// å­—é¢é‡æ¼”ç¤º
void modern_literals_demo(void) {
    printf("ç°ä»£å­—é¢é‡ä¸å¸¸é‡:\n");
    
    // æ•´æ•°å­—é¢é‡ (C23 å¢å¼º)
    int decimal = 42;
    int octal = 052;           // å…«è¿›åˆ¶
    int hex = 0x2A;            // åå…­è¿›åˆ¶
    int binary = 0b101010;     // äºŒè¿›åˆ¶ (C23)
    
    // æ•°å­—åˆ†éš”ç¬¦ (C23)
    long large_num = 1'000'000;
    uint64_t big_hex = 0xFF'FF'FF'FF;
    
    // æµ®ç‚¹å­—é¢é‡
    double scientific = 1.23e-4;
    double hex_float = 0x1.FFFFFEp+62;  // åå…­è¿›åˆ¶æµ®ç‚¹
    
    // å­—ç¬¦å­—é¢é‡
    char ascii_char = 'A';
    char escape_char = '\n';
    char hex_char = '\x41';     // åå…­è¿›åˆ¶è½¬ä¹‰
    char unicode = '\u0041';    // Unicodeè½¬ä¹‰
    
    // å­—ç¬¦ä¸²å­—é¢é‡
    const char* simple_str = "Hello";
    const char* multiline_str = "Line 1\n"
                               "Line 2\n"
                               "Line 3";
    
    // å®½å­—ç¬¦å’ŒUTFå­—ç¬¦ä¸²
    const wchar_t* wide_str = L"å®½å­—ç¬¦ä¸²";
    const char* utf8_str = u8"UTF-8 å­—ç¬¦ä¸²";
    const char16_t* utf16_str = u"UTF-16 å­—ç¬¦ä¸²";
    const char32_t* utf32_str = U"UTF-32 å­—ç¬¦ä¸²";
    
    printf("  æ•´æ•°å­—é¢é‡: %d, %d, %d, %d\n", decimal, octal, hex, binary);
    printf("  å¤§æ•°å­—: %ld, 0x%lX\n", large_num, big_hex);
    printf("  æµ®ç‚¹æ•°: %g, %a\n", scientific, hex_float);
    printf("  å­—ç¬¦: '%c', '\\x%02X', '\\u%04X'\n", ascii_char, hex_char, unicode);
    printf("  å­—ç¬¦ä¸²: \"%s\"\n", simple_str);
    printf("  å¤šè¡Œå­—ç¬¦ä¸²:\n%s", multiline_str);
    
    // å¸¸é‡ä½¿ç”¨
    printf("  æšä¸¾å¸¸é‡: BUFFER_SIZE=%d, FLAG_ALL=0x%X\n", 
           BUFFER_SIZE, FLAG_ALL);
    printf("  ç±»å‹å®‰å…¨å¸¸é‡: å®¹é‡=%zu, Ï€=%.6f\n", ARRAY_CAPACITY, PI);
    printf("  å­—ç¬¦ä¸²å¸¸é‡: \"%s\"\n", DEFAULT_CONFIG_FILE);
}
```

### 4.3 ç¬¦å·å¸¸é‡çš„æœ€ä½³å®è·µ

```c
// ä¼ ç»Ÿå®å®šä¹‰çš„é—®é¢˜å’Œæ”¹è¿›
#define OLD_MAX(a, b) ((a) > (b) ? (a) : (b))  // å¯èƒ½é‡å¤æ±‚å€¼

// ç°ä»£ç±»å‹å®‰å…¨å®
#define SAFE_MAX(a, b) ({          \
    __typeof__(a) _a = (a);        \
    __typeof__(b) _b = (b);        \
    (_a > _b) ? _a : _b;           \
})

// æ¡ä»¶ç¼–è¯‘å¸¸é‡
#ifdef DEBUG
    #define LOG_LEVEL 3
    #define ENABLE_ASSERTIONS 1
#else
    #define LOG_LEVEL 1
    #define ENABLE_ASSERTIONS 0
#endif

// å¹³å°ç›¸å…³å¸¸é‡
#if defined(_WIN32)
    #define PATH_SEPARATOR '\\'
    #define LINE_ENDING "\r\n"
#elif defined(__unix__) || defined(__APPLE__)
    #define PATH_SEPARATOR '/'
    #define LINE_ENDING "\n"
#else
    #error "ä¸æ”¯æŒçš„å¹³å°"
#endif

// åŠŸèƒ½æµ‹è¯•å®
#if __STDC_VERSION__ >= 201112L
    #define HAS_C11_FEATURES 1
    #define THREAD_LOCAL _Thread_local
#else
    #define HAS_C11_FEATURES 0
    #define THREAD_LOCAL static
#endif

// é…ç½®ç»“æ„ä½“
typedef struct {
    const char* name;
    int value;
    const char* description;
} config_item_t;

static const config_item_t CONFIG_ITEMS[] = {
    {"buffer_size", BUFFER_SIZE, "é»˜è®¤ç¼“å†²åŒºå¤§å°"},
    {"max_connections", MAX_CONNECTIONS, "æœ€å¤§è¿æ¥æ•°"},
    {"timeout", TIMEOUT_SECONDS, "è¶…æ—¶æ—¶é—´(ç§’)"},
    {"log_level", LOG_LEVEL, "æ—¥å¿—çº§åˆ«"},
    {NULL, 0, NULL}  // å“¨å…µå€¼
};

void symbolic_constants_demo(void) {
    printf("ç¬¦å·å¸¸é‡æœ€ä½³å®è·µ:\n");
    
    // å®ä½¿ç”¨å¯¹æ¯”
    int x = 10, y = 20;
    printf("  ä¼ ç»Ÿå® OLD_MAX(%d, %d) = %d\n", x, y, OLD_MAX(x, y));
    printf("  å®‰å…¨å® SAFE_MAX(%d, %d) = %d\n", x, y, SAFE_MAX(x, y));
    
    // æ¡ä»¶ç¼–è¯‘ç»“æœ
    printf("  ç¼–è¯‘é…ç½®:\n");
    printf("    è°ƒè¯•æ¨¡å¼: %s\n", DEBUG ? "å¼€å¯" : "å…³é—­");
    printf("    æ—¥å¿—çº§åˆ«: %d\n", LOG_LEVEL);
    printf("    æ–­è¨€: %s\n", ENABLE_ASSERTIONS ? "å¯ç”¨" : "ç¦ç”¨");
    
    // å¹³å°ç›¸å…³
    printf("  å¹³å°é…ç½®:\n");
    printf("    è·¯å¾„åˆ†éš”ç¬¦: '%c'\n", PATH_SEPARATOR);
    printf("    è¡Œç»“æŸç¬¦: \"%s\" (é•¿åº¦: %zu)\n", 
           LINE_ENDING, strlen(LINE_ENDING));
    
    // Cæ ‡å‡†ç‰¹æ€§
    printf("  Cæ ‡å‡†ç‰¹æ€§:\n");
    printf("    C11ç‰¹æ€§: %s\n", HAS_C11_FEATURES ? "æ”¯æŒ" : "ä¸æ”¯æŒ");
    
    // é…ç½®é¡¹éå†
    printf("  é…ç½®é¡¹åˆ—è¡¨:\n");
    for (const config_item_t* item = CONFIG_ITEMS; item->name; item++) {
        printf("    %s = %d (%s)\n", 
               item->name, item->value, item->description);
    }
}
```

### 4.4 å˜é‡ä½œç”¨åŸŸçš„ç°ä»£ç®¡ç†

```c
#include <pthread.h>

// å…¨å±€ä½œç”¨åŸŸç®¡ç†
typedef struct {
    const char* module_name;
    int (*init_func)(void);
    void (*cleanup_func)(void);
    bool initialized;
} module_registry_t;

// æ¨¡å—åˆå§‹åŒ–å‡½æ•°
static int network_init(void) {
    printf("    ç½‘ç»œæ¨¡å—åˆå§‹åŒ–\n");
    return 0;
}

static void network_cleanup(void) {
    printf("    ç½‘ç»œæ¨¡å—æ¸…ç†\n");
}

static int database_init(void) {
    printf("    æ•°æ®åº“æ¨¡å—åˆå§‹åŒ–\n");
    return 0;
}

static void database_cleanup(void) {
    printf("    æ•°æ®åº“æ¨¡å—æ¸…ç†\n");
}

// æ¨¡å—æ³¨å†Œè¡¨
static module_registry_t g_modules[] = {
    {"network", network_init, network_cleanup, false},
    {"database", database_init, database_cleanup, false},
    {NULL, NULL, NULL, false}
};

// çº¿ç¨‹å±€éƒ¨å­˜å‚¨
THREAD_LOCAL int thread_id = 0;
THREAD_LOCAL char thread_name[32] = {0};

// ä½œç”¨åŸŸç®¡ç†å‡½æ•°
void initialize_modules(void) {
    printf("  æ¨¡å—åˆå§‹åŒ–:\n");
    for (module_registry_t* mod = g_modules; mod->module_name; mod++) {
        if (!mod->initialized && mod->init_func) {
            if (mod->init_func() == 0) {
                mod->initialized = true;
            }
        }
    }
}

void cleanup_modules(void) {
    printf("  æ¨¡å—æ¸…ç†:\n");
    for (module_registry_t* mod = g_modules; mod->module_name; mod++) {
        if (mod->initialized && mod->cleanup_func) {
            mod->cleanup_func();
            mod->initialized = false;
        }
    }
}

// RAIIæ¨¡å¼æ¨¡æ‹Ÿ
typedef struct {
    void* resource;
    void (*destructor)(void*);
} scoped_resource_t;

#define SCOPED_RESOURCE(var, res, dtor) \
    scoped_resource_t var __attribute__((cleanup(cleanup_scoped_resource))) = \
        {(res), (dtor)}

static void cleanup_scoped_resource(scoped_resource_t* res) {
    if (res && res->resource && res->destructor) {
        res->destructor(res->resource);
    }
}

static void free_wrapper(void* ptr) {
    free(ptr);
    printf("    è‡ªåŠ¨é‡Šæ”¾å†…å­˜\n");
}

void scope_management_advanced_demo(void) {
    printf("é«˜çº§ä½œç”¨åŸŸç®¡ç†:\n");
    
    // æ¨¡å—ç”Ÿå‘½å‘¨æœŸç®¡ç†
    initialize_modules();
    
    // çº¿ç¨‹å±€éƒ¨å­˜å‚¨
    thread_id = 12345;
    snprintf(thread_name, sizeof(thread_name), "WorkerThread-%d", thread_id);
    printf("  çº¿ç¨‹ä¿¡æ¯: ID=%d, åç§°='%s'\n", thread_id, thread_name);
    
    // å—ä½œç”¨åŸŸä¸è‡ªåŠ¨æ¸…ç†
    {
        printf("  è¿›å…¥ä½œç”¨åŸŸå—\n");
        
        // è‡ªåŠ¨å†…å­˜ç®¡ç† (éœ€è¦GCCæ‰©å±•)
        #ifdef __GNUC__
        char* buffer = malloc(256);
        if (buffer) {
            strcpy(buffer, "è‡ªåŠ¨ç®¡ç†çš„å†…å­˜");
            printf("    åˆ†é…å†…å­˜: '%s'\n", buffer);
            
            SCOPED_RESOURCE(scoped_buf, buffer, free_wrapper);
            // buffer å°†åœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾
        }
        #else
        printf("    (è‡ªåŠ¨æ¸…ç†éœ€è¦GCCç¼–è¯‘å™¨æ”¯æŒ)\n");
        #endif
        
        printf("  ç¦»å¼€ä½œç”¨åŸŸå—\n");
    }
    
    cleanup_modules();
}
```

## 5. ç°ä»£Cè¯­è¨€å®è·µæŒ‡å—ä¸æ€§èƒ½ä¼˜åŒ–

### 5.1 æ™ºèƒ½ç±»å‹é€‰æ‹©ç­–ç•¥

```c
#include <stdint.h>
#include <stdbool.h>
#include <time.h>

// ç±»å‹é€‰æ‹©å†³ç­–æ ‘
typedef enum {
    TYPE_CHOICE_RANGE,      // åŸºäºæ•°æ®èŒƒå›´
    TYPE_CHOICE_PERFORMANCE,// åŸºäºæ€§èƒ½éœ€æ±‚
    TYPE_CHOICE_PORTABILITY,// åŸºäºå¯ç§»æ¤æ€§
    TYPE_CHOICE_SAFETY      // åŸºäºå®‰å…¨æ€§
} type_choice_criteria_t;

// ç±»å‹é€‰æ‹©å»ºè®®ç»“æ„
typedef struct {
    const char* use_case;
    const char* recommended_type;
    const char* reason;
    size_t size_bytes;
    const char* range_info;
} type_recommendation_t;

static const type_recommendation_t TYPE_RECOMMENDATIONS[] = {
    // æ•´æ•°ç±»å‹å»ºè®®
    {"åƒç´ å€¼/é¢œè‰²åˆ†é‡", "uint8_t", "èŒƒå›´0-255ï¼ŒèŠ‚çœå†…å­˜", 1, "0 åˆ° 255"},
    {"éŸ³é¢‘é‡‡æ ·", "int16_t", "CDè´¨é‡éŸ³é¢‘æ ‡å‡†", 2, "-32,768 åˆ° 32,767"},
    {"æ–‡ä»¶å¤§å°", "uint64_t", "æ”¯æŒå¤§æ–‡ä»¶", 8, "0 åˆ° 18EB"},
    {"æ•°ç»„ç´¢å¼•", "size_t", "ä¸ç³»ç»ŸæŒ‡é’ˆå¤§å°åŒ¹é…", sizeof(size_t), "0 åˆ° SIZE_MAX"},
    {"å¾ªç¯è®¡æ•°å™¨", "int", "CPUåŸç”Ÿç±»å‹ï¼Œæ€§èƒ½æœ€ä½³", sizeof(int), "é€šå¸¸32ä½"},
    {"ç½‘ç»œåè®®é•¿åº¦", "uint32_t", "ç½‘ç»œå­—èŠ‚åºå…¼å®¹", 4, "0 åˆ° 4GB"},
    {"æ—¶é—´æˆ³(æ¯«ç§’)", "uint64_t", "è¶³å¤Ÿæœªæ¥å‡ åƒå¹´", 8, "0 åˆ° 584,942,417å¹´"},
    {"é”™è¯¯ç ", "int", "å…¼å®¹ç³»ç»Ÿè°ƒç”¨çº¦å®š", sizeof(int), "è´Ÿæ•°è¡¨ç¤ºé”™è¯¯"},
    
    // æµ®ç‚¹ç±»å‹å»ºè®®
    {"3Dåæ ‡", "float", "GPUå‹å¥½ï¼Œç²¾åº¦è¶³å¤Ÿ", 4, "Â±3.4e38, 7ä½ç²¾åº¦"},
    {"ç§‘å­¦è®¡ç®—", "double", "é«˜ç²¾åº¦éœ€æ±‚", 8, "Â±1.8e308, 15ä½ç²¾åº¦"},
    {"é‡‘èè®¡ç®—", "long double", "æœ€é«˜ç²¾åº¦", sizeof(long double), "å¹³å°ç›¸å…³"},
    
    {NULL, NULL, NULL, 0, NULL}
};

// æ€§èƒ½åŸºå‡†æµ‹è¯•
typedef struct {
    const char* type_name;
    size_t iterations;
    double time_ms;
    double ops_per_sec;
} performance_result_t;

performance_result_t benchmark_integer_types(void) {
    const size_t ITERATIONS = 10000000;
    clock_t start, end;
    
    // æµ‹è¯•intæ€§èƒ½
    start = clock();
    volatile int int_sum = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        int_sum += i;
    }
    end = clock();
    
    double time_ms = ((double)(end - start) / CLOCKS_PER_SEC) * 1000;
    double ops_per_sec = ITERATIONS / (time_ms / 1000);
    
    return (performance_result_t){
        "int", ITERATIONS, time_ms, ops_per_sec
    };
}

void intelligent_type_selection_demo(void) {
    printf("æ™ºèƒ½ç±»å‹é€‰æ‹©ç­–ç•¥:\n");
    
    // æ˜¾ç¤ºç±»å‹å»ºè®®è¡¨
    printf("  ç±»å‹é€‰æ‹©å»ºè®®è¡¨:\n");
    printf("  %-20s %-15s %-8s %-25s %s\n", 
           "ç”¨é€”", "æ¨èç±»å‹", "å¤§å°", "èŒƒå›´", "ç†ç”±");
    printf("  %s\n", "--------------------------------------------------------------------------------");
    
    for (const type_recommendation_t* rec = TYPE_RECOMMENDATIONS; rec->use_case; rec++) {
        printf("  %-20s %-15s %zuå­—èŠ‚   %-25s %s\n",
               rec->use_case, rec->recommended_type, rec->size_bytes,
               rec->range_info, rec->reason);
    }
    
    // æ€§èƒ½åŸºå‡†æµ‹è¯•
    printf("\n  æ€§èƒ½åŸºå‡†æµ‹è¯•:\n");
    performance_result_t result = benchmark_integer_types();
    printf("    %s: %.2f ms, %.0f ops/sec\n", 
           result.type_name, result.time_ms, result.ops_per_sec);
    
    // å†…å­˜å¯¹é½åˆ†æ
    printf("\n  å†…å­˜å¯¹é½åˆ†æ:\n");
    struct unaligned_struct {
        char c;      // 1å­—èŠ‚
        double d;    // 8å­—èŠ‚
        char c2;     // 1å­—èŠ‚
    };
    
    struct aligned_struct {
        double d;    // 8å­—èŠ‚
        char c;      // 1å­—èŠ‚
        char c2;     // 1å­—èŠ‚
        // 6å­—èŠ‚å¡«å……
    };
    
    printf("    æœªä¼˜åŒ–ç»“æ„ä½“: %zuå­—èŠ‚\n", sizeof(struct unaligned_struct));
    printf("    ä¼˜åŒ–åç»“æ„ä½“: %zuå­—èŠ‚\n", sizeof(struct aligned_struct));
    printf("    èŠ‚çœå†…å­˜: %zuå­—èŠ‚\n", 
           sizeof(struct unaligned_struct) - sizeof(struct aligned_struct));
}
```

### 5.2 å®‰å…¨ç¼–ç¨‹æ¨¡å¼ä¸é”™è¯¯å¤„ç†

```c
#include <errno.h>
#include <assert.h>

// é”™è¯¯å¤„ç†æšä¸¾
typedef enum {
    RESULT_SUCCESS = 0,
    RESULT_NULL_POINTER,
    RESULT_INVALID_ARGUMENT,
    RESULT_BUFFER_OVERFLOW,
    RESULT_MEMORY_ERROR,
    RESULT_CONVERSION_ERROR
} result_code_t;

// ç»“æœåŒ…è£…å™¨
#define RESULT_TYPE(T) struct { result_code_t code; T value; }

typedef RESULT_TYPE(int) int_result_t;
typedef RESULT_TYPE(double) double_result_t;

// å®‰å…¨çš„å­—ç¬¦ä¸²åˆ°æ•´æ•°è½¬æ¢
int_result_t safe_str_to_int(const char* str) {
    int_result_t result = {RESULT_SUCCESS, 0};
    
    if (!str) {
        result.code = RESULT_NULL_POINTER;
        return result;
    }
    
    char* endptr;
    errno = 0;
    long val = strtol(str, &endptr, 10);
    
    if (errno == ERANGE || val > INT_MAX || val < INT_MIN) {
        result.code = RESULT_CONVERSION_ERROR;
        return result;
    }
    
    if (endptr == str || *endptr != '\0') {
        result.code = RESULT_INVALID_ARGUMENT;
        return result;
    }
    
    result.value = (int)val;
    return result;
}

// å®‰å…¨çš„æ•°ç»„è®¿é—®
#define SAFE_ARRAY_ACCESS(arr, idx, len, default_val) \
    (((idx) >= 0 && (idx) < (len)) ? (arr)[idx] : (default_val))

// è¾¹ç•Œæ£€æŸ¥å®
#define CHECK_BOUNDS(idx, len) \
    do { \
        if ((idx) < 0 || (idx) >= (len)) { \
            fprintf(stderr, "æ•°ç»„è¶Šç•Œ: ç´¢å¼•%d, é•¿åº¦%d, æ–‡ä»¶%s, è¡Œ%d\n", \
                    (int)(idx), (int)(len), __FILE__, __LINE__); \
            abort(); \
        } \
    } while(0)

// å†…å­˜å®‰å…¨åˆ†é…å™¨
void* safe_malloc(size_t size, const char* purpose) {
    if (size == 0) {
        fprintf(stderr, "è­¦å‘Š: å°è¯•åˆ†é…0å­—èŠ‚å†…å­˜ (%s)\n", purpose);
        return NULL;
    }
    
    void* ptr = malloc(size);
    if (!ptr) {
        fprintf(stderr, "å†…å­˜åˆ†é…å¤±è´¥: %zuå­—èŠ‚ (%s)\n", size, purpose);
        exit(EXIT_FAILURE);
    }
    
    // è°ƒè¯•æ¨¡å¼ä¸‹æ¸…é›¶å†…å­˜
    #ifdef DEBUG
    memset(ptr, 0, size);
    printf("åˆ†é…å†…å­˜: %p, %zuå­—èŠ‚ (%s)\n", ptr, size, purpose);
    #endif
    
    return ptr;
}

void safe_free(void** ptr) {
    if (ptr && *ptr) {
        #ifdef DEBUG
        printf("é‡Šæ”¾å†…å­˜: %p\n", *ptr);
        #endif
        free(*ptr);
        *ptr = NULL;  // é˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆ
    }
}

void safety_patterns_demo(void) {
    printf("å®‰å…¨ç¼–ç¨‹æ¨¡å¼æ¼”ç¤º:\n");
    
    // å®‰å…¨è½¬æ¢æµ‹è¯•
    const char* test_strings[] = {"123", "-456", "abc", "999999999999", NULL};
    printf("  å®‰å…¨å­—ç¬¦ä¸²è½¬æ¢:\n");
    
    for (size_t i = 0; i < sizeof(test_strings)/sizeof(test_strings[0]); i++) {
        int_result_t result = safe_str_to_int(test_strings[i]);
        printf("    \"%s\" -> ", test_strings[i] ? test_strings[i] : "NULL");
        
        switch (result.code) {
            case RESULT_SUCCESS:
                printf("æˆåŠŸ: %d\n", result.value);
                break;
            case RESULT_NULL_POINTER:
                printf("é”™è¯¯: ç©ºæŒ‡é’ˆ\n");
                break;
            case RESULT_INVALID_ARGUMENT:
                printf("é”™è¯¯: æ— æ•ˆå‚æ•°\n");
                break;
            case RESULT_CONVERSION_ERROR:
                printf("é”™è¯¯: è½¬æ¢å¤±è´¥\n");
                break;
            default:
                printf("é”™è¯¯: æœªçŸ¥é”™è¯¯\n");
        }
    }
    
    // å®‰å…¨æ•°ç»„è®¿é—®
    printf("\n  å®‰å…¨æ•°ç»„è®¿é—®:\n");
    int test_array[] = {10, 20, 30, 40, 50};
    size_t array_len = sizeof(test_array) / sizeof(test_array[0]);
    
    int indices[] = {0, 2, 5, -1};
    for (size_t i = 0; i < sizeof(indices)/sizeof(indices[0]); i++) {
        int idx = indices[i];
        int value = SAFE_ARRAY_ACCESS(test_array, idx, array_len, -1);
        printf("    ç´¢å¼•%d: %s -> %d\n", idx, 
               (idx >= 0 && idx < array_len) ? "æœ‰æ•ˆ" : "æ— æ•ˆ", value);
    }
    
    // å®‰å…¨å†…å­˜ç®¡ç†
    printf("\n  å®‰å…¨å†…å­˜ç®¡ç†:\n");
    char* buffer = (char*)safe_malloc(256, "æµ‹è¯•ç¼“å†²åŒº");
    strcpy(buffer, "å®‰å…¨åˆ†é…çš„å†…å­˜");
    printf("    ç¼“å†²åŒºå†…å®¹: '%s'\n", buffer);
    safe_free((void**)&buffer);
    printf("    ç¼“å†²åŒºå·²å®‰å…¨é‡Šæ”¾ï¼ŒæŒ‡é’ˆ: %p\n", (void*)buffer);
}
```

### 5.3 ç°ä»£è°ƒè¯•ä¸åˆ†æå·¥å…·é›†æˆ

```c
#include <stdarg.h>

// è°ƒè¯•çº§åˆ«
typedef enum {
    DEBUG_LEVEL_ERROR = 0,
    DEBUG_LEVEL_WARN  = 1,
    DEBUG_LEVEL_INFO  = 2,
    DEBUG_LEVEL_DEBUG = 3,
    DEBUG_LEVEL_TRACE = 4
} debug_level_t;

// å…¨å±€è°ƒè¯•çº§åˆ«
static debug_level_t g_debug_level = DEBUG_LEVEL_INFO;

// å½©è‰²è¾“å‡ºå®
#define COLOR_RED     "\033[31m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_RESET   "\033[0m"

// é«˜çº§è°ƒè¯•å®
#define DEBUG_PRINT(level, fmt, ...) \
    do { \
        if ((level) <= g_debug_level) { \
            const char* color = ""; \
            const char* level_str = ""; \
            switch(level) { \
                case DEBUG_LEVEL_ERROR: color = COLOR_RED; level_str = "ERROR"; break; \
                case DEBUG_LEVEL_WARN:  color = COLOR_YELLOW; level_str = "WARN "; break; \
                case DEBUG_LEVEL_INFO:  color = COLOR_GREEN; level_str = "INFO "; break; \
                case DEBUG_LEVEL_DEBUG: color = COLOR_BLUE; level_str = "DEBUG"; break; \
                case DEBUG_LEVEL_TRACE: color = COLOR_MAGENTA; level_str = "TRACE"; break; \
            } \
            fprintf(stderr, "%s[%s]%s %s:%d %s() - " fmt "%s\n", \
                    color, level_str, COLOR_RESET, \
                    __FILE__, __LINE__, __func__, ##__VA_ARGS__, COLOR_RESET); \
        } \
    } while(0)

// æ€§èƒ½åˆ†æå®
#define PROFILE_START(name) \
    clock_t _profile_start_##name = clock(); \
    DEBUG_PRINT(DEBUG_LEVEL_TRACE, "å¼€å§‹æ€§èƒ½åˆ†æ: %s", #name)

#define PROFILE_END(name) \
    do { \
        clock_t _profile_end_##name = clock(); \
        double _profile_time_##name = ((double)(_profile_end_##name - _profile_start_##name)) / CLOCKS_PER_SEC * 1000; \
        DEBUG_PRINT(DEBUG_LEVEL_INFO, "æ€§èƒ½åˆ†æ %s: %.2f ms", #name, _profile_time_##name); \
    } while(0)

// å†…å­˜æ³„æ¼æ£€æµ‹ (ç®€åŒ–ç‰ˆ)
#ifdef DEBUG_MEMORY
static size_t g_allocated_bytes = 0;
static size_t g_allocation_count = 0;

void* debug_malloc(size_t size, const char* file, int line) {
    void* ptr = malloc(size);
    if (ptr) {
        g_allocated_bytes += size;
        g_allocation_count++;
        DEBUG_PRINT(DEBUG_LEVEL_TRACE, "åˆ†é…å†…å­˜: %p, %zuå­—èŠ‚ (æ€»è®¡: %zuå­—èŠ‚, %zuæ¬¡åˆ†é…) at %s:%d", 
                   ptr, size, g_allocated_bytes, g_allocation_count, file, line);
    }
    return ptr;
}

void debug_free(void* ptr, const char* file, int line) {
    if (ptr) {
        g_allocation_count--;
        DEBUG_PRINT(DEBUG_LEVEL_TRACE, "é‡Šæ”¾å†…å­˜: %p (å‰©ä½™: %zuæ¬¡åˆ†é…) at %s:%d", 
                   ptr, g_allocation_count, file, line);
        free(ptr);
    }
}

#define malloc(size) debug_malloc(size, __FILE__, __LINE__)
#define free(ptr) debug_free(ptr, __FILE__, __LINE__)
#endif

// æ–­è¨€å¢å¼º
#define ASSERT_MSG(condition, msg, ...) \
    do { \
        if (!(condition)) { \
            DEBUG_PRINT(DEBUG_LEVEL_ERROR, "æ–­è¨€å¤±è´¥: " #condition); \
            DEBUG_PRINT(DEBUG_LEVEL_ERROR, msg, ##__VA_ARGS__); \
            abort(); \
        } \
    } while(0)

// é™æ€åˆ†æå‹å¥½çš„ä»£ç 
void modern_debugging_demo(void) {
    printf("ç°ä»£è°ƒè¯•ä¸åˆ†æå·¥å…·æ¼”ç¤º:\n");
    
    // è®¾ç½®è°ƒè¯•çº§åˆ«
    g_debug_level = DEBUG_LEVEL_TRACE;
    
    DEBUG_PRINT(DEBUG_LEVEL_INFO, "å¼€å§‹è°ƒè¯•æ¼”ç¤º");
    DEBUG_PRINT(DEBUG_LEVEL_DEBUG, "è°ƒè¯•çº§åˆ«è®¾ç½®ä¸º: %d", g_debug_level);
    
    // æ€§èƒ½åˆ†æç¤ºä¾‹
    PROFILE_START(sorting);
    
    // æ¨¡æ‹Ÿä¸€äº›å·¥ä½œ
    int test_array[] = {64, 34, 25, 12, 22, 11, 90};
    size_t n = sizeof(test_array) / sizeof(test_array[0]);
    
    DEBUG_PRINT(DEBUG_LEVEL_DEBUG, "æ’åºæ•°ç»„ï¼Œå¤§å°: %zu", n);
    
    // ç®€å•å†’æ³¡æ’åº
    for (size_t i = 0; i < n-1; i++) {
        for (size_t j = 0; j < n-i-1; j++) {
            if (test_array[j] > test_array[j+1]) {
                int temp = test_array[j];
                test_array[j] = test_array[j+1];
                test_array[j+1] = temp;
            }
        }
    }
    
    PROFILE_END(sorting);
    
    // æ–­è¨€æµ‹è¯•
    ASSERT_MSG(test_array[0] <= test_array[1], "æ•°ç»„æœªæ­£ç¡®æ’åº");
    DEBUG_PRINT(DEBUG_LEVEL_INFO, "æ’åºéªŒè¯é€šè¿‡");
    
    // å†…å­˜åˆ†æç¤ºä¾‹
    #ifdef DEBUG_MEMORY
    char* buffer1 = malloc(100);
    char* buffer2 = malloc(200);
    free(buffer1);
    free(buffer2);
    
    if (g_allocation_count == 0) {
        DEBUG_PRINT(DEBUG_LEVEL_INFO, "å†…å­˜æ³„æ¼æ£€æµ‹: é€šè¿‡");
    } else {
        DEBUG_PRINT(DEBUG_LEVEL_WARN, "å†…å­˜æ³„æ¼æ£€æµ‹: å‘ç°%zuä¸ªæœªé‡Šæ”¾çš„åˆ†é…", g_allocation_count);
    }
    #endif
    
    DEBUG_PRINT(DEBUG_LEVEL_INFO, "è°ƒè¯•æ¼”ç¤ºå®Œæˆ");
}
```

### 5.4 è·¨å¹³å°å…¼å®¹æ€§ä¸ç°ä»£Cæ ‡å‡†ç‰¹æ€§

```c
// å¹³å°æ£€æµ‹å®
#if defined(_WIN32) || defined(_WIN64)
    #define PLATFORM_WINDOWS
    #include <windows.h>
#elif defined(__linux__)
    #define PLATFORM_LINUX
    #include <unistd.h>
#elif defined(__APPLE__)
    #define PLATFORM_MACOS
    #include <unistd.h>
#else
    #define PLATFORM_UNKNOWN
#endif

// Cæ ‡å‡†ç‰ˆæœ¬æ£€æµ‹
#if __STDC_VERSION__ >= 202311L
    #define C_STANDARD "C23"
    #define HAS_C23_FEATURES 1
#elif __STDC_VERSION__ >= 201710L
    #define C_STANDARD "C18"
    #define HAS_C18_FEATURES 1
#elif __STDC_VERSION__ >= 201112L
    #define C_STANDARD "C11"
    #define HAS_C11_FEATURES 1
#elif __STDC_VERSION__ >= 199901L
    #define C_STANDARD "C99"
    #define HAS_C99_FEATURES 1
#else
    #define C_STANDARD "C90"
#endif

// ç¼–è¯‘å™¨ç‰¹æ€§æ£€æµ‹
#ifdef __GNUC__
    #define COMPILER_GCC
    #define FORCE_INLINE __attribute__((always_inline)) inline
    #define NO_RETURN __attribute__((noreturn))
    #define DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
    #define COMPILER_MSVC
    #define FORCE_INLINE __forceinline
    #define NO_RETURN __declspec(noreturn)
    #define DEPRECATED __declspec(deprecated)
#else
    #define FORCE_INLINE inline
    #define NO_RETURN
    #define DEPRECATED
#endif

// ç°ä»£Cç‰¹æ€§ä½¿ç”¨
#ifdef HAS_C11_FEATURES
    #include <stdatomic.h>
    #include <threads.h>
    
    // åŸå­æ“ä½œç¤ºä¾‹
    _Atomic int atomic_counter = 0;
    
    // çº¿ç¨‹å±€éƒ¨å­˜å‚¨
    _Thread_local int thread_local_var = 0;
    
    // é™æ€æ–­è¨€
    _Static_assert(sizeof(int) >= 4, "intç±»å‹è‡³å°‘éœ€è¦4å­—èŠ‚");
    
    // æ³›å‹å® (C11)
    #define MAX(x, y) _Generic((x), \
        int: max_int, \
        float: max_float, \
        double: max_double, \
        default: max_generic \
    )(x, y)
    
    int max_int(int a, int b) { return a > b ? a : b; }
    float max_float(float a, float b) { return a > b ? a : b; }
    double max_double(double a, double b) { return a > b ? a : b; }
    void* max_generic(void* a, void* b) { return a; } // å ä½ç¬¦
#endif

// è·¨å¹³å°æ—¶é—´å‡½æ•°
double get_time_seconds(void) {
    #ifdef PLATFORM_WINDOWS
        LARGE_INTEGER frequency, counter;
        QueryPerformanceFrequency(&frequency);
        QueryPerformanceCounter(&counter);
        return (double)counter.QuadPart / frequency.QuadPart;
    #else
        struct timespec ts;
        clock_gettime(CLOCK_MONOTONIC, &ts);
        return ts.tv_sec + ts.tv_nsec / 1e9;
    #endif
}

void cross_platform_demo(void) {
    printf("è·¨å¹³å°å…¼å®¹æ€§ä¸ç°ä»£Cç‰¹æ€§æ¼”ç¤º:\n");
    
    // å¹³å°ä¿¡æ¯
    printf("  å¹³å°ä¿¡æ¯:\n");
    #ifdef PLATFORM_WINDOWS
        printf("    æ“ä½œç³»ç»Ÿ: Windows\n");
    #elif defined(PLATFORM_LINUX)
        printf("    æ“ä½œç³»ç»Ÿ: Linux\n");
    #elif defined(PLATFORM_MACOS)
        printf("    æ“ä½œç³»ç»Ÿ: macOS\n");
    #else
        printf("    æ“ä½œç³»ç»Ÿ: æœªçŸ¥\n");
    #endif
    
    // ç¼–è¯‘å™¨ä¿¡æ¯
    printf("  ç¼–è¯‘å™¨ä¿¡æ¯:\n");
    #ifdef COMPILER_GCC
        printf("    ç¼–è¯‘å™¨: GCC %d.%d.%d\n", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);
    #elif defined(COMPILER_MSVC)
        printf("    ç¼–è¯‘å™¨: MSVC %d\n", _MSC_VER);
    #else
        printf("    ç¼–è¯‘å™¨: æœªçŸ¥\n");
    #endif
    
    // Cæ ‡å‡†ä¿¡æ¯
    printf("    Cæ ‡å‡†: %s\n", C_STANDARD);
    printf("    __STDC_VERSION__: %ld\n", __STDC_VERSION__);
    
    // ç±»å‹å¤§å°ä¿¡æ¯
    printf("  ç±»å‹å¤§å°ä¿¡æ¯:\n");
    printf("    char: %zuå­—èŠ‚\n", sizeof(char));
    printf("    int: %zuå­—èŠ‚\n", sizeof(int));
    printf("    long: %zuå­—èŠ‚\n", sizeof(long));
    printf("    long long: %zuå­—èŠ‚\n", sizeof(long long));
    printf("    void*: %zuå­—èŠ‚\n", sizeof(void*));
    printf("    size_t: %zuå­—èŠ‚\n", sizeof(size_t));
    
    // ç°ä»£Cç‰¹æ€§æ¼”ç¤º
    #ifdef HAS_C11_FEATURES
        printf("  C11ç‰¹æ€§æ¼”ç¤º:\n");
        
        // åŸå­æ“ä½œ
        int old_value = atomic_fetch_add(&atomic_counter, 5);
        printf("    åŸå­æ“ä½œ: æ—§å€¼=%d, æ–°å€¼=%d\n", old_value, atomic_load(&atomic_counter));
        
        // çº¿ç¨‹å±€éƒ¨å­˜å‚¨
        thread_local_var = 42;
        printf("    çº¿ç¨‹å±€éƒ¨å˜é‡: %d\n", thread_local_var);
        
        // æ³›å‹å®
        printf("    æ³›å‹å®: MAX(10, 20) = %d\n", MAX(10, 20));
        printf("    æ³›å‹å®: MAX(3.14f, 2.71f) = %.2f\n", MAX(3.14f, 2.71f));
    #else
        printf("  C11ç‰¹æ€§: ä¸æ”¯æŒ\n");
    #endif
    
    // é«˜ç²¾åº¦æ—¶é—´
    double start_time = get_time_seconds();
    // æ¨¡æ‹Ÿä¸€äº›å·¥ä½œ
    volatile int dummy = 0;
    for (int i = 0; i < 1000000; i++) {
        dummy += i;
    }
    double end_time = get_time_seconds();
    printf("  é«˜ç²¾åº¦è®¡æ—¶: %.6fç§’\n", end_time - start_time);
}
```

## 6. æ€»ç»“ä¸è¿›é˜¶æ–¹å‘

### 6.1 æ ¸å¿ƒçŸ¥è¯†ç‚¹æ€»ç»“

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œæˆ‘ä»¬æ·±å…¥æŒæ¡äº†ç°ä»£Cè¯­è¨€æ•°æ®ç±»å‹ä¸å˜é‡ç®¡ç†çš„æ ¸å¿ƒæ¦‚å¿µï¼š

#### ç±»å‹ç³»ç»Ÿç²¾è¦
- **ç°ä»£ç±»å‹é€‰æ‹©**: ä½¿ç”¨`stdint.h`å›ºå®šå®½åº¦ç±»å‹ç¡®ä¿è·¨å¹³å°ä¸€è‡´æ€§
- **å†…å­˜æ¨¡å‹ç†è§£**: æŒæ¡æ•°æ®åœ¨å†…å­˜ä¸­çš„è¡¨ç¤ºå’Œå¯¹é½è§„åˆ™
- **ç±»å‹å®‰å…¨ç¼–ç¨‹**: è¿ç”¨ç¼–è¯‘æ—¶æ£€æŸ¥å’Œè¿è¡Œæ—¶éªŒè¯ç¡®ä¿ç±»å‹å®‰å…¨

#### å˜é‡ç®¡ç†æœ€ä½³å®è·µ
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**: ç†è§£è‡ªåŠ¨ã€é™æ€ã€åŠ¨æ€å­˜å‚¨çš„ç‰¹ç‚¹å’Œé€‚ç”¨åœºæ™¯
- **ä½œç”¨åŸŸæ§åˆ¶**: åˆç†ä½¿ç”¨å—ä½œç”¨åŸŸå’Œå‘½åç©ºé—´æ¨¡æ‹ŸæŠ€æœ¯
- **å®‰å…¨åˆå§‹åŒ–**: é‡‡ç”¨é˜²å¾¡æ€§ç¼–ç¨‹æ¨¡å¼é¿å…æœªå®šä¹‰è¡Œä¸º

#### ç°ä»£Cç‰¹æ€§åº”ç”¨
- **C11/C18/C23ç‰¹æ€§**: åŸå­æ“ä½œã€çº¿ç¨‹å±€éƒ¨å­˜å‚¨ã€æ³›å‹å®ç­‰
- **è·¨å¹³å°å…¼å®¹**: æ¡ä»¶ç¼–è¯‘å’Œç‰¹æ€§æ£€æµ‹æŠ€æœ¯
- **è°ƒè¯•ä¸åˆ†æ**: é›†æˆç°ä»£å·¥å…·é“¾è¿›è¡Œæ€§èƒ½åˆ†æå’Œé”™è¯¯æ£€æµ‹

### 6.2 å®è·µåº”ç”¨æŒ‡å—

```c
// ç»¼åˆç¤ºä¾‹ï¼šç°ä»£Cæ•°æ®ç±»å‹æœ€ä½³å®è·µ
#include <stdint.h>
#include <stdbool.h>
#include <stdatomic.h>

// 1. ç±»å‹å®‰å…¨çš„é…ç½®ç³»ç»Ÿ
typedef struct {
    uint32_t magic;           // é­”æ•°éªŒè¯
    uint16_t version;         // ç‰ˆæœ¬å·
    bool debug_enabled;       // è°ƒè¯•å¼€å…³
    size_t buffer_size;       // ç¼“å†²åŒºå¤§å°
    double timeout_seconds;   // è¶…æ—¶æ—¶é—´
} config_t;

#define CONFIG_MAGIC 0xDEADBEEF
#define CONFIG_VERSION 1

// å®‰å…¨çš„é…ç½®åˆå§‹åŒ–
config_t create_safe_config(void) {
    return (config_t) {
        .magic = CONFIG_MAGIC,
        .version = CONFIG_VERSION,
        .debug_enabled = false,
        .buffer_size = 4096,
        .timeout_seconds = 30.0
    };
}

// 2. é«˜æ€§èƒ½è®¡æ•°å™¨ç³»ç»Ÿ
typedef struct {
    _Atomic uint64_t value;
    _Atomic uint64_t operations;
    const char* name;
} atomic_counter_t;

void counter_increment(atomic_counter_t* counter) {
    if (counter) {
        atomic_fetch_add(&counter->value, 1);
        atomic_fetch_add(&counter->operations, 1);
    }
}

uint64_t counter_get_value(const atomic_counter_t* counter) {
    return counter ? atomic_load(&counter->value) : 0;
}

// 3. å†…å­˜å®‰å…¨çš„å­—ç¬¦ä¸²å¤„ç†
typedef struct {
    char* data;
    size_t length;
    size_t capacity;
    uint32_t checksum;
} safe_string_t;

safe_string_t* safe_string_create(const char* initial) {
    if (!initial) return NULL;
    
    size_t len = strlen(initial);
    safe_string_t* str = malloc(sizeof(safe_string_t));
    if (!str) return NULL;
    
    str->capacity = len + 1;
    str->data = malloc(str->capacity);
    if (!str->data) {
        free(str);
        return NULL;
    }
    
    strcpy(str->data, initial);
    str->length = len;
    str->checksum = 0; // ç®€åŒ–çš„æ ¡éªŒå’Œ
    
    return str;
}

void safe_string_destroy(safe_string_t** str) {
    if (str && *str) {
        free((*str)->data);
        (*str)->data = NULL;
        free(*str);
        *str = NULL;
    }
}
```

### 6.3 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### å†…å­˜å¸ƒå±€ä¼˜åŒ–
```c
// ä¼˜åŒ–å‰ï¼šå†…å­˜æµªè´¹
struct inefficient_struct {
    char flag;        // 1å­—èŠ‚
    double value;     // 8å­—èŠ‚ (7å­—èŠ‚å¡«å……)
    int count;        // 4å­—èŠ‚
    char status;      // 1å­—èŠ‚ (3å­—èŠ‚å¡«å……)
};  // æ€»è®¡ï¼š24å­—èŠ‚

// ä¼˜åŒ–åï¼šç´§å‡‘å¸ƒå±€
struct efficient_struct {
    double value;     // 8å­—èŠ‚
    int count;        // 4å­—èŠ‚
    char flag;        // 1å­—èŠ‚
    char status;      // 1å­—èŠ‚
    // 2å­—èŠ‚å¡«å……
};  // æ€»è®¡ï¼š16å­—èŠ‚ï¼ŒèŠ‚çœ33%å†…å­˜
```

#### ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„
```c
// æ•°ç»„ç»“æ„ï¼ˆç¼“å­˜å‹å¥½ï¼‰
typedef struct {
    size_t count;
    int* values;      // è¿ç»­å†…å­˜
    char* flags;      // è¿ç»­å†…å­˜
} aos_data_t;        // Array of Structures

// ç»“æ„æ•°ç»„ï¼ˆå¯èƒ½å¯¼è‡´ç¼“å­˜æœªå‘½ä¸­ï¼‰
typedef struct {
    int value;
    char flag;
} soa_item_t;

typedef struct {
    size_t count;
    soa_item_t* items; // äº¤é”™å†…å­˜è®¿é—®
} soa_data_t;         // Structure of Arrays
```

### 6.4 è¿›é˜¶å­¦ä¹ è·¯å¾„

#### æ·±å…¥ç³»ç»Ÿç¼–ç¨‹
1. **å†…å­˜ç®¡ç†è¿›é˜¶**
   - è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨
   - å†…å­˜æ± æŠ€æœ¯
   - åƒåœ¾å›æ”¶ç®—æ³•

2. **å¹¶å‘ç¼–ç¨‹**
   - åŸå­æ“ä½œæ·±å…¥
   - æ— é”æ•°æ®ç»“æ„
   - å†…å­˜æ¨¡å‹ç†è§£

3. **æ€§èƒ½ä¼˜åŒ–**
   - CPUç¼“å­˜ä¼˜åŒ–
   - SIMDæŒ‡ä»¤é›†
   - ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯

#### ç°ä»£Cç”Ÿæ€ç³»ç»Ÿ
1. **æ„å»ºç³»ç»Ÿ**
   - CMakeé«˜çº§ç‰¹æ€§
   - åŒ…ç®¡ç†å·¥å…·
   - æŒç»­é›†æˆ

2. **è°ƒè¯•ä¸åˆ†æ**
   - Valgrindå†…å­˜æ£€æµ‹
   - AddressSanitizer
   - æ€§èƒ½åˆ†æå·¥å…·

3. **ä»£ç è´¨é‡**
   - é™æ€åˆ†æå·¥å…·
   - å•å…ƒæµ‹è¯•æ¡†æ¶
   - ä»£ç è¦†ç›–ç‡

### 6.5 å­¦ä¹ æ£€æŸ¥æ¸…å•

#### åŸºç¡€æŒæ¡ âœ“
- [ ] ç†è§£æ‰€æœ‰åŸºæœ¬æ•°æ®ç±»å‹çš„ç‰¹ç‚¹å’Œç”¨é€”
- [ ] æŒæ¡å˜é‡å£°æ˜ã€åˆå§‹åŒ–å’Œä½œç”¨åŸŸè§„åˆ™
- [ ] ç†Ÿç»ƒä½¿ç”¨ç±»å‹è½¬æ¢å’Œå¸¸é‡å®šä¹‰
- [ ] äº†è§£å†…å­˜å¯¹é½å’Œç»“æ„ä½“å¸ƒå±€

#### è¿›é˜¶åº”ç”¨ âœ“
- [ ] èƒ½å¤Ÿé€‰æ‹©åˆé€‚çš„æ•°æ®ç±»å‹è§£å†³å®é™…é—®é¢˜
- [ ] æŒæ¡å®‰å…¨ç¼–ç¨‹æ¨¡å¼å’Œé”™è¯¯å¤„ç†
- [ ] ç†è§£ç°ä»£Cæ ‡å‡†ç‰¹æ€§å’Œè·¨å¹³å°ç¼–ç¨‹
- [ ] å…·å¤‡æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•èƒ½åŠ›

#### å®æˆ˜é¡¹ç›® âœ“
- [ ] å®ç°ä¸€ä¸ªç±»å‹å®‰å…¨çš„é…ç½®ç³»ç»Ÿ
- [ ] å¼€å‘é«˜æ€§èƒ½çš„æ•°æ®ç»“æ„åº“
- [ ] æ„å»ºè·¨å¹³å°çš„å·¥å…·ç¨‹åº
- [ ] å‚ä¸å¼€æºCé¡¹ç›®è´¡çŒ®

é€šè¿‡ç³»ç»Ÿå­¦ä¹ å’Œå®è·µï¼Œä½ å°†å…·å¤‡ç°ä»£Cè¯­è¨€æ•°æ®ç±»å‹ä¸å˜é‡ç®¡ç†çš„ä¸“ä¸šèƒ½åŠ›ï¼Œä¸ºåç»­çš„é«˜çº§ä¸»é¢˜å­¦ä¹ æ‰“ä¸‹åšå®åŸºç¡€ã€‚è®°ä½ï¼Œä¼˜ç§€çš„Cç¨‹åºå‘˜ä¸ä»…è¦æŒæ¡è¯­æ³•ï¼Œæ›´è¦ç†è§£åº•å±‚åŸç†ï¼ŒåŸ¹å…»ç³»ç»Ÿæ€ç»´å’Œå·¥ç¨‹å®è·µèƒ½åŠ›ã€‚

