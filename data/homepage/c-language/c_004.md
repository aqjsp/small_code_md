# C语言指针与内存管理

## 学习目标

通过本章的深入学习，你将全面掌握：
- 指针的本质概念和计算机内存模型的深层理解
- 指针类型系统、指针运算和指针与数组的内在关系
- 动态内存管理的原理、最佳实践和常见陷阱
- 多级指针、函数指针和复杂数据结构的构建
- 指针安全编程技巧和内存调试方法
- 实际项目中指针应用的高级技巧和性能优化

## 1. 指针的本质与内存模型深度解析

### 1.1 计算机内存模型基础

理解指针的第一步是深入理解计算机的内存模型。内存可以看作是一个巨大的字节数组，每个字节都有唯一的地址。

```c
#include <stdio.h>
#include <stdint.h>

// 演示内存地址的基本概念
void memory_model_demo() {
    printf("=== 内存模型基础演示 ===\n");
    
    // 不同类型变量的内存布局
    char c = 'A';
    short s = 1000;
    int i = 100000;
    long l = 1000000L;
    float f = 3.14f;
    double d = 3.14159;
    
    printf("变量类型与内存地址:\n");
    printf("  char   c = '%c'    地址: %p, 大小: %zu字节\n", c, (void*)&c, sizeof(c));
    printf("  short  s = %d      地址: %p, 大小: %zu字节\n", s, (void*)&s, sizeof(s));
    printf("  int    i = %d     地址: %p, 大小: %zu字节\n", i, (void*)&i, sizeof(i));
    printf("  long   l = %ld    地址: %p, 大小: %zu字节\n", l, (void*)&l, sizeof(l));
    printf("  float  f = %.2f    地址: %p, 大小: %zu字节\n", f, (void*)&f, sizeof(f));
    printf("  double d = %.5f  地址: %p, 大小: %zu字节\n", d, (void*)&d, sizeof(d));
    
    // 内存对齐演示
    printf("\n内存对齐分析:\n");
    printf("  &c 到 &s 的距离: %ld字节\n", (char*)&s - (char*)&c);
    printf("  &s 到 &i 的距离: %ld字节\n", (char*)&i - (char*)&s);
    printf("  &i 到 &l 的距离: %ld字节\n", (char*)&l - (char*)&i);
    
    // 字节序演示（大端/小端）
    printf("\n字节序分析:\n");
    int test_value = 0x12345678;
    unsigned char* bytes = (unsigned char*)&test_value;
    printf("  整数 0x12345678 的字节存储顺序:\n");
    for (int j = 0; j < sizeof(int); j++) {
        printf("    字节%d: 0x%02X\n", j, bytes[j]);
    }
    
    // 判断字节序
    if (bytes[0] == 0x78) {
        printf("  系统使用小端字节序 (Little Endian)\n");
    } else {
        printf("  系统使用大端字节序 (Big Endian)\n");
    }
}

// 演示内存的不同区域
int global_var = 100;           // 全局变量 - 数据段
static int static_var = 200;    // 静态变量 - 数据段
const int const_var = 300;     // 常量 - 只读数据段

void memory_regions_demo() {
    printf("\n=== 内存区域分析 ===\n");
    
    int local_var = 400;        // 局部变量 - 栈
    static int local_static = 500; // 局部静态变量 - 数据段
    
    // 动态分配 - 堆
    int* heap_var = malloc(sizeof(int));
    *heap_var = 600;
    
    printf("不同内存区域的变量地址:\n");
    printf("  全局变量     global_var:     %p\n", (void*)&global_var);
    printf("  静态变量     static_var:     %p\n", (void*)&static_var);
    printf("  常量         const_var:      %p\n", (void*)&const_var);
    printf("  局部变量     local_var:      %p\n", (void*)&local_var);
    printf("  局部静态变量 local_static:   %p\n", (void*)&local_static);
    printf("  堆变量       heap_var:       %p\n", (void*)heap_var);
    printf("  函数地址     main:           %p\n", (void*)memory_regions_demo);
    
    // 分析地址范围
    printf("\n地址范围分析:\n");
    uintptr_t global_addr = (uintptr_t)&global_var;
    uintptr_t local_addr = (uintptr_t)&local_var;
    uintptr_t heap_addr = (uintptr_t)heap_var;
    uintptr_t func_addr = (uintptr_t)memory_regions_demo;
    
    printf("  全局变量地址: 0x%lx\n", global_addr);
    printf("  局部变量地址: 0x%lx\n", local_addr);
    printf("  堆变量地址:   0x%lx\n", heap_addr);
    printf("  函数地址:     0x%lx\n", func_addr);
    
    free(heap_var);
}

int main() {
    memory_model_demo();
    memory_regions_demo();
    return 0;
}
```

### 1.2 指针的本质与类型系统

指针是C语言最强大也是最容易出错的特性。理解指针的本质对于掌握C语言至关重要。

```c
#include <stdio.h>
#include <stdlib.h>

// 指针基础概念演示
void pointer_basics_demo() {
    printf("=== 指针基础概念演示 ===\n");
    
    int value = 42;
    int* ptr = &value;  // ptr指向value的地址
    
    printf("基本指针操作:\n");
    printf("  变量value的值:        %d\n", value);
    printf("  变量value的地址:      %p\n", (void*)&value);
    printf("  指针ptr的值(地址):    %p\n", (void*)ptr);
    printf("  指针ptr指向的值:      %d\n", *ptr);
    printf("  指针ptr本身的地址:    %p\n", (void*)&ptr);
    printf("  指针ptr的大小:        %zu字节\n", sizeof(ptr));
    
    // 通过指针修改值
    *ptr = 100;
    printf("\n通过指针修改后:\n");
    printf("  变量value的值:        %d\n", value);
    printf("  指针ptr指向的值:      %d\n", *ptr);
    
    // 指针的指针
    int** ptr_to_ptr = &ptr;
    printf("\n指针的指针:\n");
    printf("  ptr_to_ptr的值:       %p\n", (void*)ptr_to_ptr);
    printf("  *ptr_to_ptr的值:      %p\n", (void*)*ptr_to_ptr);
    printf("  **ptr_to_ptr的值:     %d\n", **ptr_to_ptr);
}

// 不同类型指针的演示
void pointer_types_demo() {
    printf("\n=== 指针类型系统演示 ===\n");
    
    // 基本类型指针
    char c = 'A';
    short s = 1000;
    int i = 100000;
    long l = 1000000L;
    float f = 3.14f;
    double d = 3.14159;
    
    char* char_ptr = &c;
    short* short_ptr = &s;
    int* int_ptr = &i;
    long* long_ptr = &l;
    float* float_ptr = &f;
    double* double_ptr = &d;
    
    printf("不同类型指针的大小:\n");
    printf("  char*   指针大小: %zu字节, 指向数据大小: %zu字节\n", 
           sizeof(char_ptr), sizeof(*char_ptr));
    printf("  short*  指针大小: %zu字节, 指向数据大小: %zu字节\n", 
           sizeof(short_ptr), sizeof(*short_ptr));
    printf("  int*    指针大小: %zu字节, 指向数据大小: %zu字节\n", 
           sizeof(int_ptr), sizeof(*int_ptr));
    printf("  long*   指针大小: %zu字节, 指向数据大小: %zu字节\n", 
           sizeof(long_ptr), sizeof(*long_ptr));
    printf("  float*  指针大小: %zu字节, 指向数据大小: %zu字节\n", 
           sizeof(float_ptr), sizeof(*float_ptr));
    printf("  double* 指针大小: %zu字节, 指向数据大小: %zu字节\n", 
           sizeof(double_ptr), sizeof(*double_ptr));
    
    // void指针演示
    void* void_ptr = &i;
    printf("\nvoid指针演示:\n");
    printf("  void_ptr指向int:      %p\n", void_ptr);
    printf("  转换为int*后的值:     %d\n", *(int*)void_ptr);
    
    // 将void指针指向不同类型
    void_ptr = &f;
    printf("  void_ptr指向float:    %p\n", void_ptr);
    printf("  转换为float*后的值:   %.2f\n", *(float*)void_ptr);
    
    // 空指针演示
    int* null_ptr = NULL;
    printf("\n空指针演示:\n");
    printf("  NULL指针的值:         %p\n", (void*)null_ptr);
    printf("  NULL == 0:            %s\n", (null_ptr == 0) ? "true" : "false");
    
    // 安全的指针使用
    if (null_ptr != NULL) {
        printf("  安全访问: %d\n", *null_ptr);
    } else {
        printf("  检测到空指针，避免访问\n");
    }
}

// 指针运算演示
void pointer_arithmetic_demo() {
    printf("\n=== 指针运算演示 ===\n");
    
    int arr[] = {10, 20, 30, 40, 50};
    int* ptr = arr;  // 指向数组首元素
    
    printf("数组和指针运算:\n");
    printf("  数组: [10, 20, 30, 40, 50]\n");
    printf("  ptr指向首元素: %p, 值: %d\n", (void*)ptr, *ptr);
    
    // 指针递增
    ptr++;
    printf("  ptr++后: %p, 值: %d\n", (void*)ptr, *ptr);
    
    // 指针加法
    ptr = arr + 2;
    printf("  arr+2: %p, 值: %d\n", (void*)ptr, *ptr);
    
    // 指针减法
    ptr = arr + 4;
    int* ptr2 = arr + 1;
    printf("  ptr指向arr[4]: %p, 值: %d\n", (void*)ptr, *ptr);
    printf("  ptr2指向arr[1]: %p, 值: %d\n", (void*)ptr2, *ptr2);
    printf("  ptr - ptr2 = %ld (元素个数差)\n", ptr - ptr2);
    
    // 不同类型指针的运算步长
    printf("\n不同类型指针的运算步长:\n");
    char* char_arr = "Hello";
    short* short_arr = (short[]){1, 2, 3, 4, 5};
    int* int_arr = (int[]){1, 2, 3, 4, 5};
    double* double_arr = (double[]){1.1, 2.2, 3.3, 4.4, 5.5};
    
    printf("  char指针:   %p -> %p (差值: %ld字节)\n", 
           (void*)char_arr, (void*)(char_arr + 1), 
           (char*)(char_arr + 1) - char_arr);
    printf("  short指针:  %p -> %p (差值: %ld字节)\n", 
           (void*)short_arr, (void*)(short_arr + 1), 
           (char*)(short_arr + 1) - (char*)short_arr);
    printf("  int指针:    %p -> %p (差值: %ld字节)\n", 
           (void*)int_arr, (void*)(int_arr + 1), 
           (char*)(int_arr + 1) - (char*)int_arr);
    printf("  double指针: %p -> %p (差值: %ld字节)\n", 
           (void*)double_arr, (void*)(double_arr + 1), 
           (char*)(double_arr + 1) - (char*)double_arr);
}

int main() {
    pointer_basics_demo();
    pointer_types_demo();
    pointer_arithmetic_demo();
    return 0;
}
```

### 1.3 指针与数组的深层关系

数组和指针在C语言中有着密切的关系，但它们并不完全相同。理解这种关系对于掌握C语言至关重要。

```c
#include <stdio.h>
#include <string.h>

// 数组名与指针的关系演示
void array_pointer_relationship() {
    printf("=== 数组名与指针的关系 ===\n");
    
    int arr[5] = {1, 2, 3, 4, 5};
    int* ptr = arr;  // 数组名可以隐式转换为指针
    
    printf("数组与指针的基本关系:\n");
    printf("  数组名arr:           %p\n", (void*)arr);
    printf("  &arr[0]:             %p\n", (void*)&arr[0]);
    printf("  指针ptr:             %p\n", (void*)ptr);
    printf("  arr == ptr:          %s\n", (arr == ptr) ? "true" : "false");
    printf("  arr == &arr[0]:      %s\n", (arr == &arr[0]) ? "true" : "false");
    
    // sizeof的区别
    printf("\nsizeof的区别:\n");
    printf("  sizeof(arr):         %zu字节 (整个数组)\n", sizeof(arr));
    printf("  sizeof(ptr):         %zu字节 (指针本身)\n", sizeof(ptr));
    printf("  sizeof(arr[0]):      %zu字节 (单个元素)\n", sizeof(arr[0]));
    printf("  数组元素个数:        %zu\n", sizeof(arr) / sizeof(arr[0]));
    
    // 地址运算的区别
    printf("\n地址运算的区别:\n");
    printf("  &arr:                %p (数组的地址)\n", (void*)&arr);
    printf("  &arr + 1:            %p (下一个数组的地址)\n", (void*)(&arr + 1));
    printf("  arr + 1:             %p (下一个元素的地址)\n", (void*)(arr + 1));
    printf("  &ptr:                %p (指针变量的地址)\n", (void*)&ptr);
    
    // 数组名不能被赋值
    printf("\n数组名的常量性质:\n");
    // arr = ptr;  // 编译错误：数组名是常量，不能被赋值
    ptr = arr;     // 正确：指针可以被赋值
    printf("  ptr = arr; 成功\n");
    
    // 但可以修改数组元素
    arr[0] = 100;
    printf("  arr[0] = 100; 成功，新值: %d\n", arr[0]);
}

// 多维数组与指针
void multidimensional_arrays() {
    printf("\n=== 多维数组与指针 ===\n");
    
    int matrix[3][4] = {
        {1,  2,  3,  4},
        {5,  6,  7,  8},
        {9,  10, 11, 12}
    };
    
    printf("二维数组的内存布局:\n");
    printf("  数组声明: int matrix[3][4]\n");
    
    // 打印所有元素的地址
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            printf("  matrix[%d][%d] = %2d, 地址: %p\n", 
                   i, j, matrix[i][j], (void*)&matrix[i][j]);
        }
    }
    
    // 不同的指针表示方法
    printf("\n不同的指针表示方法:\n");
    int* ptr1 = &matrix[0][0];  // 指向第一个元素
    int* ptr2 = matrix[0];      // 指向第一行
    int (*ptr3)[4] = matrix;    // 指向整行的指针
    
    printf("  ptr1 (int*):         %p, 值: %d\n", (void*)ptr1, *ptr1);
    printf("  ptr2 (int*):         %p, 值: %d\n", (void*)ptr2, *ptr2);
    printf("  ptr3 (int(*)[4]):    %p, 值: %d\n", (void*)ptr3, (*ptr3)[0]);
    
    // 指针运算的区别
    printf("\n指针运算的区别:\n");
    printf("  ptr1 + 1:            %p (下一个int)\n", (void*)(ptr1 + 1));
    printf("  ptr2 + 1:            %p (下一个int)\n", (void*)(ptr2 + 1));
    printf("  ptr3 + 1:            %p (下一行)\n", (void*)(ptr3 + 1));
    
    // 访问元素的不同方式
    printf("\n访问matrix[1][2]的不同方式:\n");
    printf("  matrix[1][2]:        %d\n", matrix[1][2]);
    printf("  *(matrix[1] + 2):    %d\n", *(matrix[1] + 2));
    printf("  *(*(matrix + 1) + 2): %d\n", *(*(matrix + 1) + 2));
    printf("  *(&matrix[0][0] + 1*4 + 2): %d\n", *(&matrix[0][0] + 1*4 + 2));
}

// 字符串与字符指针
void string_and_char_pointers() {
    printf("\n=== 字符串与字符指针 ===\n");
    
    // 不同的字符串表示方法
    char str1[] = "Hello";           // 字符数组
    char* str2 = "World";            // 字符指针指向字符串常量
    char str3[20] = "C Programming"; // 固定大小字符数组
    
    printf("不同字符串表示方法:\n");
    printf("  str1[] = \"Hello\":      %s, 地址: %p\n", str1, (void*)str1);
    printf("  str2* = \"World\":       %s, 地址: %p\n", str2, (void*)str2);
    printf("  str3[20] = \"C Programming\": %s, 地址: %p\n", str3, (void*)str3);
    
    // sizeof的区别
    printf("\nsizeof的区别:\n");
    printf("  sizeof(str1):        %zu字节 (数组大小)\n", sizeof(str1));
    printf("  sizeof(str2):        %zu字节 (指针大小)\n", sizeof(str2));
    printf("  sizeof(str3):        %zu字节 (数组大小)\n", sizeof(str3));
    printf("  strlen(str1):        %zu字符 (字符串长度)\n", strlen(str1));
    printf("  strlen(str2):        %zu字符 (字符串长度)\n", strlen(str2));
    printf("  strlen(str3):        %zu字符 (字符串长度)\n", strlen(str3));
    
    // 修改字符串
    printf("\n字符串修改:\n");
    str1[0] = 'h';  // 可以修改字符数组
    str3[0] = 'c';  // 可以修改字符数组
    // str2[0] = 'w';  // 错误：不能修改字符串常量
    
    printf("  修改后 str1:         %s\n", str1);
    printf("  修改后 str3:         %s\n", str3);
    
    // 字符串指针的重新赋值
    str2 = "New World";  // 可以让指针指向新的字符串常量
    printf("  重新赋值后 str2:     %s\n", str2);
    
    // 字符串的逐字符访问
    printf("\n逐字符访问str1:\n");
    for (char* p = str1; *p != '\0'; p++) {
        printf("  地址: %p, 字符: '%c', ASCII: %d\n", 
               (void*)p, *p, *p);
    }
}

int main() {
    array_pointer_relationship();
    multidimensional_arrays();
    string_and_char_pointers();
    return 0;
}
```

## 2. 动态内存管理深度解析

### 2.1 内存分配器原理与实现

理解动态内存管理的原理有助于编写更高效、更安全的程序。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// 内存分配函数详解
void memory_allocation_functions() {
    printf("=== 内存分配函数详解 ===\n");
    
    // malloc - 分配未初始化的内存
    printf("1. malloc函数:\n");
    int* ptr1 = malloc(5 * sizeof(int));
    if (ptr1 == NULL) {
        printf("  malloc失败\n");
        return;
    }
    
    printf("  分配5个int的内存: %p\n", (void*)ptr1);
    printf("  未初始化的内容: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", ptr1[i]);  // 可能是垃圾值
    }
    printf("\n");
    
    // 手动初始化
    for (int i = 0; i < 5; i++) {
        ptr1[i] = i + 1;
    }
    printf("  初始化后的内容: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", ptr1[i]);
    }
    printf("\n");
    
    // calloc - 分配并初始化为零的内存
    printf("\n2. calloc函数:\n");
    int* ptr2 = calloc(5, sizeof(int));
    if (ptr2 == NULL) {
        printf("  calloc失败\n");
        free(ptr1);
        return;
    }
    
    printf("  分配5个int的内存: %p\n", (void*)ptr2);
    printf("  自动初始化为零: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", ptr2[i]);
    }
    printf("\n");
    
    // realloc - 重新调整内存大小
    printf("\n3. realloc函数:\n");
    printf("  原始ptr1地址: %p\n", (void*)ptr1);
    ptr1 = realloc(ptr1, 10 * sizeof(int));  // 扩大到10个int
    if (ptr1 == NULL) {
        printf("  realloc失败\n");
        free(ptr2);
        return;
    }
    
    printf("  realloc后地址: %p\n", (void*)ptr1);
    printf("  原有数据保持: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", ptr1[i]);
    }
    printf("\n");
    
    // 初始化新分配的部分
    for (int i = 5; i < 10; i++) {
        ptr1[i] = i + 1;
    }
    printf("  扩展后的内容: ");
    for (int i = 0; i < 10; i++) {
        printf("%d ", ptr1[i]);
    }
    printf("\n");
    
    // 缩小内存
    ptr1 = realloc(ptr1, 3 * sizeof(int));
    printf("  缩小后的内容: ");
    for (int i = 0; i < 3; i++) {
        printf("%d ", ptr1[i]);
    }
    printf("\n");
    
    // 释放内存
    free(ptr1);
    free(ptr2);
    printf("\n内存已释放\n");
}

// 内存对齐和填充演示
void memory_alignment_demo() {
    printf("\n=== 内存对齐演示 ===\n");
    
    // 结构体内存对齐
    struct AlignmentTest1 {
        char c;     // 1字节
        int i;      // 4字节
        char c2;    // 1字节
    };
    
    struct AlignmentTest2 {
        char c;     // 1字节
        char c2;    // 1字节
        int i;      // 4字节
    };
    
    printf("结构体内存对齐:\n");
    printf("  struct AlignmentTest1 大小: %zu字节\n", sizeof(struct AlignmentTest1));
    printf("  struct AlignmentTest2 大小: %zu字节\n", sizeof(struct AlignmentTest2));
    
    struct AlignmentTest1 test1;
    printf("  test1.c 地址:  %p\n", (void*)&test1.c);
    printf("  test1.i 地址:  %p (偏移: %ld)\n", 
           (void*)&test1.i, (char*)&test1.i - (char*)&test1.c);
    printf("  test1.c2 地址: %p (偏移: %ld)\n", 
           (void*)&test1.c2, (char*)&test1.c2 - (char*)&test1.c);
    
    // 动态分配的内存对齐
    printf("\n动态分配的内存对齐:\n");
    void* ptrs[10];
    for (int i = 0; i < 10; i++) {
        ptrs[i] = malloc(1);  // 分配1字节
        printf("  malloc(1) 返回地址: %p\n", ptrs[i]);
    }
    
    // 检查对齐
    printf("\n地址对齐检查:\n");
    for (int i = 0; i < 10; i++) {
        uintptr_t addr = (uintptr_t)ptrs[i];
        printf("  地址 %p: 8字节对齐: %s, 16字节对齐: %s\n", 
               ptrs[i],
               (addr % 8 == 0) ? "是" : "否",
               (addr % 16 == 0) ? "是" : "否");
        free(ptrs[i]);
    }
}

// 内存池简单实现
#define POOL_SIZE 1024
#define BLOCK_SIZE 32

typedef struct Block {
    struct Block* next;
} Block;

typedef struct {
    char memory[POOL_SIZE];
    Block* free_list;
    size_t block_size;
    size_t total_blocks;
    size_t free_blocks;
} MemoryPool;

void init_memory_pool(MemoryPool* pool) {
    pool->block_size = BLOCK_SIZE;
    pool->total_blocks = POOL_SIZE / BLOCK_SIZE;
    pool->free_blocks = pool->total_blocks;
    pool->free_list = NULL;
    
    // 初始化空闲链表
    for (size_t i = 0; i < pool->total_blocks; i++) {
        Block* block = (Block*)(pool->memory + i * BLOCK_SIZE);
        block->next = pool->free_list;
        pool->free_list = block;
    }
}

void* pool_alloc(MemoryPool* pool) {
    if (pool->free_list == NULL) {
        return NULL;  // 内存池已满
    }
    
    Block* block = pool->free_list;
    pool->free_list = block->next;
    pool->free_blocks--;
    
    return (void*)block;
}

void pool_free(MemoryPool* pool, void* ptr) {
    if (ptr == NULL) return;
    
    Block* block = (Block*)ptr;
    block->next = pool->free_list;
    pool->free_list = block;
    pool->free_blocks++;
}

void memory_pool_demo() {
    printf("\n=== 内存池演示 ===\n");
    
    MemoryPool pool;
    init_memory_pool(&pool);
    
    printf("内存池初始化:\n");
    printf("  总块数: %zu, 空闲块数: %zu, 块大小: %zu字节\n", 
           pool.total_blocks, pool.free_blocks, pool.block_size);
    
    // 分配一些内存块
    void* ptrs[10];
    printf("\n分配10个内存块:\n");
    for (int i = 0; i < 10; i++) {
        ptrs[i] = pool_alloc(&pool);
        if (ptrs[i]) {
            printf("  块%d: %p\n", i, ptrs[i]);
        } else {
            printf("  块%d: 分配失败\n", i);
        }
    }
    
    printf("  分配后空闲块数: %zu\n", pool.free_blocks);
    
    // 释放一些内存块
    printf("\n释放前5个内存块:\n");
    for (int i = 0; i < 5; i++) {
        pool_free(&pool, ptrs[i]);
        ptrs[i] = NULL;
    }
    
    printf("  释放后空闲块数: %zu\n", pool.free_blocks);
    
    // 再次分配
    printf("\n再次分配3个内存块:\n");
    for (int i = 0; i < 3; i++) {
        void* ptr = pool_alloc(&pool);
        if (ptr) {
            printf("  新块%d: %p\n", i, ptr);
        }
    }
    
    printf("  最终空闲块数: %zu\n", pool.free_blocks);
}

int main() {
    memory_allocation_functions();
    memory_alignment_demo();
    memory_pool_demo();
    return 0;
}
```

### 2.2 内存安全编程与错误检测

内存安全是C语言编程中最重要的话题之一。了解常见的内存错误和预防方法至关重要。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// 内存错误类型演示
void memory_errors_demo() {
    printf("=== 常见内存错误演示 ===\n");
    
    // 1. 内存泄漏
    printf("1. 内存泄漏示例:\n");
    void* leak_ptr = malloc(100);
    printf("  分配了100字节内存: %p\n", leak_ptr);
    // 忘记调用free(leak_ptr); - 这会导致内存泄漏
    // 在实际程序中应该调用free，这里为了演示故意不调用
    
    // 2. 悬空指针
    printf("\n2. 悬空指针示例:\n");
    int* dangling_ptr = malloc(sizeof(int));
    *dangling_ptr = 42;
    printf("  分配内存并赋值: %d\n", *dangling_ptr);
    free(dangling_ptr);
    printf("  内存已释放，指针变为悬空指针\n");
    // printf("  访问悬空指针: %d\n", *dangling_ptr); // 危险！未定义行为
    
    // 安全做法：释放后设为NULL
    dangling_ptr = NULL;
    if (dangling_ptr != NULL) {
        printf("  安全访问: %d\n", *dangling_ptr);
    } else {
        printf("  检测到空指针，避免访问\n");
    }
    
    // 3. 重复释放
    printf("\n3. 重复释放示例:\n");
    int* double_free_ptr = malloc(sizeof(int));
    printf("  分配内存: %p\n", (void*)double_free_ptr);
    free(double_free_ptr);
    printf("  第一次释放成功\n");
    // free(double_free_ptr); // 危险！重复释放
    // 安全做法：释放后设为NULL
    double_free_ptr = NULL;
    
    // 4. 缓冲区溢出
    printf("\n4. 缓冲区溢出示例:\n");
    char buffer[10];
    const char* source = "This is a very long string that will overflow";
    printf("  缓冲区大小: %zu字节\n", sizeof(buffer));
    printf("  源字符串长度: %zu字符\n", strlen(source));
    
    // 不安全的复制
    // strcpy(buffer, source); // 危险！缓冲区溢出
    
    // 安全的复制
    strncpy(buffer, source, sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0';  // 确保以null结尾
    printf("  安全复制结果: \"%s\"\n", buffer);
    
    // 5. 未初始化内存访问
    printf("\n5. 未初始化内存访问:\n");
    int* uninit_ptr = malloc(5 * sizeof(int));
    printf("  未初始化内存内容: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", uninit_ptr[i]);  // 可能是垃圾值
    }
    printf("\n");
    
    // 安全做法：使用calloc或手动初始化
    int* init_ptr = calloc(5, sizeof(int));
    printf("  calloc初始化内容: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", init_ptr[i]);
    }
    printf("\n");
    
    free(uninit_ptr);
    free(init_ptr);
}

// 安全的内存管理函数
void* safe_malloc(size_t size) {
    void* ptr = malloc(size);
    if (ptr == NULL) {
        fprintf(stderr, "内存分配失败: 请求 %zu 字节\n", size);
        exit(EXIT_FAILURE);
    }
    return ptr;
}

void* safe_calloc(size_t num, size_t size) {
    void* ptr = calloc(num, size);
    if (ptr == NULL) {
        fprintf(stderr, "内存分配失败: 请求 %zu 个 %zu 字节的元素\n", num, size);
        exit(EXIT_FAILURE);
    }
    return ptr;
}

void* safe_realloc(void* ptr, size_t new_size) {
    void* new_ptr = realloc(ptr, new_size);
    if (new_ptr == NULL && new_size > 0) {
        fprintf(stderr, "内存重分配失败: 请求 %zu 字节\n", new_size);
        free(ptr);  // 释放原内存
        exit(EXIT_FAILURE);
    }
    return new_ptr;
}

void safe_free(void** ptr) {
    if (ptr != NULL && *ptr != NULL) {
        free(*ptr);
        *ptr = NULL;  // 防止悬空指针
    }
}

// 内存调试工具
typedef struct MemoryBlock {
    void* ptr;
    size_t size;
    const char* file;
    int line;
    struct MemoryBlock* next;
} MemoryBlock;

static MemoryBlock* memory_list = NULL;
static size_t total_allocated = 0;
static size_t allocation_count = 0;

void* debug_malloc(size_t size, const char* file, int line) {
    void* ptr = malloc(size);
    if (ptr == NULL) {
        return NULL;
    }
    
    MemoryBlock* block = malloc(sizeof(MemoryBlock));
    if (block == NULL) {
        free(ptr);
        return NULL;
    }
    
    block->ptr = ptr;
    block->size = size;
    block->file = file;
    block->line = line;
    block->next = memory_list;
    memory_list = block;
    
    total_allocated += size;
    allocation_count++;
    
    printf("[DEBUG] 分配 %zu 字节在 %s:%d, 地址: %p\n", 
           size, file, line, ptr);
    
    return ptr;
}

void debug_free(void* ptr, const char* file, int line) {
    if (ptr == NULL) {
        return;
    }
    
    MemoryBlock** current = &memory_list;
    while (*current != NULL) {
        if ((*current)->ptr == ptr) {
            MemoryBlock* block = *current;
            *current = block->next;
            
            printf("[DEBUG] 释放 %zu 字节在 %s:%d, 地址: %p (分配于 %s:%d)\n", 
                   block->size, file, line, ptr, block->file, block->line);
            
            total_allocated -= block->size;
            allocation_count--;
            
            free(ptr);
            free(block);
            return;
        }
        current = &(*current)->next;
    }
    
    printf("[ERROR] 尝试释放未跟踪的内存 %p 在 %s:%d\n", ptr, file, line);
}

void print_memory_leaks() {
    if (memory_list == NULL) {
        printf("[DEBUG] 没有内存泄漏\n");
        return;
    }
    
    printf("[ERROR] 检测到内存泄漏:\n");
    MemoryBlock* current = memory_list;
    while (current != NULL) {
        printf("  泄漏: %zu 字节在 %s:%d, 地址: %p\n", 
               current->size, current->file, current->line, current->ptr);
        current = current->next;
    }
    printf("  总泄漏: %zu 字节, %zu 个分配\n", total_allocated, allocation_count);
}

#define DEBUG_MALLOC(size) debug_malloc(size, __FILE__, __LINE__)
#define DEBUG_FREE(ptr) debug_free(ptr, __FILE__, __LINE__)

void memory_debugging_demo() {
    printf("\n=== 内存调试演示 ===\n");
    
    // 正常的分配和释放
    void* ptr1 = DEBUG_MALLOC(100);
    void* ptr2 = DEBUG_MALLOC(200);
    
    DEBUG_FREE(ptr1);
    DEBUG_FREE(ptr2);
    
    // 模拟内存泄漏
    void* leak1 = DEBUG_MALLOC(50);
    void* leak2 = DEBUG_MALLOC(75);
    
    // 只释放一个，另一个造成泄漏
    DEBUG_FREE(leak1);
    // leak2 没有释放，会造成内存泄漏
    
    print_memory_leaks();
}

// 安全的字符串操作
char* safe_strdup(const char* str) {
    if (str == NULL) {
        return NULL;
    }
    
    size_t len = strlen(str) + 1;
    char* copy = safe_malloc(len);
    memcpy(copy, str, len);
    return copy;
}

char* safe_strcat(const char* str1, const char* str2) {
    if (str1 == NULL || str2 == NULL) {
        return NULL;
    }
    
    size_t len1 = strlen(str1);
    size_t len2 = strlen(str2);
    char* result = safe_malloc(len1 + len2 + 1);
    
    memcpy(result, str1, len1);
    memcpy(result + len1, str2, len2 + 1);
    
    return result;
}

void safe_string_operations() {
    printf("\n=== 安全字符串操作演示 ===\n");
    
    const char* str1 = "Hello, ";
    const char* str2 = "World!";
    
    char* copy = safe_strdup(str1);
    printf("  复制字符串: \"%s\"\n", copy);
    
    char* concat = safe_strcat(str1, str2);
    printf("  连接字符串: \"%s\"\n", concat);
    
    safe_free((void**)&copy);
    safe_free((void**)&concat);
    
    // 验证指针已设为NULL
    printf("  copy指针: %p\n", (void*)copy);
    printf("  concat指针: %p\n", (void*)concat);
}

int main() {
    memory_errors_demo();
    memory_debugging_demo();
    safe_string_operations();
    return 0;
}
```

## 3. 高级指针应用

### 3.1 多级指针与复杂数据结构

多级指针是C语言的高级特性，在构建复杂数据结构时非常有用。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 多级指针基础
void multilevel_pointers_demo() {
    printf("=== 多级指针演示 ===\n");
    
    int value = 42;
    int* ptr1 = &value;          // 一级指针
    int** ptr2 = &ptr1;          // 二级指针
    int*** ptr3 = &ptr2;         // 三级指针
    
    printf("多级指针的值和地址:\n");
    printf("  value = %d, 地址: %p\n", value, (void*)&value);
    printf("  ptr1 = %p, 地址: %p, *ptr1 = %d\n", 
           (void*)ptr1, (void*)&ptr1, *ptr1);
    printf("  ptr2 = %p, 地址: %p, *ptr2 = %p, **ptr2 = %d\n", 
           (void*)ptr2, (void*)&ptr2, (void*)*ptr2, **ptr2);
    printf("  ptr3 = %p, 地址: %p, *ptr3 = %p, **ptr3 = %p, ***ptr3 = %d\n", 
           (void*)ptr3, (void*)&ptr3, (void*)*ptr3, (void*)**ptr3, ***ptr3);
    
    // 通过不同级别的指针修改值
    printf("\n通过不同级别指针修改值:\n");
    *ptr1 = 100;
    printf("  *ptr1 = 100, value = %d\n", value);
    
    **ptr2 = 200;
    printf("  **ptr2 = 200, value = %d\n", value);
    
    ***ptr3 = 300;
    printf("  ***ptr3 = 300, value = %d\n", value);
}

// 动态二维数组
int** create_2d_array(int rows, int cols) {
    // 分配行指针数组
    int** array = malloc(rows * sizeof(int*));
    if (array == NULL) {
        return NULL;
    }
    
    // 为每一行分配内存
    for (int i = 0; i < rows; i++) {
        array[i] = malloc(cols * sizeof(int));
        if (array[i] == NULL) {
            // 如果分配失败，释放已分配的内存
            for (int j = 0; j < i; j++) {
                free(array[j]);
            }
            free(array);
            return NULL;
        }
    }
    
    return array;
}

void free_2d_array(int** array, int rows) {
    if (array == NULL) return;
    
    for (int i = 0; i < rows; i++) {
        free(array[i]);
    }
    free(array);
}

void dynamic_2d_array_demo() {
    printf("\n=== 动态二维数组演示 ===\n");
    
    int rows = 3, cols = 4;
    int** matrix = create_2d_array(rows, cols);
    
    if (matrix == NULL) {
        printf("二维数组创建失败\n");
        return;
    }
    
    // 初始化数组
    printf("初始化 %dx%d 矩阵:\n", rows, cols);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = i * cols + j + 1;
            printf("%3d ", matrix[i][j]);
        }
        printf("\n");
    }
    
    // 打印内存布局
    printf("\n内存布局分析:\n");
    printf("  matrix指针: %p\n", (void*)matrix);
    for (int i = 0; i < rows; i++) {
        printf("  matrix[%d]: %p\n", i, (void*)matrix[i]);
        for (int j = 0; j < cols; j++) {
            printf("    matrix[%d][%d]: %p, 值: %d\n", 
                   i, j, (void*)&matrix[i][j], matrix[i][j]);
        }
    }
    
    free_2d_array(matrix, rows);
    printf("\n二维数组已释放\n");
}

// 连续内存的二维数组（更高效）
int** create_contiguous_2d_array(int rows, int cols) {
    // 分配连续内存：行指针数组 + 数据区域
    int** array = malloc(rows * sizeof(int*) + rows * cols * sizeof(int));
    if (array == NULL) {
        return NULL;
    }
    
    // 数据区域紧跟在行指针数组后面
    int* data = (int*)(array + rows);
    
    // 设置行指针
    for (int i = 0; i < rows; i++) {
        array[i] = data + i * cols;
    }
    
    return array;
}

void contiguous_2d_array_demo() {
    printf("\n=== 连续内存二维数组演示 ===\n");
    
    int rows = 3, cols = 4;
    int** matrix = create_contiguous_2d_array(rows, cols);
    
    if (matrix == NULL) {
        printf("连续二维数组创建失败\n");
        return;
    }
    
    // 初始化数组
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = (i + 1) * 10 + (j + 1);
        }
    }
    
    printf("连续内存矩阵:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%3d ", matrix[i][j]);
        }
        printf("\n");
    }
    
    // 分析内存连续性
    printf("\n内存连续性分析:\n");
    printf("  matrix指针: %p\n", (void*)matrix);
    for (int i = 0; i < rows; i++) {
        printf("  matrix[%d]: %p", i, (void*)matrix[i]);
        if (i > 0) {
            ptrdiff_t diff = (char*)matrix[i] - (char*)matrix[i-1];
            printf(" (与上一行距离: %ld字节)", diff);
        }
        printf("\n");
    }
    
    // 验证数据连续性
    printf("\n数据连续性验证:\n");
    int* first_element = &matrix[0][0];
    for (int i = 0; i < rows * cols; i++) {
        printf("  连续访问[%d]: %d\n", i, first_element[i]);
    }
    
    free(matrix);  // 只需要一次free调用
    printf("\n连续二维数组已释放\n");
}

// 指针数组 vs 数组指针
void pointer_array_vs_array_pointer() {
    printf("\n=== 指针数组 vs 数组指针 ===\n");
    
    // 指针数组：数组的每个元素都是指针
    char* string_array[] = {
        "First string",
        "Second string", 
        "Third string"
    };
    
    printf("指针数组 (char* array[]):\n");
    printf("  数组大小: %zu字节\n", sizeof(string_array));
    printf("  元素个数: %zu\n", sizeof(string_array) / sizeof(string_array[0]));
    
    for (int i = 0; i < 3; i++) {
        printf("  string_array[%d]: %p -> \"%s\"\n", 
               i, (void*)string_array[i], string_array[i]);
    }
    
    // 数组指针：指向数组的指针
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    int (*array_pointer)[4] = matrix;  // 指向包含4个int的数组的指针
    
    printf("\n数组指针 (int (*ptr)[4]):\n");
    printf("  指针大小: %zu字节\n", sizeof(array_pointer));
    printf("  指向数组大小: %zu字节\n", sizeof(*array_pointer));
    
    for (int i = 0; i < 3; i++) {
        printf("  array_pointer[%d]: %p -> [", i, (void*)array_pointer[i]);
        for (int j = 0; j < 4; j++) {
            printf("%d", array_pointer[i][j]);
            if (j < 3) printf(", ");
        }
        printf("]\n");
    }
    
    // 指针运算的不同
    printf("\n指针运算的区别:\n");
    char** ptr_arr = string_array;
    int (*arr_ptr)[4] = matrix;
    
    printf("  ptr_arr: %p -> %p\n", (void*)ptr_arr, (void*)*ptr_arr);
    printf("  ptr_arr + 1: %p -> %p (下一个指针)\n", 
           (void*)(ptr_arr + 1), (void*)*(ptr_arr + 1));
    
    printf("  arr_ptr: %p\n", (void*)arr_ptr);
    printf("  arr_ptr + 1: %p (下一个数组)\n", (void*)(arr_ptr + 1));
    printf("  距离: %ld字节\n", (char*)(arr_ptr + 1) - (char*)arr_ptr);
}

int main() {
    multilevel_pointers_demo();
    dynamic_2d_array_demo();
    contiguous_2d_array_demo();
    pointer_array_vs_array_pointer();
    return 0;
}
```

### 3.2 函数指针与回调机制

函数指针是C语言的高级特性，允许将函数作为参数传递，实现回调机制和多态性。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// 基本函数指针演示
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int subtract(int a, int b) {
    return a - b;
}

void basic_function_pointers() {
    printf("=== 基本函数指针演示 ===\n");
    
    // 声明函数指针
    int (*operation)(int, int);
    
    printf("函数指针基础:\n");
    printf("  add函数地址: %p\n", (void*)add);
    printf("  multiply函数地址: %p\n", (void*)multiply);
    printf("  subtract函数地址: %p\n", (void*)subtract);
    
    // 使用函数指针
    operation = add;
    printf("  operation = add; operation(5, 3) = %d\n", operation(5, 3));
    
    operation = multiply;
    printf("  operation = multiply; operation(5, 3) = %d\n", operation(5, 3));
    
    operation = subtract;
    printf("  operation = subtract; operation(5, 3) = %d\n", operation(5, 3));
    
    // 函数指针数组
    int (*operations[])(int, int) = {add, multiply, subtract};
    const char* op_names[] = {"加法", "乘法", "减法"};
    
    printf("\n函数指针数组:\n");
    for (int i = 0; i < 3; i++) {
        printf("  %s: %d\n", op_names[i], operations[i](8, 2));
    }
}

// 回调函数演示
typedef void (*ProgressCallback)(int current, int total, const char* message);

void default_progress_callback(int current, int total, const char* message) {
    int percent = (current * 100) / total;
    printf("  [%3d%%] %s (%d/%d)\n", percent, message, current, total);
}

void simple_progress_callback(int current, int total, const char* message) {
    if (current % (total / 10) == 0 || current == total) {
        printf("  进度: %d/%d\n", current, total);
    }
}

void process_data(int* data, int size, ProgressCallback callback) {
    if (callback) {
        callback(0, size, "开始处理数据");
    }
    
    for (int i = 0; i < size; i++) {
        // 模拟数据处理
        data[i] = data[i] * 2;
        
        // 调用回调函数报告进度
        if (callback && (i % (size / 10) == 0 || i == size - 1)) {
            callback(i + 1, size, "处理数据中");
        }
    }
    
    if (callback) {
        callback(size, size, "数据处理完成");
    }
}

void callback_demo() {
    printf("\n=== 回调函数演示 ===\n");
    
    int data[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
    int size = sizeof(data) / sizeof(data[0]);
    
    printf("原始数据: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", data[i]);
    }
    printf("\n");
    
    printf("\n使用详细回调:\n");
    process_data(data, size, default_progress_callback);
    
    printf("\n处理后数据: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", data[i]);
    }
    printf("\n");
    
    // 重置数据
    for (int i = 0; i < size; i++) {
        data[i] = i + 1;
    }
    
    printf("\n使用简单回调:\n");
    process_data(data, size, simple_progress_callback);
    
    printf("\n不使用回调:\n");
    process_data(data, size, NULL);
    printf("  处理完成（无进度显示）\n");
}

// 排序算法与比较函数
typedef int (*CompareFunc)(const void* a, const void* b);

int compare_int_asc
