# 指针与内存：理解C的灵魂

目标：深入理解指针、数组与字符串的关系，掌握内存布局、指针算术、野指针与悬挂指针、const与restrict。

## 1. 指针基础
- 指针是变量的地址；类型决定解引用后的对象类型
- 取地址与解引用：& 与 *
- 空指针：NULL 表示不指向任何有效对象

## 2. 数组与指针
- 数组名在表达式中衰减为指向首元素的指针（除 sizeof 与 & 场景）
- 指针算术：p+1 跳过一个元素大小；越界访问是未定义行为
- 多维数组与指向指针的指针：int a[3][4]; int **pp

## 3. 字符串
- C字符串以'\0'结尾；常用函数：strlen/strcpy/strcat/strcmp
- 缓冲区溢出与安全：使用 strncpy/strncat 或 snprintf；注意截断与终止符

## 4. const 与 restrict
- const 限定只读；指向常量的指针与常量指针的区别
- restrict（C99）：承诺独占别名，提高编译器优化空间（仅用于指针）

## 5. 动态内存
- malloc/calloc/realloc/free；分配失败返回NULL
- 内存泄漏、重复释放、悬挂指针与野指针
- 对齐与结构体中的填充

示例：
```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int n = 5;
    int *arr = malloc(n * sizeof *arr);
    if (!arr) return 1;
    for (int i = 0; i < n; ++i) arr[i] = i*i;
    for (int i = 0; i < n; ++i) printf("%d ", arr[i]);
    free(arr);
    return 0;
}
```

## 6. 练习
- 写函数安全地连接两个字符串，保证目标缓冲区不溢出。
- 使用malloc分配二维数组（连续内存）与指针数组（非连续），比较访问方式与性能。
- 演示const与非const指针的API设计差异。

## 更多示例

示例A：安全字符串拼接
```c
#include <stdio.h>
#include <string.h>

size_t safe_strcat(char *dst, size_t cap, const char *src){
    size_t dlen = strnlen(dst, cap);
    size_t slen = strlen(src);
    if (dlen + slen + 1 > cap) slen = cap - dlen - 1;
    memcpy(dst + dlen, src, slen);
    dst[dlen + slen] = '\0';
    return dlen + slen;
}
```

示例B：二维数组的连续内存分配
```c
#include <stdio.h>
#include <stdlib.h>

int **alloc_matrix_ptrs(size_t r, size_t c){
    int **m = malloc(r * sizeof *m);
    int *data = malloc(r * c * sizeof *data);
    if (!m || !data){ free(m); free(data); return NULL; }
    for (size_t i=0;i<r;++i) m[i] = data + i*c;
    return m;
}
```

示例C：const与API设计
```c
size_t count_if(const int *arr, size_t n, int (*pred)(int)){ // 输入只读
    size_t cnt=0; for(size_t i=0;i<n;++i) if(pred(arr[i])) ++cnt; return cnt;
}
```

示例D：restrict用于优化
```c
void vec_add(size_t n, int * restrict a, const int * restrict b){
    for(size_t i=0;i<n;++i) a[i]+=b[i];
}
```

## 练习参考答案（节选）
- 比较连续内存二维数组与指针数组的访问性能：使用clock或高精度计时，确保编译优化打开。
- 设计只读/可写接口：通过const限定输入参数，避免误修改。

## 参考资料
- C11 关于 restrict 的语义说明：有效减少别名带来的优化障碍。
- 字符串安全指南（CERT C）：长度检查与终止符保障。