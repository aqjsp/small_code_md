# C语言指针与内存管理

## 学习目标

通过本章学习，你将掌握：
- 指针的基本概念和操作方法
- 动态内存分配和释放的正确使用
- 指针与数组的关系和高级应用
- 函数指针的使用和回调机制
- 常见指针错误的识别和避免方法

## 1. 指针基础

### 1.1 什么是指针

指针是存储内存地址的变量，它是C语言实现底层内存操作和高效数据结构的核心机制。指针提供了直接访问内存的能力，使得C语言能够进行高效的内存管理和数据操作。

**指针的基本概念**：
- 指针变量可以指向变量，也可以指向数组元素
- 数组的类型和指针变量的基类型一定要相同
- 数组名是一个指针"常量"，表示数组第一个元素的起始地址

**指针的三要素**：
- **地址**：指针存储的内存位置
- **值**：该地址处存储的数据内容
- **类型**：决定如何解释该地址处的数据

```c
#include <stdio.h>

void pointer_basics() {
    int a[] = {1, 2, 3, 4, 5};
    int *p = &a[0];  // p指向数组第一个元素
    int *q = a;      // 数组名a表示数组首地址，等价于&a[0]
    
    printf("*p = %d, *q = %d\n", *p, *q);  // 输出：*p = 1, *q = 1
    
    // 数组名表示数组第一个元素的起始地址
    printf("数组首地址: %p\n", (void*)a);
    printf("第一个元素地址: %p\n", (void*)&a[0]);
    printf("指针p的值: %p\n", (void*)p);
}
```

### 1.2 指针的声明和初始化

```c
// 指针声明的基本语法
int *ptr1;           // 声明一个指向int的指针
char *ptr2;          // 声明一个指向char的指针
double *ptr3;        // 声明一个指向double的指针

// 指针初始化
int value = 100;
int *ptr = &value;   // 用变量地址初始化
int *null_ptr = NULL; // 初始化为空指针

// 多个指针声明
int *p1, *p2, *p3;   // 声明三个int指针
int *p4, value2 = 0;  // p4是指针，value2是变量
```

### 1.3 指针操作符

**取地址操作符（&）**：获取变量的内存地址
**解引用操作符（*）**：访问指针指向的内容

```c
void pointer_operators() {
    int x = 10;
    int *ptr = &x;  // &x 获取x的地址
    
    printf("x的值: %d\n", x);
    printf("x的地址: %p\n", (void*)&x);
    printf("ptr的值(地址): %p\n", (void*)ptr);
    printf("*ptr的值: %d\n", *ptr);  // *ptr 解引用，获取ptr指向的值
    
    // 通过指针修改值
    *ptr = 20;
    printf("修改后x的值: %d\n", x);  // x现在是20
}
```

### 1.4 指针与数组

指针和数组在C语言中有着密切的关系，理解它们的区别和联系是掌握C语言的关键。指针可以用来访问数组元素，而数组名本身就是一个指向数组首元素的指针常量。

**指针数组与数组指针的区别**：

1. **指针数组**：数组的每个元素都是指针
```c
#include <stdio.h>

void pointer_array_demo() {
    char *str[3] = {"C语言", "Java", "Python"};  // 指针数组
    
    printf("指针数组示例：\n");
    for (int i = 0; i < 3; i++) {
        printf("str[%d] = %s\n", i, str[i]);
    }
    
    // 也可以这样定义
    char *languages[] = {"C", "C++", "Java", "Python"};
    int n = sizeof(languages) / sizeof(languages[0]);
    
    printf("\n编程语言列表：\n");
    for (int i = 0; i < n; i++) {
        printf("%d: %s\n", i + 1, languages[i]);
    }
}
```

2. **数组指针**：指向整个数组的指针
```c
void array_pointer_demo() {
    int arr[5] = {1, 2, 3, 4, 5};
    int (*p)[5] = &arr;  // 数组指针，指向整个数组
    
    printf("数组指针示例：\n");
    printf("数组地址: %p\n", (void*)&arr);
    printf("指针p的值: %p\n", (void*)p);
    
    // 通过数组指针访问元素
    for (int i = 0; i < 5; i++) {
        printf("(*p)[%d] = %d\n", i, (*p)[i]);
    }
}
```

**指针与数组元素的关系**：

在C语言中，数组名和指针在很多情况下可以互换使用。数组名代表数组首元素的地址，可以通过指针算术运算来访问数组的任意元素。指针可以像数组一样使用下标操作符，数组也可以通过指针运算来访问。
```c
void pointer_array_relationship() {
    int a[5] = {10, 20, 30, 40, 50};
    int *p = a;  // 指向数组首元素
    
    printf("指针与数组元素的关系：\n");
    
    // 多种访问方式等价
    for (int i = 0; i < 5; i++) {
        printf("a[%d] = %d, ", i, a[i]);
        printf("*(a+%d) = %d, ", i, *(a + i));
        printf("p[%d] = %d, ", i, p[i]);
        printf("*(p+%d) = %d\n", i, *(p + i));
    }
    
    // 指针运算
    printf("\n指针运算示例：\n");
    printf("p指向: %d\n", *p);
    p++;  // 指向下一个元素
    printf("p++后指向: %d\n", *p);
    p += 2;  // 向前移动2个位置
    printf("p+=2后指向: %d\n", *p);
}
```

## 2. 动态内存管理

动态内存管理是C语言的重要特性，允许程序在运行时分配和释放内存。与静态内存分配不同，动态内存分配可以根据程序的实际需要来申请内存空间，提高了内存使用的灵活性和效率。

### 2.1 malloc函数

`malloc`函数用于动态分配内存空间。它是C标准库中最基本的内存分配函数，可以在程序运行时申请指定大小的内存块。

**函数原型**：
```c
void *malloc(size_t size);
```

**参数说明**：
- `size`：要分配的内存字节数
- 返回值：成功时返回指向分配内存的指针，失败时返回`NULL`

malloc函数从堆内存中分配连续的内存空间，返回的指针指向分配内存的起始地址。如果内存不足或分配失败，函数返回NULL指针。

**使用示例**：
```c
#include <stdio.h>
#include <stdlib.h>

void malloc_demo() {
    int *p;
    int n = 10;
    
    // 动态分配内存
    p = (int*)malloc(n * sizeof(int));
    
    if (p == NULL) {
        printf("内存分配失败！\n");
        return;
    }
    
    // 初始化数组
    for (int i = 0; i < n; i++) {
        p[i] = i * i;
    }
    
    // 打印数组
    printf("动态数组内容：\n");
    for (int i = 0; i < n; i++) {
        printf("p[%d] = %d\n", i, p[i]);
    }
    
    // 释放内存
    free(p);
    p = NULL;  // 避免野指针
}
```

### 2.2 free函数

`free`函数用于释放动态分配的内存。它是与malloc配对使用的函数，用于将之前分配的内存归还给系统，防止内存泄漏。

**函数原型**：
```c
void free(void *ptr);
```

**重要注意事项**：
- 只能释放由`malloc`、`calloc`、`realloc`分配的内存
- 释放后应将指针设为`NULL`，避免野指针
- 不能重复释放同一块内存
- 不能释放已经释放的内存

正确使用free函数是避免内存泄漏和程序崩溃的关键。每个malloc调用都应该有对应的free调用。

### 2.3 calloc函数

`calloc`函数分配内存并初始化为0。与malloc不同，calloc不仅分配内存，还会将分配的内存区域全部初始化为零值，这在某些情况下非常有用。

**函数原型**：
```c
void *calloc(size_t num, size_t size);
```

**参数说明**：
- `num`：要分配的元素个数
- `size`：每个元素的字节数
- 返回值：成功时返回指向分配内存的指针，失败时返回`NULL`

calloc实际分配的内存大小为 num * size 字节，并且所有字节都被初始化为0。这使得calloc特别适合分配数组或结构体数组。

```c
void calloc_demo() {
    int *arr;
    int n = 5;
    
    // 使用calloc分配并初始化为0
    arr = (int*)calloc(n, sizeof(int));
    
    if (arr == NULL) {
        printf("内存分配失败！\n");
        return;
    }
    
    printf("calloc分配的数组（自动初始化为0）：\n");
    for (int i = 0; i < n; i++) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }
    
    free(arr);
    arr = NULL;
}
```

### 2.4 realloc函数

`realloc`函数用于重新分配内存大小。它可以扩大或缩小已分配的内存块，是动态内存管理中的重要函数，能够在程序运行时调整内存大小以适应不同的需求。

**函数原型**：
```c
void *realloc(void *ptr, size_t size);
```

**参数说明**：
- `ptr`：指向之前用`malloc`、`calloc`或`realloc`分配的内存块的指针。如果为`NULL`，则`realloc`的行为等同于`malloc`
- `size`：新的内存块大小（以字节为单位）。如果为0，则等同于调用`free`
- `ptr`：之前分配的内存指针
- `size`：新的内存大小
- 返回值：成功时返回新内存的指针，失败时返回`NULL`

```c
void realloc_demo() {
    int *arr;
    int size = 3;
    
    // 初始分配
    arr = (int*)malloc(size * sizeof(int));
    if (arr == NULL) return;
    
    // 初始化
    for (int i = 0; i < size; i++) {
        arr[i] = i + 1;
    }
    
    printf("原始数组：\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    // 扩大数组
    size = 6;
    arr = (int*)realloc(arr, size * sizeof(int));
    if (arr == NULL) return;
    
    // 初始化新元素
    for (int i = 3; i < size; i++) {
        arr[i] = i + 1;
    }
    
    printf("扩大后的数组：\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    free(arr);
    arr = NULL;
}
```

## 3. 高级指针应用

### 3.1 指针与内存管理

C语言提供了四个主要的动态内存管理函数：

```c
#include <stdlib.h>
#include <string.h>

void dynamic_memory_functions() {
    // malloc: 分配指定字节数的内存
    int *ptr1 = malloc(sizeof(int));
    if (ptr1 != NULL) {
        *ptr1 = 42;
        printf("malloc分配的值: %d\n", *ptr1);
        free(ptr1);
    }
    
    // calloc: 分配并初始化为0
    int *ptr2 = calloc(5, sizeof(int));
    if (ptr2 != NULL) {
        printf("calloc分配的数组: ");
        for (int i = 0; i < 5; i++) {
            printf("%d ", ptr2[i]);  // 全部为0
        }
        printf("\n");
        free(ptr2);
    }
    
    // realloc: 重新分配内存大小
    int *ptr3 = malloc(3 * sizeof(int));
    if (ptr3 != NULL) {
        ptr3[0] = 1; ptr3[1] = 2; ptr3[2] = 3;
        
        // 扩展到5个元素
        ptr3 = realloc(ptr3, 5 * sizeof(int));
        if (ptr3 != NULL) {
            ptr3[3] = 4; ptr3[4] = 5;
            printf("realloc扩展后: ");
            for (int i = 0; i < 5; i++) {
                printf("%d ", ptr3[i]);
            }
            printf("\n");
            free(ptr3);
        }
    }
}
```

### 3.2 指针与动态数组

```c
#include <stdlib.h>

// 动态创建一维数组
int* create_dynamic_array(int size) {
    int *arr = malloc(size * sizeof(int));
    if (arr == NULL) {
        printf("内存分配失败\n");
        return NULL;
    }
    
    // 初始化数组
    for (int i = 0; i < size; i++) {
        arr[i] = i * i;
    }
    
    return arr;
}

// 动态创建二维数组
int** create_2d_array(int rows, int cols) {
    // 分配行指针数组
    int **arr = malloc(rows * sizeof(int*));
    if (arr == NULL) return NULL;
    
    // 为每行分配内存
    for (int i = 0; i < rows; i++) {
        arr[i] = malloc(cols * sizeof(int));
        if (arr[i] == NULL) {
            // 分配失败，释放已分配的内存
            for (int j = 0; j < i; j++) {
                free(arr[j]);
            }
            free(arr);
            return NULL;
        }
    }
    
    return arr;
}

// 释放二维数组
void free_2d_array(int **arr, int rows) {
    if (arr == NULL) return;
    
    for (int i = 0; i < rows; i++) {
        free(arr[i]);
    }
    free(arr);
}

void dynamic_array_demo() {
    // 一维动态数组
    int *arr1d = create_dynamic_array(5);
    if (arr1d != NULL) {
        printf("一维动态数组: ");
        for (int i = 0; i < 5; i++) {
            printf("%d ", arr1d[i]);
        }
        printf("\n");
        free(arr1d);
    }
    
    // 二维动态数组
    int **arr2d = create_2d_array(3, 4);
    if (arr2d != NULL) {
        // 初始化二维数组
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                arr2d[i][j] = i * 4 + j;
            }
        }
        
        // 打印二维数组
        printf("二维动态数组:\n");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                printf("%2d ", arr2d[i][j]);
            }
            printf("\n");
        }
        
        free_2d_array(arr2d, 3);
    }
}
```

## 4. 函数指针

### 4.1 函数指针基础

函数指针是指向函数的指针，可以用来实现回调函数和函数表：

```c
#include <stdio.h>

// 示例函数
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

void function_pointer_basics() {
    // 声明函数指针
    int (*operation)(int, int);
    
    // 函数指针赋值
    operation = add;
    printf("5 + 3 = %d\n", operation(5, 3));
    
    operation = subtract;
    printf("5 - 3 = %d\n", operation(5, 3));
    
    operation = multiply;
    printf("5 * 3 = %d\n", operation(5, 3));
}
```

### 4.2 函数指针数组

```c
// 计算器示例
void calculator_demo() {
    // 函数指针数组
    int (*operations[])(int, int) = {add, subtract, multiply};
    char *op_names[] = {"+", "-", "*"};
    
    int a = 10, b = 5;
    
    printf("使用函数指针数组:\n");
    for (int i = 0; i < 3; i++) {
        int result = operations[i](a, b);
        printf("%d %s %d = %d\n", a, op_names[i], b, result);
    }
}
```

## 5. 常见指针错误与最佳实践

### 5.1 常见错误

**空指针解引用**：
```c
// 错误示例
int *ptr = NULL;
*ptr = 10;  // 运行时错误！

// 正确做法
if (ptr != NULL) {
    *ptr = 10;
}
```

**野指针**：
```c
// 错误示例
int *ptr;
*ptr = 10;  // ptr未初始化，指向未知位置

// 正确做法
int *ptr = NULL;  // 初始化为NULL
int value = 0;
ptr = &value;     // 指向有效地址
*ptr = 10;
```

**内存泄漏**：
```c
// 错误示例
void memory_leak() {
    int *ptr = malloc(sizeof(int));
    *ptr = 42;
    // 忘记调用free(ptr)，造成内存泄漏
}

// 正确做法
void no_memory_leak() {
    int *ptr = malloc(sizeof(int));
    if (ptr != NULL) {
        *ptr = 42;
        free(ptr);
        ptr = NULL;  // 避免悬空指针
    }
}
```

**重复释放**：
```c
// 错误示例
int *ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // 重复释放，未定义行为

// 正确做法
int *ptr = malloc(sizeof(int));
free(ptr);
ptr = NULL;  // 设置为NULL防止重复释放
```

### 5.2 最佳实践

**内存管理原则**：
1. 每个malloc都要有对应的free
2. 释放后将指针设置为NULL
3. 检查malloc的返回值
4. 使用工具检测内存错误（如Valgrind）

```c
// 安全的内存分配函数
void* safe_malloc(size_t size) {
    void *ptr = malloc(size);
    if (ptr == NULL) {
        fprintf(stderr, "内存分配失败\n");
        exit(EXIT_FAILURE);
    }
    return ptr;
}

// 安全的内存释放宏
#define SAFE_FREE(ptr) do { \
    if (ptr) { \
        free(ptr); \
        ptr = NULL; \
    } \
} while(0)

void safe_memory_demo() {
    int *ptr = safe_malloc(sizeof(int));
    *ptr = 42;
    printf("值: %d\n", *ptr);
    
    SAFE_FREE(ptr);
    // ptr现在是NULL，再次调用SAFE_FREE是安全的
    SAFE_FREE(ptr);
}
```

## 6. 实践示例

### 6.1 动态字符串处理

```c
#include <string.h>

// 动态字符串连接
char* string_concat(const char *str1, const char *str2) {
    if (str1 == NULL || str2 == NULL) return NULL;
    
    size_t len1 = strlen(str1);
    size_t len2 = strlen(str2);
    
    char *result = malloc(len1 + len2 + 1);
    if (result == NULL) return NULL;
    
    strcpy(result, str1);
    strcat(result, str2);
    
    return result;
}

void string_demo() {
    char *str1 = "Hello, ";
    char *str2 = "World!";
    
    char *result = string_concat(str1, str2);
    if (result != NULL) {
        printf("连接结果: %s\n", result);
        free(result);
    }
}
```

### 6.2 简单链表实现

```c
// 链表节点结构
typedef struct Node {
    int data;
    struct Node *next;
} Node;

// 创建新节点
Node* create_node(int data) {
    Node *node = malloc(sizeof(Node));
    if (node != NULL) {
        node->data = data;
        node->next = NULL;
    }
    return node;
}

// 在链表头部插入节点
Node* insert_head(Node *head, int data) {
    Node *new_node = create_node(data);
    if (new_node != NULL) {
        new_node->next = head;
        head = new_node;
    }
    return head;
}

// 打印链表
void print_list(Node *head) {
    Node *current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

// 释放链表
void free_list(Node *head) {
    Node *current = head;
    while (current != NULL) {
        Node *temp = current;
        current = current->next;
        free(temp);
    }
}

void linked_list_demo() {
    Node *head = NULL;
    
    // 插入一些节点
    head = insert_head(head, 3);
    head = insert_head(head, 2);
    head = insert_head(head, 1);
    
    printf("链表内容: ");
    print_list(head);
    
    // 释放链表
    free_list(head);
}
```

## 总结

指针是C语言最强大也是最容易出错的特性。掌握指针需要理解：

1. **基本概念**：地址、值、类型三要素
2. **指针运算**：算术运算和与数组的关系
3. **动态内存**：malloc/free的正确使用
4. **函数指针**：实现回调和多态
5. **安全编程**：避免常见错误，遵循最佳实践

记住，使用指针时要始终保持谨慎，确保每个malloc都有对应的free，每次解引用前都要检查指针是否为NULL。良好的指针使用习惯是编写高质量C程序的关键。
