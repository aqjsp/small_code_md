# C语言指针与内存管理

目标：深入理解指针、数组与字符串的关系，掌握内存布局、指针算术、野指针与悬挂指针、const与restrict。

## 1. 指针基础
- 声明：int *p; p存储地址。
- 操作：&取址，*解引用；指针算术 p+1 移动sizeof(int)。
- NULL指针：#include <stddef.h>；用于哨兵，避免野指针。
- 陷阱：解引用NULL/无效指针导致未定义行为；指针类型不匹配。

## 2. 数组与指针
- 数组：int a[5]; a衰退为int*。
- 多维：int m[3][4]; 等价 int (*p)[4] = m;
- 指针数组 vs 数组指针：int *pa[5] vs int (*ap)[5];

## 3. 字符串
- char s[] = "hello"; 以'\0'结束。
- 字符串字面量不可修改；使用const char*。
- 函数如strcpy需小心缓冲溢出；优先strncpy。

## 4. const 与 restrict
- const：const int *p (指向const) vs int * const q (const指针) vs const int * const r。
- restrict (C99)：告知编译器指针无别名，启用优化；用于memcpy等。

## 5. 动态内存
- 分配：void* malloc(size_t)；calloc清零；realloc调整。
- 释放：free(p); p=NULL避免悬垂指针。
- 常见错误：内存泄漏（忘free）、use-after-free、double free。
- Valgrind等工具检测。

示例：
```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int n = 5;
    int *arr = malloc(n * sizeof *arr);
    if (!arr) return 1;
    for (int i = 0; i < n; ++i) arr[i] = i*i;
    for (int i = 0; i < n; ++i) printf("%d ", arr[i]);
    free(arr);
    return 0;
}
```

## 6. 示例
示例A：指针算术遍历数组
```c
int a[] = {1,2,3};
for(int *p=a; p<a+3; p++) printf("%d ", *p);
```

示例B：restrict优化示例
```c
void copy(int *restrict dst, const int *restrict src, size_t n) {
    for(size_t i=0; i<n; i++) dst[i]=src[i];
}
```

## 7. 练习
- 实现自己的strdup使用malloc。
- 写函数反转数组使用指针。
- 模拟二维数组动态分配。

## 更多练习参考答案
- strdup：计算len, malloc(len+1), memcpy, 返回。
- 反转：两指针从头尾交换至中间。
- 二维：malloc(rows * sizeof(int*)) then each row malloc(cols * sizeof(int))。