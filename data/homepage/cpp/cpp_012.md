# C++智能指针：shared_ptr与weak_ptr详解

## 1. 概述

在现代C++编程中，智能指针是内存管理的重要工具。shared_ptr和weak_ptr作为C++11引入的智能指针，提供了安全、高效的共享所有权管理机制。本章将深入探讨这两种智能指针的原理、使用方法和最佳实践。

## 2. shared_ptr：共享所有权

### 2.1 什么是shared_ptr？

shared_ptr是一个智能指针，允许多个指针实例共享同一个对象的所有权。当最后一个shared_ptr被销毁时，所管理的对象也会被自动删除。

```cpp
#include <memory>
#include <iostream>

int main() {
    // 创建shared_ptr
    std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
    
    // 共享所有权
    std::shared_ptr<int> ptr2 = ptr1;
    std::shared_ptr<int> ptr3 = ptr1;
    
    std::cout << "引用计数: " << ptr1.use_count() << std::endl; // 输出: 3
    std::cout << "值: " << *ptr1 << std::endl; // 输出: 42
    
    return 0;
} // 所有shared_ptr离开作用域，对象被自动删除
```

### 2.2 引用计数机制

shared_ptr使用引用计数来跟踪有多少个指针指向同一个对象：

**基本原理**：
- 每次复制shared_ptr时，引用计数+1
- 每次销毁shared_ptr时，引用计数-1
- 当引用计数变为0时，自动删除对象

```cpp
void demonstrateRefCount() {
    std::shared_ptr<std::string> ptr1;
    
    {
        auto ptr2 = std::make_shared<std::string>("Hello");
        std::cout << "ptr2计数: " << ptr2.use_count() << std::endl; // 1
        
        ptr1 = ptr2; // 复制，计数增加
        std::cout << "复制后计数: " << ptr2.use_count() << std::endl; // 2
        
    } // ptr2离开作用域，计数减少
    
    std::cout << "ptr1计数: " << ptr1.use_count() << std::endl; // 1
    std::cout << "值仍然有效: " << *ptr1 << std::endl; // "Hello"
}
```

### 2.3 创建shared_ptr的方法

**1. 使用make_shared（推荐）**
```cpp
auto ptr = std::make_shared<MyClass>(args);
```

**优势**：
- 一次内存分配（对象+控制块）
- 更好的缓存性能
- 异常安全

**2. 使用构造函数**
```cpp
std::shared_ptr<MyClass> ptr(new MyClass(args));
```

**缺点**：
- 两次内存分配
- 异常不安全（在某些情况下）

### 2.4 控制块概念

shared_ptr内部使用控制块来管理引用计数和其他信息：

```
shared_ptr结构:
┌─────────────┐    ┌─────────────┐
│   对象指针   │───→│    对象     │
├─────────────┤    └─────────────┘
│ 控制块指针   │───→┌─────────────┐
└─────────────┘    │  引用计数   │
                   ├─────────────┤
                   │  弱引用计数 │
                   ├─────────────┤
                   │   删除器    │
                   ├─────────────┤
                   │   分配器    │
                   └─────────────┘
```

## 3. weak_ptr：弱引用

### 3.1 什么是weak_ptr？

weak_ptr是一个不拥有对象的智能指针，它可以观察shared_ptr管理的对象，但不影响对象的生命周期。

```cpp
#include <memory>
#include <iostream>

int main() {
    std::weak_ptr<int> weak;
    
    {
        auto shared = std::make_shared<int>(42);
        weak = shared; // weak_ptr指向shared_ptr管理的对象
        
        std::cout << "对象存在: " << !weak.expired() << std::endl; // true
        
        // 安全访问对象
        if (auto locked = weak.lock()) {
            std::cout << "值: " << *locked << std::endl; // 42
        }
    } // shared离开作用域，对象被删除
    
    std::cout << "对象已销毁: " << weak.expired() << std::endl; // true
    
    return 0;
}
```

### 3.2 weak_ptr的主要用途

**1. 打破循环引用**
```cpp
class Parent;
class Child;

class Parent {
public:
    std::vector<std::shared_ptr<Child>> children;
    void addChild(std::shared_ptr<Child> child) {
        children.push_back(child);
    }
};

class Child {
public:
    std::weak_ptr<Parent> parent; // 使用weak_ptr避免循环引用
    
    void doSomething() {
        if (auto p = parent.lock()) {
            // 安全访问父对象
            std::cout << "父对象仍然存在" << std::endl;
        }
    }
};
```

**2. 缓存和观察者模式**
```cpp
class ResourceCache {
private:
    std::map<std::string, std::weak_ptr<Resource>> cache;
    
public:
    std::shared_ptr<Resource> getResource(const std::string& name) {
        auto it = cache.find(name);
        if (it != cache.end()) {
            if (auto resource = it->second.lock()) {
                return resource; // 缓存命中，返回现有资源
            } else {
                cache.erase(it); // 资源已过期，清理缓存
            }
        }
        
        // 创建新资源
        auto resource = std::make_shared<Resource>(name);
        cache[name] = resource;
        return resource;
    }
};
```

## 4. 循环引用问题

### 4.1 什么是循环引用？

循环引用发生在两个或多个对象通过shared_ptr相互引用，形成引用环：

```cpp
// 错误示例：循环引用导致内存泄漏
class Node {
public:
    std::shared_ptr<Node> next;
    std::shared_ptr<Node> prev; // 这里应该使用weak_ptr
    int data;
    
    Node(int val) : data(val) {}
    ~Node() {
        std::cout << "Node " << data << " 被销毁" << std::endl;
    }
};

void createCycle() {
    auto node1 = std::make_shared<Node>(1);
    auto node2 = std::make_shared<Node>(2);
    
    node1->next = node2;
    node2->prev = node1; // 形成循环引用
    
    // 函数结束时，node1和node2的引用计数都不为0
    // 导致内存泄漏！
}
```

### 4.2 解决循环引用

使用weak_ptr打破循环：

```cpp
class Node {
public:
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev; // 使用weak_ptr
    int data;
    
    Node(int val) : data(val) {}
    ~Node() {
        std::cout << "Node " << data << " 被销毁" << std::endl;
    }
    
    void setPrev(std::shared_ptr<Node> node) {
        prev = node;
    }
    
    std::shared_ptr<Node> getPrev() {
        return prev.lock(); // 安全获取前驱节点
    }
};

void createList() {
    auto node1 = std::make_shared<Node>(1);
    auto node2 = std::make_shared<Node>(2);
    
    node1->next = node2;
    node2->setPrev(node1); // 不会形成循环引用
    
    // 函数结束时，对象会被正确销毁
}
```

## 5. 线程安全特性

### 5.1 shared_ptr的线程安全保证

shared_ptr提供有限的线程安全保证：

**安全的操作**：
- 引用计数的修改（原子操作）
- 多个线程同时读取同一个shared_ptr
- 多个线程同时复制同一个shared_ptr

**不安全的操作**：
- 多个线程同时修改同一个shared_ptr对象
- 对shared_ptr指向的对象的并发访问

```cpp
#include <thread>
#include <vector>

void threadSafeExample() {
    auto shared = std::make_shared<int>(42);
    std::vector<std::thread> threads;
    
    // 安全：多个线程复制shared_ptr
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back([shared]() {
            auto local_copy = shared; // 线程安全的复制
            // 使用local_copy...
        });
    }
    
    for (auto& t : threads) {
        t.join();
    }
}

void threadUnsafeExample() {
    std::shared_ptr<int> shared = std::make_shared<int>(42);
    
    // 不安全：多个线程修改同一个shared_ptr
    std::thread t1([&shared]() {
        shared = std::make_shared<int>(100); // 危险！
    });
    
    std::thread t2([&shared]() {
        shared = std::make_shared<int>(200); // 危险！
    });
    
    t1.join();
    t2.join();
}
```

### 5.2 线程安全的使用模式

```cpp
class ThreadSafeCounter {
private:
    std::shared_ptr<std::atomic<int>> counter;
    
public:
    ThreadSafeCounter() : counter(std::make_shared<std::atomic<int>>(0)) {}
    
    void increment() {
        auto local = counter; // 获取当前shared_ptr的副本
        ++(*local); // 对原子变量进行操作
    }
    
    int get() const {
        auto local = counter;
        return local->load();
    }
};
```

## 6. 性能考虑

### 6.1 内存开销

```cpp
// 内存布局比较
sizeof(int*);                    // 8字节（64位系统）
sizeof(std::unique_ptr<int>);    // 8字节
sizeof(std::shared_ptr<int>);    // 16字节（对象指针+控制块指针）

// 控制块额外开销
// - 引用计数：4-8字节
// - 弱引用计数：4-8字节
// - 虚函数表指针：8字节
// - 删除器和分配器：可变大小
```

### 6.2 性能优化建议

**1. 优先使用make_shared**
```cpp
// 好：一次分配
auto ptr = std::make_shared<MyClass>(args);

// 差：两次分配
auto ptr = std::shared_ptr<MyClass>(new MyClass(args));
```

**2. 避免不必要的复制**
```cpp
// 好：传递引用
void process(const std::shared_ptr<Data>& data) {
    // 不增加引用计数
}

// 差：传递值
void process(std::shared_ptr<Data> data) {
    // 增加引用计数，可能导致原子操作
}
```

**3. 合理使用weak_ptr**
```cpp
// 好：临时访问使用weak_ptr
class Observer {
    std::weak_ptr<Subject> subject;
public:
    void update() {
        if (auto s = subject.lock()) {
            // 临时获取强引用
            s->doSomething();
        }
    }
};
```

## 7. 自定义删除器

shared_ptr支持自定义删除器，用于特殊的资源管理需求：

```cpp
#include <memory>
#include <cstdio>

// 文件资源管理
auto fileDeleter = [](FILE* f) {
    if (f) {
        std::fclose(f);
        std::cout << "文件已关闭" << std::endl;
    }
};

void fileExample() {
    FILE* f = std::fopen("test.txt", "w");
    if (f) {
        std::shared_ptr<FILE> file_ptr(f, fileDeleter);
        // 使用文件...
    } // 文件自动关闭
}

// 数组删除器
void arrayExample() {
    std::shared_ptr<int> arr(new int[10], [](int* p) {
        delete[] p;
        std::cout << "数组已删除" << std::endl;
    });
    
    // 或者使用std::default_delete
    std::shared_ptr<int> arr2(new int[10], std::default_delete<int[]>());
}
```

## 8. 设计原则与最佳实践

### 8.1 设计原则

#### 8.1.1 明确所有权语义
- 使用shared_ptr表达共享所有权
- 使用weak_ptr表达观察关系
- 避免混合使用原始指针和智能指针

#### 8.1.2 防止循环引用
- 识别潜在的循环引用场景
- 在适当位置使用weak_ptr
- 设计清晰的所有权层次结构

#### 8.1.3 线程安全考虑
- 理解shared_ptr的线程安全保证
- 保护对shared_ptr本身的并发修改
- 保护对指向对象的并发访问

### 8.2 常见陷阱

#### 8.2.1 从原始指针创建多个shared_ptr
```cpp
// 错误：导致重复删除
int* raw = new int(42);
std::shared_ptr<int> ptr1(raw);
std::shared_ptr<int> ptr2(raw); // 危险！两个独立的控制块
```

#### 8.2.2 循环引用导致内存泄漏
```cpp
// 错误：相互持有shared_ptr
class A {
    std::shared_ptr<B> b_ptr; // 应该考虑使用weak_ptr
};

class B {
    std::shared_ptr<A> a_ptr; // 应该考虑使用weak_ptr
};
```

#### 8.2.3 在构造函数中使用shared_from_this
```cpp
class MyClass : public std::enable_shared_from_this<MyClass> {
public:
    MyClass() {
        // 错误：对象还未完全构造
        auto self = shared_from_this(); // 抛出异常
    }
    
    void init() {
        // 正确：对象已完全构造
        auto self = shared_from_this();
    }
};
```

### 8.3 最佳实践

#### 8.3.1 工厂函数模式
```cpp
class MyClass {
private:
    MyClass(int value) : data(value) {} // 私有构造函数
    
public:
    static std::shared_ptr<MyClass> create(int value) {
        return std::shared_ptr<MyClass>(new MyClass(value));
    }
    
private:
    int data;
};
```

#### 8.3.2 资源管理包装器
```cpp
template<typename Resource, typename Deleter>
class ResourceWrapper {
private:
    std::shared_ptr<Resource> resource;
    
public:
    ResourceWrapper(Resource* res, Deleter del) 
        : resource(res, del) {}
    
    Resource* get() const { return resource.get(); }
    Resource& operator*() const { return *resource; }
    Resource* operator->() const { return resource.get(); }
};
```

#### 8.3.3 观察者模式实现
```cpp
class Subject {
private:
    std::vector<std::weak_ptr<Observer>> observers;
    
public:
    void addObserver(std::shared_ptr<Observer> obs) {
        observers.push_back(obs);
    }
    
    void notify() {
        // 清理过期的观察者
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [](const std::weak_ptr<Observer>& wp) {
                    return wp.expired();
                }),
            observers.end()
        );
        
        // 通知有效的观察者
        for (auto& wp : observers) {
            if (auto obs = wp.lock()) {
                obs->update();
            }
        }
    }
};
```

## 9. 学习建议

1. **理解概念**：先掌握引用计数和共享所有权的基本概念
2. **识别场景**：学会识别需要共享所有权的使用场景
3. **避免陷阱**：重点理解循环引用问题及其解决方案
4. **性能意识**：了解智能指针的性能特征和优化方法
5. **实践应用**：在实际项目中逐步应用这些概念

## 10. 总结

掌握shared_ptr和weak_ptr将帮助你：
- 安全地管理共享资源
- 避免内存泄漏和悬挂指针
- 实现复杂的对象关系
- 编写线程安全的代码
- 设计更清晰的API接口

shared_ptr和weak_ptr是现代C++内存管理的重要工具，它们提供了安全、高效的共享所有权管理机制。通过合理使用这些智能指针，你可以编写出更安全、更可维护的C++代码。

## 11. 进一步学习

- 深入研究智能指针的内部实现机制
- 学习更多RAII设计模式的应用
- 探索现代C++库中智能指针的使用案例
- 实践复杂项目中的内存管理策略
- 研究性能敏感场景下的智能指针优化技巧