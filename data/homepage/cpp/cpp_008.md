# C++运算符重载与类型转换机制

## 1. 核心概念

### 1.1 运算符重载的设计哲学

#### 语法糖的本质
运算符重载本质上是一种语法糖，它允许用户定义类型使用与内置类型相同的运算符语法。这种机制的核心目标是提高代码的可读性和直观性。

当我们为自定义类型重载运算符时，实际上是在定义特殊的成员函数或友元函数。编译器会将运算符表达式转换为相应的函数调用。

#### 语义一致性原则
运算符重载的首要原则是保持语义一致性。重载的运算符应该具有与内置类型运算符相似的行为和语义。违反这一原则会导致代码难以理解和维护。

例如，`+` 运算符应该表示某种形式的"加法"操作，而不应该用来表示完全无关的操作如文件删除。

#### 直观性与可预测性
好的运算符重载应该让用户能够直观地理解其行为。用户不应该需要查阅文档就能猜测运算符的大致功能。

### 1.2 成员函数 vs 非成员函数

#### 设计决策的考虑因素
选择将运算符实现为成员函数还是非成员函数是一个重要的设计决策，需要考虑多个因素：

**封装性考虑**：成员函数可以直接访问私有成员，而非成员函数需要通过公共接口访问。

**对称性要求**：对于需要对称性的运算符（如算术运算符），非成员函数通常是更好的选择，因为它们对两个操作数一视同仁。

**类型转换支持**：非成员函数可以对两个操作数都进行隐式类型转换，而成员函数只能对右操作数进行转换。

#### 修改性运算符的特殊性
修改左操作数的运算符（如 `+=`、`++`、`=`）通常应该实现为成员函数，因为它们需要修改对象的状态，这是成员函数的天然职责。

### 1.3 运算符重载的分类

#### 算术运算符
算术运算符包括基本的数学运算，如加法、减法、乘法、除法等。设计时需要考虑：

**返回值优化**：算术运算符通常返回新对象，需要考虑返回值优化（RVO）和移动语义。

**复合赋值的基础**：通常先实现复合赋值运算符（如 `+=`），然后基于它实现对应的算术运算符。

**类型提升和精度**：需要考虑不同类型之间运算时的类型提升和精度保持。

#### 比较运算符
比较运算符用于确定对象之间的关系。设计时的关键考虑：

**等价性 vs 相等性**：需要区分数学上的等价和程序中的相等概念。

**严格弱序**：排序相关的比较运算符必须满足严格弱序的数学性质。

**一致性要求**：各个比较运算符之间应该保持逻辑一致性。

#### 特殊运算符
包括下标运算符、函数调用运算符等具有特殊用途的运算符：

**下标运算符**：需要提供const和非const版本，考虑边界检查和性能权衡。

**函数调用运算符**：用于创建函数对象，是函数式编程的重要工具。

## 2. 类型转换机制

### 2.1 隐式转换的设计权衡

#### 便利性与安全性的平衡
隐式类型转换提供了编程便利性，但也可能导致意外的行为。设计时需要在便利性和安全性之间找到平衡。

**转换构造函数**：接受单个参数的构造函数会创建隐式转换路径。这种转换可能导致意外的对象创建。

**转换运算符**：允许对象隐式转换为其他类型。过度使用可能导致类型系统的混乱。

#### explicit关键字的作用
`explicit` 关键字是控制隐式转换的重要工具。它要求转换必须显式进行，从而提高代码的安全性和可读性。

使用 `explicit` 的指导原则：当转换可能导致意外行为或性能问题时，应该使用 `explicit`。

### 2.2 显式转换的最佳实践

#### 命名转换函数
相比于转换运算符，命名转换函数提供了更好的语义表达：

**语义明确性**：函数名可以清楚地表达转换的意图和可能的副作用。

**参数化能力**：可以接受参数，提供更灵活的转换选项。

**错误处理**：可以通过返回值或异常提供更好的错误处理机制。

#### 工厂函数模式
静态工厂方法是创建对象的推荐模式，它比转换构造函数提供了更好的控制和语义表达。

### 2.3 现代C++的类型转换

#### 强制转换运算符
现代C++提供了四种专门的强制转换运算符，每种都有特定的用途：

**static_cast**：用于编译时可以确定安全性的转换，性能开销最小。

**dynamic_cast**：用于多态类型的安全向下转换，依赖RTTI，有运行时开销。

**const_cast**：专门用于添加或移除const属性。

**reinterpret_cast**：用于低级的位模式重解释，最危险但有时必需。

#### 类型特征与编译时检查
C++11引入的type_traits库提供了丰富的编译时类型检查工具，为安全的类型转换提供了基础。

C++20的概念（Concepts）进一步提升了类型约束的表达能力，使得类型转换更加安全和直观。

## 3. 泛型编程中的运算符

### 3.1 概念约束与运算符要求

#### 算法的运算符依赖
STL算法对类型的运算符有特定要求。理解这些要求对于设计与标准库兼容的类型至关重要。

**可排序性**：排序算法要求类型支持比较运算符，且满足严格弱序。

**可累加性**：数值算法要求类型支持算术运算符，且满足相应的数学性质。

#### 运算符语义的数学性质
在泛型编程中，运算符的数学性质（如结合律、交换律、分配律）变得特别重要，因为算法的正确性往往依赖于这些性质。

### 3.2 表达式模板技术

#### 延迟求值的概念
表达式模板是一种高级技术，通过延迟计算的执行来优化性能。它构建表达式树而不是立即执行计算。

**循环融合**：多个运算可以在一个循环中完成，避免中间结果的存储。

**内存效率**：减少临时对象的创建和内存访问次数。

## 4. 设计原则与最佳实践

### 4.1 核心设计原则

#### 最小惊讶原则
运算符的行为应该符合用户的直觉预期。这是所有其他设计原则的基础。

#### 一致性维护
运算符重载应该与语言的内置运算符保持一致的语义，不仅体现在单个运算符上，也体现在运算符之间的关系上。

#### 性能与安全的平衡
在大多数情况下应该优先考虑安全性，但在性能关键的场景中可能需要做出权衡。这种权衡应该是明确和有文档记录的。

### 4.2 现代C++的最佳实践

#### RAII与异常安全
在实现运算符重载时，应该遵循RAII原则，确保资源的正确管理。运算符重载中的异常安全性往往依赖于正确的资源管理。

#### 移动语义的利用
现代C++的移动语义为运算符重载提供了新的优化机会。通过正确实现移动构造函数和移动赋值运算符，可以显著提高性能。

#### 模板与概念的结合
现代C++鼓励编写泛型代码，运算符重载也不例外。概念提供了表达类型约束的强大工具，使得泛型运算符更加安全和高效。

## 5. 常见陷阱与注意事项

### 5.1 设计陷阱

#### 过度重载
不是所有操作都适合用运算符表示。过度重载会降低代码的可读性。

#### 语义不一致
重载的运算符与用户期望的语义不符，会导致代码难以理解和维护。

#### 性能陷阱
某些运算符重载可能隐藏了昂贵的操作，用户可能无法察觉性能问题。

### 5.2 类型转换陷阱

#### 意外的转换
隐式类型转换可能导致意外的行为，特别是在重载决议过程中。

#### 转换链
多个隐式转换的链式调用可能导致难以预测的结果。

## 6. 学习建议

### 6.1 渐进式学习路径

1. **基础理解**：先理解运算符重载的基本概念和语法
2. **设计原则**：学习好的运算符重载的设计原则
3. **类型转换**：深入理解类型转换机制
4. **泛型应用**：学习在泛型编程中的应用
5. **高级技术**：掌握表达式模板等高级技术

### 6.2 实践建议

- 从简单的算术类型开始练习运算符重载
- 研究标准库中的运算符重载实现
- 注重代码的可读性和直观性
- 重视异常安全和性能考虑
- 积极使用现代C++特性

运算符重载和类型转换是C++的强大特性，它们为用户定义类型提供了与内置类型相同的语法便利性。正确使用这些特性可以创建既高效又安全的代码，为用户提供优秀的编程体验。关键是要平衡便利性、安全性和性能，始终以用户的使用体验为中心进行设计。

### 6.3 现代C++类型转换操作符

**类型转换操作符的完整演示**

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <typeinfo>

// 基类用于演示dynamic_cast
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() const = 0;
    virtual double getArea() const = 0;
};

class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : radius(r) {}
    
    void draw() const override {
        std::cout << "绘制圆形，半径: " << radius << std::endl;
    }
    
    double getArea() const override {
        return 3.14159 * radius * radius;
    }
    
    double getRadius() const { return radius; }
    
    // Circle特有的方法
    void roll() const {
        std::cout << "圆形滚动中..." << std::endl;
    }
};

class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    void draw() const override {
        std::cout << "绘制矩形，尺寸: " << width << "x" << height << std::endl;
    }
    
    double getArea() const override {
        return width * height;
    }
    
    // Rectangle特有的方法
    void fold() const {
        std::cout << "矩形折叠中..." << std::endl;
    }
};

// 演示各种类型转换
void demonstrateTypeCasting() {
    std::cout << "=== C++类型转换演示 ===" << std::endl;
    
    // 1. static_cast - 编译时类型转换
    std::cout << "\n1. static_cast 演示:" << std::endl;
    
    // 基本类型转换
    int intValue = 42;
    double doubleValue = static_cast<double>(intValue);
    std::cout << "int " << intValue << " -> double " << doubleValue << std::endl;
    
    // 指针类型转换（向上转换）
    Circle circle(5.0);
    Shape* shapePtr = static_cast<Shape*>(&circle);
    std::cout << "Circle* -> Shape*: ";
    shapePtr->draw();
    
    // 2. dynamic_cast - 运行时类型检查
    std::cout << "\n2. dynamic_cast 演示:" << std::endl;
    
    std::vector<std::unique_ptr<Shape>> shapes;
    shapes.push_back(std::make_unique<Circle>(3.0));
    shapes.push_back(std::make_unique<Rectangle>(4.0, 5.0));
    shapes.push_back(std::make_unique<Circle>(2.5));
    
    for (const auto& shape : shapes) {
        shape->draw();
        
        // 尝试转换为Circle
        if (Circle* circlePtr = dynamic_cast<Circle*>(shape.get())) {
            std::cout << "  -> 这是一个圆形，半径: " << circlePtr->getRadius() << std::endl;
            circlePtr->roll();
        }
        // 尝试转换为Rectangle
        else if (Rectangle* rectPtr = dynamic_cast<Rectangle*>(shape.get())) {
            std::cout << "  -> 这是一个矩形" << std::endl;
            rectPtr->fold();
        }
        std::cout << std::endl;
    }
    
    // 3. const_cast - 移除或添加const限定符
    std::cout << "3. const_cast 演示:" << std::endl;
    
    const int constValue = 100;
    const int* constPtr = &constValue;
    
    // 移除const（注意：修改原本const的对象是未定义行为）
    int* nonConstPtr = const_cast<int*>(constPtr);
    std::cout << "const int* -> int*: " << *nonConstPtr << std::endl;
    
    // 更安全的用法：添加const
    int mutableValue = 200;
    int* mutablePtr = &mutableValue;
    const int* constifiedPtr = const_cast<const int*>(mutablePtr);
    std::cout << "int* -> const int*: " << *constifiedPtr << std::endl;
    
    // 4. reinterpret_cast - 低级别类型重新解释
    std::cout << "\n4. reinterpret_cast 演示:" << std::endl;
    
    int number = 0x41424344;  // ASCII: "ABCD"
    char* charPtr = reinterpret_cast<char*>(&number);
    
    std::cout << "int 0x" << std::hex << number << " 重新解释为字符: ";
    for (int i = 0; i < 4; ++i) {
        if (charPtr[i] != 0) {
            std::cout << charPtr[i];
        }
    }
    std::cout << std::dec << std::endl;
    
    // 指针与整数之间的转换
    void* voidPtr = &number;
    uintptr_t address = reinterpret_cast<uintptr_t>(voidPtr);
    std::cout << "指针地址: 0x" << std::hex << address << std::dec << std::endl;
}

// 自定义类型转换示例
class Temperature {
private:
    double celsius;
    
public:
    // 转换构造函数（隐式转换）
    Temperature(double c) : celsius(c) {
        std::cout << "从double创建Temperature: " << c << "°C" << std::endl;
    }
    
    // explicit构造函数（显式转换）
    explicit Temperature(int fahrenheit_int) 
        : celsius((fahrenheit_int - 32) * 5.0 / 9.0) {
        std::cout << "从int(华氏度)创建Temperature: " << fahrenheit_int << "°F -> " 
                  << celsius << "°C" << std::endl;
    }
    
    // 类型转换运算符（隐式转换到double）
    operator double() const {
        std::cout << "Temperature转换为double: " << celsius << std::endl;
        return celsius;
    }
    
    // explicit类型转换运算符（显式转换到int）
    explicit operator int() const {
        std::cout << "Temperature显式转换为int: " << static_cast<int>(celsius) << std::endl;
        return static_cast<int>(celsius);
    }
    
    // 显式转换函数
    double toFahrenheit() const {
        return celsius * 9.0 / 5.0 + 32;
    }
    
    void display() const {
        std::cout << "温度: " << celsius << "°C (" << toFahrenheit() << "°F)" << std::endl;
    }
};

void demonstrateCustomConversions() {
    std::cout << "\n=== 自定义类型转换演示 ===" << std::endl;
    
    // 隐式转换构造函数
    Temperature temp1 = 25.5;  // double -> Temperature
    temp1.display();
    
    // 显式转换构造函数
    Temperature temp2(77);     // int -> Temperature (explicit)
    temp2.display();
    
    // 隐式类型转换运算符
    double celsius = temp1;    // Temperature -> double
    std::cout << "提取的摄氏度: " << celsius << std::endl;
    
    // 显式类型转换运算符
    int temp_int = static_cast<int>(temp2);  // Temperature -> int
    std::cout << "提取的整数温度: " << temp_int << std::endl;
    
    // 函数参数中的隐式转换
    auto printTemp = [](Temperature t) {
        std::cout << "函数参数转换: ";
        t.display();
    };
    
    printTemp(30.0);  // double隐式转换为Temperature
}

int main() {
    demonstrateTypeCasting();
    demonstrateCustomConversions();
    return 0;
}
```

## 7. 运算符重载的实践应用

### 完整的复数类实现

**复数类的运算符重载示例**

```cpp
#include <iostream>
#include <cmath>
#include <sstream>

class Complex {
private:
    double real, imag;
    
public:
    // 构造函数
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}
    
    // 拷贝构造函数
    Complex(const Complex& other) : real(other.real), imag(other.imag) {
        std::cout << "拷贝构造: " << *this << std::endl;
    }
    
    // 移动构造函数
    Complex(Complex&& other) noexcept : real(other.real), imag(other.imag) {
        std::cout << "移动构造: " << *this << std::endl;
        other.real = other.imag = 0.0;
    }
    
    // 赋值运算符
    Complex& operator=(const Complex& other) {
        if (this != &other) {
            real = other.real;
            imag = other.imag;
            std::cout << "拷贝赋值: " << *this << std::endl;
        }
        return *this;
    }
    
    // 移动赋值运算符
    Complex& operator=(Complex&& other) noexcept {
        if (this != &other) {
            real = other.real;
            imag = other.imag;
            other.real = other.imag = 0.0;
            std::cout << "移动赋值: " << *this << std::endl;
        }
        return *this;
    }
    
    // 算术运算符（成员函数）
    Complex& operator+=(const Complex& other) {
        real += other.real;
        imag += other.imag;
        return *this;
    }
    
    Complex& operator-=(const Complex& other) {
        real -= other.real;
        imag -= other.imag;
        return *this;
    }
    
    Complex& operator*=(const Complex& other) {
        double newReal = real * other.real - imag * other.imag;
        double newImag = real * other.imag + imag * other.real;
        real = newReal;
        imag = newImag;
        return *this;
    }
    
    Complex& operator/=(const Complex& other) {
        double denominator = other.real * other.real + other.imag * other.imag;
        if (denominator == 0.0) {
            throw std::runtime_error("除零错误");
        }
        
        double newReal = (real * other.real + imag * other.imag) / denominator;
        double newImag = (imag * other.real - real * other.imag) / denominator;
        real = newReal;
        imag = newImag;
        return *this;
    }
    
    // 一元运算符
    Complex operator+() const {
        return *this;
    }
    
    Complex operator-() const {
        return Complex(-real, -imag);
    }
    
    // 前置递增
    Complex& operator++() {
        ++real;
        return *this;
    }
    
    // 后置递增
    Complex operator++(int) {
        Complex temp(*this);
        ++real;
        return temp;
    }
    
    // 前置递减
    Complex& operator--() {
        --real;
        return *this;
    }
    
    // 后置递减
    Complex operator--(int) {
        Complex temp(*this);
        --real;
        return temp;
    }
    
    // 比较运算符
    bool operator==(const Complex& other) const {
        return std::abs(real - other.real) < 1e-9 && 
               std::abs(imag - other.imag) < 1e-9;
    }
    
    bool operator!=(const Complex& other) const {
        return !(*this == other);
    }
    
    // 类型转换运算符
    explicit operator bool() const {
        return real != 0.0 || imag != 0.0;
    }
    
    explicit operator double() const {
        return magnitude();
    }
    
    // 辅助函数
    double magnitude() const {
        return std::sqrt(real * real + imag * imag);
    }
    
    double phase() const {
        return std::atan2(imag, real);
    }
    
    Complex conjugate() const {
        return Complex(real, -imag);
    }
    
    // 访问器
    double getReal() const { return real; }
    double getImag() const { return imag; }
    
    // 友元函数声明
    friend Complex operator+(const Complex& lhs, const Complex& rhs);
    friend Complex operator-(const Complex& lhs, const Complex& rhs);
    friend Complex operator*(const Complex& lhs, const Complex& rhs);
    friend Complex operator/(const Complex& lhs, const Complex& rhs);
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
    friend std::istream& operator>>(std::istream& is, Complex& c);
};

// 二元算术运算符（非成员函数）
Complex operator+(const Complex& lhs, const Complex& rhs) {
    return Complex(lhs.real + rhs.real, lhs.imag + rhs.imag);
}

Complex operator-(const Complex& lhs, const Complex& rhs) {
    return Complex(lhs.real - rhs.real, lhs.imag - rhs.imag);
}

Complex operator*(const Complex& lhs, const Complex& rhs) {
    return Complex(lhs.real * rhs.real - lhs.imag * rhs.imag,
                   lhs.real * rhs.imag + lhs.imag * rhs.real);
}

Complex operator/(const Complex& lhs, const Complex& rhs) {
    double denominator = rhs.real * rhs.real + rhs.imag * rhs.imag;
    if (denominator == 0.0) {
        throw std::runtime_error("除零错误");
    }
    
    return Complex((lhs.real * rhs.real + lhs.imag * rhs.imag) / denominator,
                   (lhs.imag * rhs.real - lhs.real * rhs.imag) / denominator);
}

// 流运算符
std::ostream& operator<<(std::ostream& os, const Complex& c) {
    if (c.imag >= 0) {
        os << c.real << " + " << c.imag << "i";
    } else {
        os << c.real << " - " << (-c.imag) << "i";
    }
    return os;
}

std::istream& operator>>(std::istream& is, Complex& c) {
    std::cout << "输入实部: ";
    is >> c.real;
    std::cout << "输入虚部: ";
    is >> c.imag;
    return is;
}

// 复数运算演示
void demonstrateComplexOperations() {
    std::cout << "=== 复数运算符重载演示 ===" << std::endl;
    
    // 创建复数
    Complex c1(3.0, 4.0);
    Complex c2(1.0, -2.0);
    Complex c3;
    
    std::cout << "c1 = " << c1 << std::endl;
    std::cout << "c2 = " << c2 << std::endl;
    std::cout << "c3 = " << c3 << std::endl;
    
    // 算术运算
    std::cout << "\n算术运算:" << std::endl;
    std::cout << "c1 + c2 = " << (c1 + c2) << std::endl;
    std::cout << "c1 - c2 = " << (c1 - c2) << std::endl;
    std::cout << "c1 * c2 = " << (c1 * c2) << std::endl;
    std::cout << "c1 / c2 = " << (c1 / c2) << std::endl;
    
    // 复合赋值运算
    std::cout << "\n复合赋值运算:" << std::endl;
    c3 = c1;
    std::cout << "c3 = c1: " << c3 << std::endl;
    
    c3 += c2;
    std::cout << "c3 += c2: " << c3 << std::endl;
    
    c3 *= Complex(2.0, 0.0);
    std::cout << "c3 *= (2+0i): " << c3 << std::endl;
    
    // 一元运算符
    std::cout << "\n一元运算符:" << std::endl;
    std::cout << "+c1 = " << (+c1) << std::endl;
    std::cout << "-c1 = " << (-c1) << std::endl;
    
    Complex c4 = c1;
    std::cout << "c4 = " << c4 << std::endl;
    std::cout << "++c4 = " << (++c4) << std::endl;
    std::cout << "c4++ = " << (c4++) << std::endl;
    std::cout << "c4 = " << c4 << std::endl;
    
    // 比较运算符
    std::cout << "\n比较运算符:" << std::endl;
    std::cout << "c1 == c2: " << (c1 == c2) << std::endl;
    std::cout << "c1 != c2: " << (c1 != c2) << std::endl;
    
    Complex c5(3.0, 4.0);
    std::cout << "c1 == c5: " << (c1 == c5) << std::endl;
    
    // 类型转换
    std::cout << "\n类型转换:" << std::endl;
    std::cout << "c1的模长: " << static_cast<double>(c1) << std::endl;
    std::cout << "c1是否非零: " << static_cast<bool>(c1) << std::endl;
    std::cout << "c3是否非零: " << static_cast<bool>(c3) << std::endl;
    
    // 辅助函数
    std::cout << "\n辅助函数:" << std::endl;
    std::cout << "c1的模长: " << c1.magnitude() << std::endl;
    std::cout << "c1的相位: " << c1.phase() << " 弧度" << std::endl;
    std::cout << "c1的共轭: " << c1.conjugate() << std::endl;
}

int main() {
    try {
        demonstrateComplexOperations();
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 智能指针的运算符重载

**自定义智能指针实现**

```cpp
#include <iostream>
#include <memory>
#include <utility>

template<typename T>
class SmartPtr {
private:
    T* ptr;
    size_t* ref_count;
    
    void cleanup() {
        if (ref_count && --(*ref_count) == 0) {
            delete ptr;
            delete ref_count;
            std::cout << "资源已清理" << std::endl;
        }
    }
    
public:
    // 构造函数
    explicit SmartPtr(T* p = nullptr) 
        : ptr(p), ref_count(p ? new size_t(1) : nullptr) {
        if (ptr) {
            std::cout << "SmartPtr创建，引用计数: " << *ref_count << std::endl;
        }
    }
    
    // 拷贝构造函数
    SmartPtr(const SmartPtr& other) 
        : ptr(other.ptr), ref_count(other.ref_count) {
        if (ref_count) {
            ++(*ref_count);
            std::cout << "SmartPtr拷贝，引用计数: " << *ref_count << std::endl;
        }
    }
    
    // 移动构造函数
    SmartPtr(SmartPtr&& other) noexcept 
        : ptr(other.ptr), ref_count(other.ref_count) {
        other.ptr = nullptr;
        other.ref_count = nullptr;
        std::cout << "SmartPtr移动构造" << std::endl;
    }
    
    // 析构函数
    ~SmartPtr() {
        cleanup();
    }
    
    // 赋值运算符
    SmartPtr& operator=(const SmartPtr& other) {
        if (this != &other) {
            cleanup();
            ptr = other.ptr;
            ref_count = other.ref_count;
            if (ref_count) {
                ++(*ref_count);
                std::cout << "SmartPtr赋值，引用计数: " << *ref_count << std::endl;
            }
        }
        return *this;
    }
    
    // 移动赋值运算符
    SmartPtr& operator=(SmartPtr&& other) noexcept {
        if (this != &other) {
            cleanup();
            ptr = other.ptr;
            ref_count = other.ref_count;
            other.ptr = nullptr;
            other.ref_count = nullptr;
            std::cout << "SmartPtr移动赋值" << std::endl;
        }
        return *this;
    }
    
    // 解引用运算符
    T& operator*() const {
        if (!ptr) {
            throw std::runtime_error("解引用空指针");
        }
        return *ptr;
    }
    
    // 成员访问运算符
    T* operator->() const {
        if (!ptr) {
            throw std::runtime_error("访问空指针成员");
        }
        return ptr;
    }
    
    // 数组下标运算符
    T& operator[](size_t index) const {
        if (!ptr) {
            throw std::runtime_error("访问空指针数组");
        }
        return ptr[index];
    }
    
    // 布尔转换运算符
    explicit operator bool() const {
        return ptr != nullptr;
    }
    
    // 比较运算符
    bool operator==(const SmartPtr& other) const {
        return ptr == other.ptr;
    }
    
    bool operator!=(const SmartPtr& other) const {
        return ptr != other.ptr;
    }
    
    bool operator<(const SmartPtr& other) const {
        return ptr < other.ptr;
    }
    
    // 与原始指针比较
    bool operator==(const T* rawPtr) const {
        return ptr == rawPtr;
    }
    
    bool operator!=(const T* rawPtr) const {
        return ptr != rawPtr;
    }
    
    // 获取原始指针
    T* get() const {
        return ptr;
    }
    
    // 获取引用计数
    size_t use_count() const {
        return ref_count ? *ref_count : 0;
    }
    
    // 重置指针
    void reset(T* newPtr = nullptr) {
        cleanup();
        ptr = newPtr;
        ref_count = newPtr ? new size_t(1) : nullptr;
        if (ptr) {
            std::cout << "SmartPtr重置，引用计数: " << *ref_count << std::endl;
        }
    }
};

// 测试类
class TestClass {
private:
    int value;
    std::string name;
    
public:
    TestClass(int v, const std::string& n) : value(v), name(n) {
        std::cout << "TestClass构造: " << name << "(" << value << ")" << std::endl;
    }
    
    ~TestClass() {
        std::cout << "TestClass析构: " << name << "(" << value << ")" << std::endl;
    }
    
    void display() const {
        std::cout << "TestClass: " << name << " = " << value << std::endl;
    }
    
    int getValue() const { return value; }
    const std::string& getName() const { return name; }
    
    void setValue(int v) { value = v; }
};

void demonstrateSmartPtr() {
    std::cout << "=== 智能指针运算符重载演示 ===" << std::endl;
    
    // 创建智能指针
    SmartPtr<TestClass> ptr1(new TestClass(42, "对象1"));
    
    // 解引用运算符
    std::cout << "\n解引用运算符:" << std::endl;
    (*ptr1).display();
    
    // 成员访问运算符
    std::cout << "\n成员访问运算符:" << std::endl;
    ptr1->display();
    std::cout << "值: " << ptr1->getValue() << std::endl;
    
    // 拷贝构造
    std::cout << "\n拷贝构造:" << std::endl;
    SmartPtr<TestClass> ptr2 = ptr1;
    std::cout << "ptr1引用计数: " << ptr1.use_count() << std::endl;
    std::cout << "ptr2引用计数: " << ptr2.use_count() << std::endl;
    
    // 布尔转换
    std::cout << "\n布尔转换:" << std::endl;
    if (ptr1) {
        std::cout << "ptr1不为空" << std::endl;
    }
    
    SmartPtr<TestClass> ptr3;
    if (!ptr3) {
        std::cout << "ptr3为空" << std::endl;
    }
    
    // 比较运算符
    std::cout << "\n比较运算符:" << std::endl;
    std::cout << "ptr1 == ptr2: " << (ptr1 == ptr2) << std::endl;
    std::cout << "ptr1 != ptr3: " << (ptr1 != ptr3) << std::endl;
    
    // 赋值运算符
    std::cout << "\n赋值运算符:" << std::endl;
    ptr3 = ptr1;
    std::cout << "ptr1引用计数: " << ptr1.use_count() << std::endl;
    
    // 重置指针
    std::cout << "\n重置指针:" << std::endl;
    ptr3.reset(new TestClass(100, "对象2"));
    std::cout << "ptr1引用计数: " << ptr1.use_count() << std::endl;
    std::cout << "ptr3引用计数: " << ptr3.use_count() << std::endl;
    
    // 移动语义
    std::cout << "\n移动语义:" << std::endl;
    SmartPtr<TestClass> ptr4 = std::move(ptr3);
    std::cout << "移动后ptr3引用计数: " << ptr3.use_count() << std::endl;
    std::cout << "移动后ptr4引用计数: " << ptr4.use_count() << std::endl;
    
    if (ptr4) {
        ptr4->display();
    }
}

int main() {
    try {
        demonstrateSmartPtr();
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    std::cout << "\n程序结束，观察析构顺序..." << std::endl;
    return 0;
}