# C++设计模式与架构设计

### 1. 设计模式基础

#### 什么是设计模式？

**设计模式**是解决特定设计问题的可复用解决方案，包含四个基本要素：
- **模式名称**：便于交流的标识
- **问题**：何时使用该模式
- **解决方案**：设计的组成元素
- **效果**：应用模式的结果和权衡

#### 模式的分类

1. **创建型模式**：对象创建机制
2. **结构型模式**：对象组合方式
3. **行为型模式**：对象间的职责分配

### 2. 创建型模式

#### 单例模式（Singleton）

**用途**：确保一个类只有一个实例，并提供全局访问点。

```cpp
class Singleton {
private:
    static Singleton* instance;
    static std::mutex mutex_;
    
    // 私有构造函数
    Singleton() = default;
    
public:
    // 删除拷贝构造和赋值操作
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static Singleton* getInstance() {
        std::lock_guard<std::mutex> lock(mutex_);
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
};

// 现代C++的线程安全实现
class ModernSingleton {
public:
    static ModernSingleton& getInstance() {
        static ModernSingleton instance;  // C++11保证线程安全
        return instance;
    }
    
private:
    ModernSingleton() = default;
    ~ModernSingleton() = default;
    ModernSingleton(const ModernSingleton&) = delete;
    ModernSingleton& operator=(const ModernSingleton&) = delete;
};
```

**使用场景**：
- 配置管理器
- 日志记录器
- 数据库连接池
- 缓存管理器

#### 工厂模式（Factory）

**用途**：创建对象而不暴露创建逻辑，通过公共接口引用新创建的对象。

```cpp
// 产品接口
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() = 0;
};

// 具体产品
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "绘制圆形\n";
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "绘制矩形\n";
    }
};

// 简单工厂
class ShapeFactory {
public:
    enum class ShapeType { CIRCLE, RECTANGLE };
    
    static std::unique_ptr<Shape> createShape(ShapeType type) {
        switch (type) {
            case ShapeType::CIRCLE:
                return std::make_unique<Circle>();
            case ShapeType::RECTANGLE:
                return std::make_unique<Rectangle>();
            default:
                return nullptr;
        }
    }
};

// 使用示例
auto circle = ShapeFactory::createShape(ShapeFactory::ShapeType::CIRCLE);
circle->draw();
```

#### 建造者模式（Builder）

**用途**：构建复杂对象，将构建过程和表示分离。

```cpp
class Computer {
private:
    std::string cpu_;
    std::string memory_;
    std::string storage_;
    std::string graphics_;

public:
    void setCPU(const std::string& cpu) { cpu_ = cpu; }
    void setMemory(const std::string& memory) { memory_ = memory; }
    void setStorage(const std::string& storage) { storage_ = storage; }
    void setGraphics(const std::string& graphics) { graphics_ = graphics; }
    
    void showSpecs() const {
        std::cout << "CPU: " << cpu_ << "\n"
                  << "内存: " << memory_ << "\n"
                  << "存储: " << storage_ << "\n"
                  << "显卡: " << graphics_ << "\n";
    }
};

class ComputerBuilder {
private:
    std::unique_ptr<Computer> computer_;

public:
    ComputerBuilder() : computer_(std::make_unique<Computer>()) {}
    
    ComputerBuilder& setCPU(const std::string& cpu) {
        computer_->setCPU(cpu);
        return *this;
    }
    
    ComputerBuilder& setMemory(const std::string& memory) {
        computer_->setMemory(memory);
        return *this;
    }
    
    ComputerBuilder& setStorage(const std::string& storage) {
        computer_->setStorage(storage);
        return *this;
    }
    
    ComputerBuilder& setGraphics(const std::string& graphics) {
        computer_->setGraphics(graphics);
        return *this;
    }
    
    std::unique_ptr<Computer> build() {
        return std::move(computer_);
    }
};

// 使用示例
auto computer = ComputerBuilder()
    .setCPU("Intel i7")
    .setMemory("16GB DDR4")
    .setStorage("1TB SSD")
    .setGraphics("RTX 3080")
    .build();
```

### 3. 结构型模式

#### 适配器模式（Adapter）

**用途**：让不兼容的接口能够协同工作。

```cpp
// 目标接口
class Target {
public:
    virtual ~Target() = default;
    virtual void request() = 0;
};

// 需要适配的类
class Adaptee {
public:
    void specificRequest() {
        std::cout << "特殊请求处理\n";
    }
};

// 适配器
class Adapter : public Target {
private:
    std::unique_ptr<Adaptee> adaptee_;

public:
    Adapter(std::unique_ptr<Adaptee> adaptee) 
        : adaptee_(std::move(adaptee)) {}
    
    void request() override {
        adaptee_->specificRequest();
    }
};

// 使用示例
auto adaptee = std::make_unique<Adaptee>();
auto adapter = std::make_unique<Adapter>(std::move(adaptee));
adapter->request();
```

#### 装饰器模式（Decorator）

**用途**：动态地给对象添加新功能，而不改变其结构。

```cpp
// 组件接口
class Coffee {
public:
    virtual ~Coffee() = default;
    virtual std::string getDescription() const = 0;
    virtual double getCost() const = 0;
};

// 具体组件
class SimpleCoffee : public Coffee {
public:
    std::string getDescription() const override {
        return "简单咖啡";
    }
    
    double getCost() const override {
        return 2.0;
    }
};

// 装饰器基类
class CoffeeDecorator : public Coffee {
protected:
    std::unique_ptr<Coffee> coffee_;

public:
    CoffeeDecorator(std::unique_ptr<Coffee> coffee) 
        : coffee_(std::move(coffee)) {}
};

// 具体装饰器
class MilkDecorator : public CoffeeDecorator {
public:
    MilkDecorator(std::unique_ptr<Coffee> coffee) 
        : CoffeeDecorator(std::move(coffee)) {}
    
    std::string getDescription() const override {
        return coffee_->getDescription() + " + 牛奶";
    }
    
    double getCost() const override {
        return coffee_->getCost() + 0.5;
    }
};

class SugarDecorator : public CoffeeDecorator {
public:
    SugarDecorator(std::unique_ptr<Coffee> coffee) 
        : CoffeeDecorator(std::move(coffee)) {}
    
    std::string getDescription() const override {
        return coffee_->getDescription() + " + 糖";
    }
    
    double getCost() const override {
        return coffee_->getCost() + 0.2;
    }
};

// 使用示例
auto coffee = std::make_unique<SimpleCoffee>();
coffee = std::make_unique<MilkDecorator>(std::move(coffee));
coffee = std::make_unique<SugarDecorator>(std::move(coffee));

std::cout << coffee->getDescription() << " - $" << coffee->getCost() << std::endl;
```

### 4. 行为型模式

#### 观察者模式（Observer）

**用途**：定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都得到通知。

```cpp
#include <vector>
#include <algorithm>

// 观察者接口
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(const std::string& message) = 0;
};

// 主题接口
class Subject {
private:
    std::vector<Observer*> observers_;

public:
    virtual ~Subject() = default;
    
    void attach(Observer* observer) {
        observers_.push_back(observer);
    }
    
    void detach(Observer* observer) {
        observers_.erase(
            std::remove(observers_.begin(), observers_.end(), observer),
            observers_.end()
        );
    }
    
    void notify(const std::string& message) {
        for (auto* observer : observers_) {
            observer->update(message);
        }
    }
};

// 具体主题
class NewsAgency : public Subject {
private:
    std::string news_;

public:
    void setNews(const std::string& news) {
        news_ = news;
        notify(news_);
    }
    
    std::string getNews() const { return news_; }
};

// 具体观察者
class NewsChannel : public Observer {
private:
    std::string name_;

public:
    NewsChannel(const std::string& name) : name_(name) {}
    
    void update(const std::string& message) override {
        std::cout << name_ << " 收到新闻: " << message << std::endl;
    }
};

// 使用示例
NewsAgency agency;
NewsChannel cnn("CNN");
NewsChannel bbc("BBC");

agency.attach(&cnn);
agency.attach(&bbc);
agency.setNews("重大新闻发布！");
```

#### 策略模式（Strategy）

**用途**：定义算法族，分别封装起来，让它们之间可以互相替换。

```cpp
// 策略接口
class SortStrategy {
public:
    virtual ~SortStrategy() = default;
    virtual void sort(std::vector<int>& data) = 0;
};

// 具体策略
class BubbleSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::cout << "使用冒泡排序\n";
        // 冒泡排序实现
        for (size_t i = 0; i < data.size(); ++i) {
            for (size_t j = 0; j < data.size() - i - 1; ++j) {
                if (data[j] > data[j + 1]) {
                    std::swap(data[j], data[j + 1]);
                }
            }
        }
    }
};

class QuickSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::cout << "使用快速排序\n";
        std::sort(data.begin(), data.end());
    }
};

// 上下文
class SortContext {
private:
    std::unique_ptr<SortStrategy> strategy_;

public:
    void setStrategy(std::unique_ptr<SortStrategy> strategy) {
        strategy_ = std::move(strategy);
    }
    
    void executeSort(std::vector<int>& data) {
        if (strategy_) {
            strategy_->sort(data);
        }
    }
};

// 使用示例
std::vector<int> data = {64, 34, 25, 12, 22, 11, 90};
SortContext context;

context.setStrategy(std::make_unique<BubbleSort>());
context.executeSort(data);
```

#### 命令模式（Command）

**用途**：将请求封装成对象，以便使用不同的请求、队列或日志请求参数化其他对象。

```cpp
// 命令接口
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual void undo() = 0;
};

// 接收者
class Light {
private:
    bool isOn_ = false;

public:
    void turnOn() {
        isOn_ = true;
        std::cout << "灯已打开\n";
    }
    
    void turnOff() {
        isOn_ = false;
        std::cout << "灯已关闭\n";
    }
    
    bool isOn() const { return isOn_; }
};

// 具体命令
class LightOnCommand : public Command {
private:
    Light* light_;

public:
    LightOnCommand(Light* light) : light_(light) {}
    
    void execute() override {
        light_->turnOn();
    }
    
    void undo() override {
        light_->turnOff();
    }
};

class LightOffCommand : public Command {
private:
    Light* light_;

public:
    LightOffCommand(Light* light) : light_(light) {}
    
    void execute() override {
        light_->turnOff();
    }
    
    void undo() override {
        light_->turnOn();
    }
};

// 调用者
class RemoteControl {
private:
    std::unique_ptr<Command> command_;
    std::unique_ptr<Command> lastCommand_;

public:
    void setCommand(std::unique_ptr<Command> command) {
        command_ = std::move(command);
    }
    
    void pressButton() {
        if (command_) {
            command_->execute();
            lastCommand_ = std::move(command_);
        }
    }
    
    void pressUndo() {
        if (lastCommand_) {
            lastCommand_->undo();
        }
    }
};
```

### 5. SOLID原则

#### 单一职责原则（SRP）

**原则**：一个类应该只有一个引起它变化的原因。

```cpp
// 违反SRP的例子
class BadEmployee {
public:
    void calculatePay() { /* 计算薪资 */ }
    void save() { /* 保存到数据库 */ }
    void generateReport() { /* 生成报告 */ }
};

// 遵循SRP的设计
class Employee {
private:
    std::string name_;
    double salary_;
public:
    // 只负责员工数据
    std::string getName() const { return name_; }
    double getSalary() const { return salary_; }
};

class PayrollCalculator {
public:
    double calculatePay(const Employee& employee) {
        // 计算薪资逻辑
        return employee.getSalary();
    }
};

class EmployeeRepository {
public:
    void save(const Employee& employee) {
        // 保存到数据库
    }
};

class ReportGenerator {
public:
    void generateReport(const Employee& employee) {
        // 生成报告
    }
};
```

#### 开闭原则（OCP）

**原则**：软件实体应该对扩展开放，对修改关闭。

```cpp
// 遵循OCP的设计
class Shape {
public:
    virtual ~Shape() = default;
    virtual double area() const = 0;
};

class Rectangle : public Shape {
private:
    double width_, height_;
public:
    Rectangle(double w, double h) : width_(w), height_(h) {}
    double area() const override { return width_ * height_; }
};

class Circle : public Shape {
private:
    double radius_;
public:
    Circle(double r) : radius_(r) {}
    double area() const override { return 3.14159 * radius_ * radius_; }
};

class AreaCalculator {
public:
    double totalArea(const std::vector<std::unique_ptr<Shape>>& shapes) {
        double total = 0;
        for (const auto& shape : shapes) {
            total += shape->area();
        }
        return total;
    }
};
```

#### 里氏替换原则（LSP）

**原则**：子类对象应该能够替换其基类对象而不改变程序的正确性。

```cpp
class Bird {
public:
    virtual ~Bird() = default;
    virtual void eat() { std::cout << "鸟在吃东西\n"; }
};

class FlyingBird : public Bird {
public:
    virtual void fly() { std::cout << "鸟在飞翔\n"; }
};

class Sparrow : public FlyingBird {
public:
    void fly() override { std::cout << "麻雀在飞翔\n"; }
};

class Penguin : public Bird {
public:
    void eat() override { std::cout << "企鹅在吃鱼\n"; }
    // 企鹅不能飞，所以不继承FlyingBird
};
```

#### 接口隔离原则（ISP）

**原则**：客户端不应该依赖它不需要的接口。

```cpp
// 违反ISP的设计
class BadWorker {
public:
    virtual void work() = 0;
    virtual void eat() = 0;
    virtual void sleep() = 0;
};

// 遵循ISP的设计
class Workable {
public:
    virtual ~Workable() = default;
    virtual void work() = 0;
};

class Eatable {
public:
    virtual ~Eatable() = default;
    virtual void eat() = 0;
};

class Sleepable {
public:
    virtual ~Sleepable() = default;
    virtual void sleep() = 0;
};

class Human : public Workable, public Eatable, public Sleepable {
public:
    void work() override { std::cout << "人在工作\n"; }
    void eat() override { std::cout << "人在吃饭\n"; }
    void sleep() override { std::cout << "人在睡觉\n"; }
};

class Robot : public Workable {
public:
    void work() override { std::cout << "机器人在工作\n"; }
    // 机器人不需要吃饭和睡觉
};
```

#### 依赖倒置原则（DIP）

**原则**：高层模块不应该依赖低层模块，两者都应该依赖抽象。

```cpp
// 抽象接口
class MessageSender {
public:
    virtual ~MessageSender() = default;
    virtual void send(const std::string& message) = 0;
};

// 低层模块
class EmailSender : public MessageSender {
public:
    void send(const std::string& message) override {
        std::cout << "发送邮件: " << message << std::endl;
    }
};

class SMSSender : public MessageSender {
public:
    void send(const std::string& message) override {
        std::cout << "发送短信: " << message << std::endl;
    }
};

// 高层模块
class NotificationService {
private:
    std::unique_ptr<MessageSender> sender_;

public:
    NotificationService(std::unique_ptr<MessageSender> sender)
        : sender_(std::move(sender)) {}
    
    void notify(const std::string& message) {
        sender_->send(message);
    }
};

// 使用示例
auto emailService = std::make_unique<NotificationService>(
    std::make_unique<EmailSender>()
);
emailService->notify("Hello World!");
```

### 6. 软件架构模式

#### 分层架构

**概念**：将系统分为多个层次，每层只能调用下层的服务。

```cpp
// 数据访问层
class UserRepository {
public:
    virtual ~UserRepository() = default;
    virtual User findById(int id) = 0;
    virtual void save(const User& user) = 0;
};

class DatabaseUserRepository : public UserRepository {
public:
    User findById(int id) override {
        // 数据库查询逻辑
        return User{};
    }
    
    void save(const User& user) override {
        // 数据库保存逻辑
    }
};

// 业务逻辑层
class UserService {
private:
    std::unique_ptr<UserRepository> repository_;

public:
    UserService(std::unique_ptr<UserRepository> repo)
        : repository_(std::move(repo)) {}
    
    User getUser(int id) {
        return repository_->findById(id);
    }
    
    void updateUser(const User& user) {
        // 业务逻辑验证
        repository_->save(user);
    }
};

// 表现层
class UserController {
private:
    std::unique_ptr<UserService> service_;

public:
    UserController(std::unique_ptr<UserService> service)
        : service_(std::move(service)) {}
    
    void handleGetUser(int id) {
        auto user = service_->getUser(id);
        // 返回HTTP响应
    }
};
```

#### MVC模式

**概念**：将应用程序分为模型、视图和控制器三个组件。

```cpp
// 模型
class UserModel {
private:
    std::string name_;
    std::string email_;

public:
    void setName(const std::string& name) { name_ = name; }
    void setEmail(const std::string& email) { email_ = email; }
    std::string getName() const { return name_; }
    std::string getEmail() const { return email_; }
};

// 视图
class UserView {
public:
    void displayUser(const UserModel& user) {
        std::cout << "用户名: " << user.getName() << std::endl;
        std::cout << "邮箱: " << user.getEmail() << std::endl;
    }
    
    void displayError(const std::string& error) {
        std::cout << "错误: " << error << std::endl;
    }
};

// 控制器
class UserController {
private:
    UserModel model_;
    UserView view_;

public:
    void setUserName(const std::string& name) {
        model_.setName(name);
    }
    
    void setUserEmail(const std::string& email) {
        model_.setEmail(email);
    }
    
    void updateView() {
        view_.displayUser(model_);
    }
};
```

### 7. 依赖注入

#### 构造函数注入

```cpp
class Logger {
public:
    virtual ~Logger() = default;
    virtual void log(const std::string& message) = 0;
};

class FileLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "写入文件: " << message << std::endl;
    }
};

class UserService {
private:
    std::unique_ptr<Logger> logger_;

public:
    // 构造函数注入
    UserService(std::unique_ptr<Logger> logger)
        : logger_(std::move(logger)) {}
    
    void createUser(const std::string& name) {
        // 创建用户逻辑
        logger_->log("用户 " + name + " 已创建");
    }
};

// 使用示例
auto logger = std::make_unique<FileLogger>();
auto userService = std::make_unique<UserService>(std::move(logger));
userService->createUser("张三");
```

#### 简单的IoC容器

```cpp
#include <unordered_map>
#include <functional>
#include <typeindex>

class DIContainer {
private:
    std::unordered_map<std::type_index, std::function<std::unique_ptr<void>()>> factories_;

public:
    template<typename Interface, typename Implementation>
    void registerType() {
        factories_[std::type_index(typeid(Interface))] = []() {
            return std::unique_ptr<void>(static_cast<void*>(new Implementation()));
        };
    }
    
    template<typename T>
    std::unique_ptr<T> resolve() {
        auto it = factories_.find(std::type_index(typeid(T)));
        if (it != factories_.end()) {
            return std::unique_ptr<T>(static_cast<T*>(it->second().release()));
        }
        return nullptr;
    }
};

// 使用示例
DIContainer container;
container.registerType<Logger, FileLogger>();
auto logger = container.resolve<Logger>();
```

## 性能优化策略

### 1. 编译时优化

#### 模板元编程

```cpp
// 编译时计算
template<int N>
struct Factorial {
    static constexpr int value = N * Factorial<N-1>::value;
};

template<>
struct Factorial<0> {
    static constexpr int value = 1;
};

// 使用
constexpr int result = Factorial<5>::value;  // 编译时计算
```

#### constexpr函数

```cpp
constexpr int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}

// 编译时计算
constexpr int fib10 = fibonacci(10);
```

### 2. 内存优化

#### 对象池模式

```cpp
template<typename T>
class ObjectPool {
private:
    std::vector<std::unique_ptr<T>> pool_;
    std::queue<T*> available_;
    std::mutex mutex_;

public:
    ObjectPool(size_t size) {
        pool_.reserve(size);
        for (size_t i = 0; i < size; ++i) {
            auto obj = std::make_unique<T>();
            available_.push(obj.get());
            pool_.push_back(std::move(obj));
        }
    }
    
    T* acquire() {
        std::lock_guard<std::mutex> lock(mutex_);
        if (available_.empty()) {
            return nullptr;
        }
        T* obj = available_.front();
        available_.pop();
        return obj;
    }
    
    void release(T* obj) {
        std::lock_guard<std::mutex> lock(mutex_);
        available_.push(obj);
    }
};
```

#### RAII资源管理

```cpp
class FileHandle {
private:
    FILE* file_;

public:
    explicit FileHandle(const char* filename, const char* mode)
        : file_(fopen(filename, mode)) {
        if (!file_) {
            throw std::runtime_error("无法打开文件");
        }
    }
    
    ~FileHandle() {
        if (file_) {
            fclose(file_);
        }
    }
    
    // 禁止拷贝
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;
    
    // 允许移动
    FileHandle(FileHandle&& other) noexcept : file_(other.file_) {
        other.file_ = nullptr;
    }
    
    FileHandle& operator=(FileHandle&& other) noexcept {
        if (this != &other) {
            if (file_) fclose(file_);
            file_ = other.file_;
            other.file_ = nullptr;
        }
        return *this;
    }
    
    FILE* get() const { return file_; }
};
```

## 代码重构技巧

### 1. 提取方法

```cpp
// 重构前：长方法
class OrderProcessor {
public:
    void processOrder(const Order& order) {
        // 验证订单
        if (order.getItems().empty()) {
            throw std::invalid_argument("订单为空");
        }
        
        // 计算总价
        double total = 0;
        for (const auto& item : order.getItems()) {
            total += item.getPrice() * item.getQuantity();
        }
        
        // 应用折扣
        if (order.getCustomer().isVIP()) {
            total *= 0.9;  // VIP 9折
        }
        
        // 处理支付
        paymentService_.processPayment(order.getCustomer(), total);
        
        // 发送确认邮件
        emailService_.sendConfirmation(order.getCustomer().getEmail(), order);
    }
};

// 重构后：提取方法
class OrderProcessor {
public:
    void processOrder(const Order& order) {
        validateOrder(order);
        double total = calculateTotal(order);
        total = applyDiscount(order, total);
        processPayment(order.getCustomer(), total);
        sendConfirmation(order);
    }

private:
    void validateOrder(const Order& order) {
        if (order.getItems().empty()) {
            throw std::invalid_argument("订单为空");
        }
    }
    
    double calculateTotal(const Order& order) {
        double total = 0;
        for (const auto& item : order.getItems()) {
            total += item.getPrice() * item.getQuantity();
        }
        return total;
    }
    
    double applyDiscount(const Order& order, double total) {
        if (order.getCustomer().isVIP()) {
            return total * 0.9;
        }
        return total;
    }
    
    void processPayment(const Customer& customer, double amount) {
        paymentService_.processPayment(customer, amount);
    }
    
    void sendConfirmation(const Order& order) {
        emailService_.sendConfirmation(order.getCustomer().getEmail(), order);
    }
};
```

### 2. 提取类

```cpp
// 重构前：职责过多的类
class Customer {
private:
    std::string name_;
    std::string email_;
    std::string address_;
    std::vector<Order> orderHistory_;

public:
    // 客户信息相关方法
    void setName(const std::string& name) { name_ = name; }
    std::string getName() const { return name_; }
    
    // 订单历史相关方法
    void addOrder(const Order& order) { orderHistory_.push_back(order); }
    std::vector<Order> getOrderHistory() const { return orderHistory_; }
    double getTotalSpent() const {
        double total = 0;
        for (const auto& order : orderHistory_) {
            total += order.getTotal();
        }
        return total;
    }
};

// 重构后：提取订单历史类
class OrderHistory {
private:
    std::vector<Order> orders_;

public:
    void addOrder(const Order& order) {
        orders_.push_back(order);
    }
    
    std::vector<Order> getOrders() const {
        return orders_;
    }
    
    double getTotalSpent() const {
        double total = 0;
        for (const auto& order : orders_) {
            total += order.getTotal();
        }
        return total;
    }
};

class Customer {
private:
    std::string name_;
    std::string email_;
    std::string address_;
    OrderHistory orderHistory_;

public:
    void setName(const std::string& name) { name_ = name; }
    std::string getName() const { return name_; }
    
    OrderHistory& getOrderHistory() { return orderHistory_; }
    const OrderHistory& getOrderHistory() const { return orderHistory_; }
};
```

## 最佳实践

### 1. 设计原则

- **优先组合而非继承**：使用组合提高灵活性
- **针对接口编程**：依赖抽象而非具体实现
- **保持简单**：避免过度设计
- **单一职责**：每个类只做一件事

### 2. 代码质量

- **命名清晰**：使用有意义的名称
- **函数简短**：保持函数简洁明了
- **减少重复**：遵循DRY原则
- **异常安全**：正确处理异常情况

### 3. 性能考虑

- **避免过早优化**：先保证正确性
- **测量性能**：使用工具分析瓶颈
- **合理使用模板**：平衡编译时间和运行时性能
- **内存管理**：使用智能指针和RAII

## 学习建议

### 循序渐进的学习路径

1. **基础模式**：从简单的单例、工厂模式开始
2. **SOLID原则**：理解面向对象设计原则
3. **结构型模式**：学习对象组合技巧
4. **行为型模式**：掌握对象交互模式
5. **架构模式**：理解系统级设计模式

### 实践项目建议

1. **日志系统**：实现单例、策略、装饰器模式
2. **图形编辑器**：应用命令、观察者、组合模式
3. **Web框架**：实现MVC、依赖注入
4. **游戏引擎**：应用状态、工厂、对象池模式
5. **数据库ORM**：实现建造者、适配器模式

### 学习资源

1. **经典书籍**：《设计模式》、《重构》、《代码整洁之道》
2. **在线资源**：GitHub开源项目、技术博客
3. **实践练习**：LeetCode设计题、开源项目贡献
4. **代码审查**：参与团队代码审查，学习最佳实践

## 总结

设计模式和架构设计是软件开发的重要技能。通过学习和应用这些模式，你可以：

- 编写更加灵活和可维护的代码
- 提高代码的复用性和扩展性
- 更好地与团队成员沟通设计思路
- 解决复杂的软件设计问题
