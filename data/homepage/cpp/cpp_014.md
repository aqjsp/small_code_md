# C++多线程与并发编程

## 1. 概述

多线程编程是现代C++开发中的重要技能，它允许程序同时执行多个任务，充分利用多核处理器的性能优势。C++11引入了标准的线程库，为并发编程提供了强大的支持。

本文将深入探讨C++多线程编程的核心概念、同步机制、内存模型，以及常见的并发模式和最佳实践，帮助你掌握安全、高效的并发编程技术。

## 2. 多线程基础

### 2.1 什么是线程？

**线程**是程序执行的最小单位，一个进程可以包含多个线程：

```cpp
#include <thread>
#include <iostream>

void worker_function(int id) {
    std::cout << "线程 " << id << " 正在工作\n";
}

int main() {
    // 创建线程
    std::thread t1(worker_function, 1);
    std::thread t2(worker_function, 2);
    
    // 等待线程完成
    t1.join();
    t2.join();
    
    return 0;
}
```

### 2.2 线程的生命周期

1. **创建**：线程对象被构造
2. **运行**：线程开始执行任务
3. **等待**：主线程等待子线程完成
4. **销毁**：线程执行完毕，资源被回收

### 2.3 线程管理的关键概念

- **join()**：等待线程完成
- **detach()**：分离线程，让其独立运行
- **joinable()**：检查线程是否可以join

## 3. 线程同步机制

### 3.1 互斥锁（Mutex）

**互斥锁**用于保护共享资源，确保同一时间只有一个线程可以访问：

```cpp
#include <mutex>
#include <thread>

std::mutex mtx;
int shared_counter = 0;

void increment() {
    std::lock_guard<std::mutex> lock(mtx);  // RAII风格的锁
    ++shared_counter;  // 临界区
}
```

**锁的类型**：
- `std::mutex`：基本互斥锁
- `std::recursive_mutex`：可递归锁
- `std::timed_mutex`：支持超时的锁
- `std::shared_mutex`：读写锁

### 3.2 条件变量（Condition Variable）

**条件变量**用于线程间的通信，让线程等待特定条件：

```cpp
#include <condition_variable>

std::condition_variable cv;
std::mutex cv_mtx;
bool ready = false;

void worker() {
    std::unique_lock<std::mutex> lock(cv_mtx);
    cv.wait(lock, []{ return ready; });  // 等待条件满足
    // 执行工作...
}

void signal_ready() {
    {
        std::lock_guard<std::mutex> lock(cv_mtx);
        ready = true;
    }
    cv.notify_one();  // 通知等待的线程
}
```

### 3.3 原子操作（Atomic Operations）

**原子操作**提供无锁的线程安全操作：

```cpp
#include <atomic>

std::atomic<int> atomic_counter{0};

void atomic_increment() {
    atomic_counter++;  // 原子操作，无需锁
}

void compare_and_swap() {
    int expected = 5;
    int desired = 10;
    // 如果值等于expected，则设置为desired
    bool success = atomic_counter.compare_exchange_weak(expected, desired);
}
```

## 4. 内存模型与线程安全

### 4.1 内存序（Memory Ordering）

C++提供了不同的内存序来控制操作的可见性：

```cpp
// 不同的内存序
std::atomic<int> x{0};

// 顺序一致性（默认，最强保证）
x.store(1, std::memory_order_seq_cst);

// 获取-释放语义（常用的平衡选择）
x.store(1, std::memory_order_release);
int value = x.load(std::memory_order_acquire);

// 松散序（最弱保证，仅保证原子性）
x.store(1, std::memory_order_relaxed);
```

### 4.2 数据竞争与线程安全

**数据竞争**发生在多个线程同时访问同一内存位置，且至少有一个是写操作：

```cpp
// 危险：数据竞争
int global_var = 0;
void unsafe_increment() {
    global_var++;  // 非原子操作，可能导致数据竞争
}

// 安全：使用锁保护
std::mutex mtx;
void safe_increment() {
    std::lock_guard<std::mutex> lock(mtx);
    global_var++;
}

// 安全：使用原子变量
std::atomic<int> atomic_var{0};
void atomic_increment() {
    atomic_var++;
}
```

## 5. 异步编程模式

### 5.1 Future和Promise

**Future/Promise**提供了异步计算的抽象：

```cpp
#include <future>

// 使用async启动异步任务
std::future<int> async_task = std::async(std::launch::async, []() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    return 42;
});

// 获取结果（会阻塞直到任务完成）
int result = async_task.get();

// 使用promise手动设置结果
std::promise<int> promise;
std::future<int> future = promise.get_future();

std::thread([&promise]() {
    // 执行一些工作...
    promise.set_value(100);  // 设置结果
}).detach();

int value = future.get();  // 获取结果
```

### 5.2 任务并行化

```cpp
#include <algorithm>
#include <execution>
#include <vector>

std::vector<int> data(1000000);

// 并行算法（C++17）
std::for_each(std::execution::par, data.begin(), data.end(), 
              [](int& x) { x = x * x; });

// 并行排序
std::sort(std::execution::par, data.begin(), data.end());
```

## 6. 高级并发模式

### 6.1 生产者-消费者模式

```cpp
#include <queue>

template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable condition_;

public:
    void push(T item) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(item);
        condition_.notify_one();
    }
    
    T pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        condition_.wait(lock, [this] { return !queue_.empty(); });
        T item = queue_.front();
        queue_.pop();
        return item;
    }
};
```

### 6.3 线程池模式

```cpp
class ThreadPool {
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop = false;

public:
    ThreadPool(size_t threads) {
        for(size_t i = 0; i < threads; ++i) {
            workers.emplace_back([this] {
                while(true) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(queue_mutex);
                        condition.wait(lock, [this]{ return stop || !tasks.empty(); });
                        if(stop && tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
        }
    }
    
    template<class F>
    void enqueue(F&& f) {
        {
            std::lock_guard<std::mutex> lock(queue_mutex);
            tasks.emplace(std::forward<F>(f));
        }
        condition.notify_one();
    }
};
```

## 7. 性能优化与调试

### 7.1 性能分析

多线程程序的性能分析需要特别关注以下几个方面：

```cpp
#include <chrono>
#include <thread>

// 性能测量示例
class PerformanceTimer {
public:
    void start() {
        start_time = std::chrono::high_resolution_clock::now();
    }
    
    void stop() {
        end_time = std::chrono::high_resolution_clock::now();
    }
    
    double elapsed_ms() const {
        auto duration = end_time - start_time;
        return std::chrono::duration<double, std::milli>(duration).count();
    }
    
private:
    std::chrono::high_resolution_clock::time_point start_time, end_time;
};
```

**关键性能指标**：
- **吞吐量**：单位时间内完成的任务数
- **延迟**：单个任务的完成时间
- **CPU利用率**：处理器核心的使用效率
- **内存使用**：程序的内存占用情况

### 7.2 调试技巧

#### 使用调试工具

```cpp
// 线程安全的日志记录
class ThreadSafeLogger {
private:
    std::mutex log_mutex;
    std::ofstream log_file;
    
public:
    ThreadSafeLogger(const std::string& filename) : log_file(filename) {}
    
    template<typename... Args>
    void log(Args&&... args) {
        std::lock_guard<std::mutex> lock(log_mutex);
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        
        log_file << "[" << std::this_thread::get_id() << "] "
                 << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S")
                 << ": ";
        (log_file << ... << args) << std::endl;
    }
};
```

#### 死锁检测

```cpp
// 简单的死锁检测机制
class DeadlockDetector {
private:
    static std::map<std::thread::id, std::vector<void*>> thread_locks;
    static std::mutex detector_mutex;
    
public:
    static void acquire_lock(void* lock_ptr) {
        std::lock_guard<std::mutex> lock(detector_mutex);
        thread_locks[std::this_thread::get_id()].push_back(lock_ptr);
        // 检测潜在的死锁...
    }
    
    static void release_lock(void* lock_ptr) {
        std::lock_guard<std::mutex> lock(detector_mutex);
        auto& locks = thread_locks[std::this_thread::get_id()];
        locks.erase(std::remove(locks.begin(), locks.end(), lock_ptr), locks.end());
    }
};
```

## 8. 设计原则

### 8.1 最小化共享状态

- 尽量减少线程间共享的数据
- 使用消息传递而非共享内存
- 优先使用不可变数据

### 8.2 使用RAII管理资源

```cpp
// 好的做法：使用RAII
{
    std::lock_guard<std::mutex> lock(mtx);
    // 临界区代码
}  // 锁自动释放

// 避免手动管理
mtx.lock();
// 如果这里抛出异常，锁永远不会被释放！
mtx.unlock();
```

### 8.3 避免死锁

```cpp
// 死锁风险：不同顺序获取锁
void thread1() {
    std::lock_guard<std::mutex> lock1(mutex1);
    std::lock_guard<std::mutex> lock2(mutex2);
}

void thread2() {
    std::lock_guard<std::mutex> lock2(mutex2);  // 顺序不同！
    std::lock_guard<std::mutex> lock1(mutex1);
}

// 解决方案：使用std::lock同时获取多个锁
void safe_function() {
    std::lock(mutex1, mutex2);
    std::lock_guard<std::mutex> lock1(mutex1, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(mutex2, std::adopt_lock);
}
```

## 9. 实际应用案例

### 9.1 Web服务器并发处理

```cpp
#include <thread>
#include <vector>
#include <functional>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <future>

class SimpleWebServer {
private:
    ThreadPool thread_pool;
    std::atomic<bool> running{true};
    
public:
    SimpleWebServer(size_t num_threads) : thread_pool(num_threads) {}
    
    void handle_request(const std::string& request) {
        thread_pool.enqueue([this, request]() {
            // 处理HTTP请求
            process_http_request(request);
        });
    }
    
private:
    void process_http_request(const std::string& request) {
        // 解析请求、生成响应
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        // 发送响应...
    }
};
```

### 9.2 并行数据处理

```cpp
#include <algorithm>
#include <execution>
#include <numeric>

class DataProcessor {
public:
    // 并行处理大量数据
    std::vector<double> parallel_transform(const std::vector<double>& input) {
        std::vector<double> result(input.size());
        
        std::transform(std::execution::par_unseq, 
                      input.begin(), input.end(), result.begin(),
                      [](double x) { return std::sin(x) * std::cos(x); });
        
        return result;
    }
    
    // 并行归约操作
    double parallel_sum(const std::vector<double>& data) {
        return std::reduce(std::execution::par, 
                          data.begin(), data.end(), 0.0);
    }
};
```

## 10. 常见陷阱

### 10.1 忘记join或detach线程

```cpp
// 错误：线程对象销毁时会调用std::terminate
void bad_example() {
    std::thread t([]{ /* work */ });
    // 忘记join()或detach()
}  // 程序崩溃！

// 正确做法
void good_example() {
    std::thread t([]{ /* work */ });
    t.join();  // 或者 t.detach();
}
```

### 10.2 数据竞争

```cpp
// 危险：多个线程修改同一变量
int counter = 0;
void increment() {
    counter++;  // 非原子操作！
}

// 安全：使用原子变量或锁
std::atomic<int> safe_counter{0};
void safe_increment() {
    safe_counter++;
}
```

### 10.4 虚假唤醒

```cpp
// 错误：没有检查条件
cv.wait(lock);  // 可能被虚假唤醒

// 正确：总是检查条件
cv.wait(lock, []{ return condition_is_true; });
```

## 3. 性能考虑

### 1. 锁的开销

- 锁操作有性能开销
- 考虑使用原子操作替代简单的锁
- 减少锁的持有时间

### 2. 缓存一致性

- 避免false sharing（伪共享）
- 考虑数据的局部性
- 使用线程本地存储

### 3. 线程数量

```cpp
// 获取硬件并发数
unsigned int num_threads = std::thread::hardware_concurrency();
if (num_threads == 0) {
    num_threads = 2;  // 默认值
}
```

## 4. 最佳实践

### 1. 优先使用高级抽象

- 使用`std::async`而非手动创建线程
- 使用并行算法（C++17）
- 考虑使用线程池

### 2. 异常安全

```cpp
void exception_safe_function() {
    std::lock_guard<std::mutex> lock(mtx);
    // 即使抛出异常，锁也会被正确释放
    risky_operation();
}
```

### 3. 测试并发代码

- 使用工具检测数据竞争（如ThreadSanitizer）
- 进行压力测试
- 考虑使用形式化验证工具

## 11. 学习建议

### 循序渐进的学习路径

1. **基础概念**：理解线程、进程、并发的基本概念
2. **同步机制**：掌握mutex、condition_variable的使用
3. **原子操作**：学习无锁编程的基础
4. **异步编程**：掌握future/promise模式
5. **高级主题**：学习内存模型、并行算法

### 实践项目建议

1. **计数器程序**：实现线程安全的计数器
2. **生产者消费者**：实现经典的生产者-消费者模式
3. **并行计算**：实现矩阵乘法的并行版本
4. **Web服务器**：实现简单的多线程Web服务器
5. **任务调度器**：实现一个线程池和任务调度系统

### 调试技巧

1. **使用调试工具**：gdb、Visual Studio调试器
2. **静态分析**：使用静态分析工具检测潜在问题
3. **运行时检测**：使用ThreadSanitizer检测数据竞争
4. **日志记录**：在关键点添加线程安全的日志
5. **单元测试**：为并发代码编写专门的测试

## 12. 总结

C++多线程编程是现代软件开发中的重要技能，它能够充分利用多核处理器的性能优势。通过本章的学习，我们掌握了：

- **基础概念**：线程的创建、管理和生命周期
- **同步机制**：互斥锁、条件变量、原子操作等核心工具
- **内存模型**：理解内存序和数据竞争的概念
- **异步编程**：Future/Promise模式和任务并行化
- **高级模式**：生产者-消费者、线程池等实用模式
- **性能优化**：分析和调试多线程程序的技巧
- **最佳实践**：避免常见陷阱，编写安全高效的并发代码

多线程编程需要大量的实践和经验积累。建议从简单的例子开始，逐步掌握各种同步机制，最终能够设计和实现复杂的并发系统。

## 13. 进一步学习

### 高级主题
- **C++20并发特性**：协程(Coroutines)、原子智能指针等
- **无锁编程**：Lock-free数据结构和算法
- **并行算法库**：std::execution策略的深入应用
- **分布式系统**：跨进程和跨机器的并发处理
- **实时系统**：硬实时和软实时系统的并发设计

### 推荐资源
- **书籍**：《C++ Concurrency in Action》、《The Art of Multiprocessor Programming》
- **标准文档**：C++标准中关于线程和内存模型的规范
- **开源项目**：研究高质量的多线程C++项目源码
- **性能分析工具**：Intel VTune、Perf、ThreadSanitizer等