# C++多线程与并发编程

### 1. 多线程基础

#### 什么是线程？

**线程**是程序执行的最小单位，一个进程可以包含多个线程：

```cpp
#include <thread>
#include <iostream>

void worker_function(int id) {
    std::cout << "线程 " << id << " 正在工作\n";
}

int main() {
    // 创建线程
    std::thread t1(worker_function, 1);
    std::thread t2(worker_function, 2);
    
    // 等待线程完成
    t1.join();
    t2.join();
    
    return 0;
}
```

#### 线程的生命周期

1. **创建**：线程对象被构造
2. **运行**：线程开始执行任务
3. **等待**：主线程等待子线程完成
4. **销毁**：线程执行完毕，资源被回收

#### 线程管理的关键概念

- **join()**：等待线程完成
- **detach()**：分离线程，让其独立运行
- **joinable()**：检查线程是否可以join

### 2. 线程同步机制

#### 互斥锁（Mutex）

**互斥锁**用于保护共享资源，确保同一时间只有一个线程可以访问：

```cpp
#include <mutex>
#include <thread>

std::mutex mtx;
int shared_counter = 0;

void increment() {
    std::lock_guard<std::mutex> lock(mtx);  // RAII风格的锁
    ++shared_counter;  // 临界区
}
```

**锁的类型**：
- `std::mutex`：基本互斥锁
- `std::recursive_mutex`：可递归锁
- `std::timed_mutex`：支持超时的锁
- `std::shared_mutex`：读写锁

#### 条件变量（Condition Variable）

**条件变量**用于线程间的通信，让线程等待特定条件：

```cpp
#include <condition_variable>

std::condition_variable cv;
std::mutex cv_mtx;
bool ready = false;

void worker() {
    std::unique_lock<std::mutex> lock(cv_mtx);
    cv.wait(lock, []{ return ready; });  // 等待条件满足
    // 执行工作...
}

void signal_ready() {
    {
        std::lock_guard<std::mutex> lock(cv_mtx);
        ready = true;
    }
    cv.notify_one();  // 通知等待的线程
}
```

#### 原子操作（Atomic Operations）

**原子操作**提供无锁的线程安全操作：

```cpp
#include <atomic>

std::atomic<int> atomic_counter{0};

void atomic_increment() {
    atomic_counter++;  // 原子操作，无需锁
}

void compare_and_swap() {
    int expected = 5;
    int desired = 10;
    // 如果值等于expected，则设置为desired
    bool success = atomic_counter.compare_exchange_weak(expected, desired);
}
```

### 3. 内存模型与线程安全

#### 内存序（Memory Ordering）

C++提供了不同的内存序来控制操作的可见性：

```cpp
// 不同的内存序
std::atomic<int> x{0};

// 顺序一致性（默认，最强保证）
x.store(1, std::memory_order_seq_cst);

// 获取-释放语义（常用的平衡选择）
x.store(1, std::memory_order_release);
int value = x.load(std::memory_order_acquire);

// 松散序（最弱保证，仅保证原子性）
x.store(1, std::memory_order_relaxed);
```

#### 数据竞争与线程安全

**数据竞争**发生在多个线程同时访问同一内存位置，且至少有一个是写操作：

```cpp
// 危险：数据竞争
int global_var = 0;
void unsafe_increment() {
    global_var++;  // 非原子操作，可能导致数据竞争
}

// 安全：使用锁保护
std::mutex mtx;
void safe_increment() {
    std::lock_guard<std::mutex> lock(mtx);
    global_var++;
}

// 安全：使用原子变量
std::atomic<int> atomic_var{0};
void atomic_increment() {
    atomic_var++;
}
```

### 4. 异步编程模式

#### Future和Promise

**Future/Promise**提供了异步计算的抽象：

```cpp
#include <future>

// 使用async启动异步任务
std::future<int> async_task = std::async(std::launch::async, []() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    return 42;
});

// 获取结果（会阻塞直到任务完成）
int result = async_task.get();

// 使用promise手动设置结果
std::promise<int> promise;
std::future<int> future = promise.get_future();

std::thread([&promise]() {
    // 执行一些工作...
    promise.set_value(100);  // 设置结果
}).detach();

int value = future.get();  // 获取结果
```

#### 任务并行化

```cpp
#include <algorithm>
#include <execution>
#include <vector>

std::vector<int> data(1000000);

// 并行算法（C++17）
std::for_each(std::execution::par, data.begin(), data.end(), 
              [](int& x) { x = x * x; });

// 并行排序
std::sort(std::execution::par, data.begin(), data.end());
```

### 5. 常见并发模式

#### 生产者-消费者模式

```cpp
#include <queue>

template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable condition_;

public:
    void push(T item) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(item);
        condition_.notify_one();
    }
    
    T pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        condition_.wait(lock, [this] { return !queue_.empty(); });
        T item = queue_.front();
        queue_.pop();
        return item;
    }
};
```

#### 线程池模式

```cpp
class ThreadPool {
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop = false;

public:
    ThreadPool(size_t threads) {
        for(size_t i = 0; i < threads; ++i) {
            workers.emplace_back([this] {
                while(true) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(queue_mutex);
                        condition.wait(lock, [this]{ return stop || !tasks.empty(); });
                        if(stop && tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
        }
    }
    
    template<class F>
    void enqueue(F&& f) {
        {
            std::lock_guard<std::mutex> lock(queue_mutex);
            tasks.emplace(std::forward<F>(f));
        }
        condition.notify_one();
    }
};
```

## 设计原则

### 1. 最小化共享状态

- 尽量减少线程间共享的数据
- 使用消息传递而非共享内存
- 优先使用不可变数据

### 2. 使用RAII管理资源

```cpp
// 好的做法：使用RAII
{
    std::lock_guard<std::mutex> lock(mtx);
    // 临界区代码
}  // 锁自动释放

// 避免手动管理
mtx.lock();
// 如果这里抛出异常，锁永远不会被释放！
mtx.unlock();
```

### 3. 避免死锁

```cpp
// 死锁风险：不同顺序获取锁
void thread1() {
    std::lock_guard<std::mutex> lock1(mutex1);
    std::lock_guard<std::mutex> lock2(mutex2);
}

void thread2() {
    std::lock_guard<std::mutex> lock2(mutex2);  // 顺序不同！
    std::lock_guard<std::mutex> lock1(mutex1);
}

// 解决方案：使用std::lock同时获取多个锁
void safe_function() {
    std::lock(mutex1, mutex2);
    std::lock_guard<std::mutex> lock1(mutex1, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(mutex2, std::adopt_lock);
}
```

## 常见陷阱

### 1. 忘记join或detach线程

```cpp
// 错误：线程对象销毁时会调用std::terminate
void bad_example() {
    std::thread t([]{ /* work */ });
    // 忘记join()或detach()
}  // 程序崩溃！

// 正确做法
void good_example() {
    std::thread t([]{ /* work */ });
    t.join();  // 或者 t.detach();
}
```

### 2. 数据竞争

```cpp
// 危险：多个线程修改同一变量
int counter = 0;
void increment() {
    counter++;  // 非原子操作！
}

// 安全：使用原子变量或锁
std::atomic<int> safe_counter{0};
void safe_increment() {
    safe_counter++;
}
```

### 3. 虚假唤醒

```cpp
// 错误：没有检查条件
cv.wait(lock);  // 可能被虚假唤醒

// 正确：总是检查条件
cv.wait(lock, []{ return condition_is_true; });
```

## 性能考虑

### 1. 锁的开销

- 锁操作有性能开销
- 考虑使用原子操作替代简单的锁
- 减少锁的持有时间

### 2. 缓存一致性

- 避免false sharing（伪共享）
- 考虑数据的局部性
- 使用线程本地存储

### 3. 线程数量

```cpp
// 获取硬件并发数
unsigned int num_threads = std::thread::hardware_concurrency();
if (num_threads == 0) {
    num_threads = 2;  // 默认值
}
```

## 最佳实践

### 1. 优先使用高级抽象

- 使用`std::async`而非手动创建线程
- 使用并行算法（C++17）
- 考虑使用线程池

### 2. 异常安全

```cpp
void exception_safe_function() {
    std::lock_guard<std::mutex> lock(mtx);
    // 即使抛出异常，锁也会被正确释放
    risky_operation();
}
```

### 3. 测试并发代码

- 使用工具检测数据竞争（如ThreadSanitizer）
- 进行压力测试
- 考虑使用形式化验证工具

## 学习建议

### 循序渐进的学习路径

1. **基础概念**：理解线程、进程、并发的基本概念
2. **同步机制**：掌握mutex、condition_variable的使用
3. **原子操作**：学习无锁编程的基础
4. **异步编程**：掌握future/promise模式
5. **高级主题**：学习内存模型、并行算法

### 实践项目建议

1. **计数器程序**：实现线程安全的计数器
2. **生产者消费者**：实现经典的生产者-消费者模式
3. **并行计算**：实现矩阵乘法的并行版本
4. **Web服务器**：实现简单的多线程Web服务器
5. **任务调度器**：实现一个线程池和任务调度系统

### 调试技巧

1. **使用调试工具**：gdb、Visual Studio调试器
2. **静态分析**：使用静态分析工具检测潜在问题
3. **运行时检测**：使用ThreadSanitizer检测数据竞争
4. **日志记录**：在关键点添加线程安全的日志
5. **单元测试**：为并发代码编写专门的测试

## 总结

多线程编程是现代C++开发的重要技能。通过理解基本概念、掌握同步机制、遵循最佳实践，你可以编写出高效、安全的并发程序。记住：

- 从简单开始，逐步掌握复杂概念
- 重视线程安全和数据竞争问题
- 使用现代C++提供的高级抽象
- 通过实践项目加深理解
- 持续学习新的并发编程技术和模式

并发编程虽然复杂，但掌握了正确的方法和工具，就能充分发挥多核处理器的性能优势。