# C++ Lambda表达式与函数式编程详解：深度理解与实践指南

## 学习目标

通过本章学习，你将掌握：
- Lambda表达式的语法和使用方法
- 捕获机制的工作原理和最佳实践
- 函数式编程的核心概念
- 高阶函数的设计和应用
- 现代C++中的函数式编程技巧
- 性能考虑和优化策略

## 目标读者

本章适合：
- 熟悉C++基础语法的开发者
- 希望学习现代C++特性的程序员
- 对函数式编程感兴趣的开发者
- 需要编写更简洁、表达力强的代码的工程师

## 前置知识

- C++基础语法和面向对象概念
- 函数指针和函数对象的基本概念
- STL容器和算法的基本使用
- 模板的基础知识

## 核心内容

### 1. Lambda表达式基础

#### 什么是Lambda表达式？

Lambda表达式是C++11引入的一种创建匿名函数的方式，它允许你在需要函数的地方直接定义函数逻辑。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 传统方式：使用函数对象
    struct IsEven {
        bool operator()(int n) const {
            return n % 2 == 0;
        }
    };
    
    // Lambda方式：更简洁
    auto isEven = [](int n) {
        return n % 2 == 0;
    };
    
    // 使用Lambda表达式
    auto count = std::count_if(numbers.begin(), numbers.end(), 
                              [](int n) { return n % 2 == 0; });
    
    std::cout << "偶数个数: " << count << std::endl; // 输出: 2
    
    return 0;
}
```

#### Lambda表达式的语法结构

Lambda表达式的完整语法：

```cpp
[捕获列表](参数列表) mutable exception -> 返回类型 { 函数体 }
```

**各部分说明**：
- **捕获列表**：指定如何捕获外部变量
- **参数列表**：函数参数（可省略）
- **mutable**：允许修改按值捕获的变量（可选）
- **exception**：异常规范（可选）
- **返回类型**：指定返回类型（可选，通常可推导）
- **函数体**：函数的实现代码

```cpp
// 基本示例
auto basic = []() { return 42; };

// 带参数
auto add = [](int a, int b) { return a + b; };

// 指定返回类型
auto divide = [](double a, double b) -> double {
    if (b != 0) return a / b;
    return 0.0;
};

// 使用示例
std::cout << basic() << std::endl;        // 42
std::cout << add(3, 4) << std::endl;      // 7
std::cout << divide(10, 3) << std::endl;  // 3.33333
```

### 2. 捕获机制详解

#### 捕获列表的语法

Lambda表达式可以捕获外部作用域的变量，有多种捕获方式：

```cpp
#include <iostream>

void demonstrateCapture() {
    int x = 10;
    int y = 20;
    std::string name = "Lambda";
    
    // 1. 按值捕获
    auto lambda1 = [x]() {
        std::cout << "按值捕获 x: " << x << std::endl;
        // x++; // 错误：不能修改按值捕获的变量
    };
    
    // 2. 按引用捕获
    auto lambda2 = [&y]() {
        std::cout << "按引用捕获 y: " << y << std::endl;
        y++; // 可以修改
    };
    
    // 3. 混合捕获
    auto lambda3 = [x, &y]() {
        std::cout << "x: " << x << ", y: " << y << std::endl;
    };
    
    // 4. 捕获所有变量（按值）
    auto lambda4 = [=]() {
        std::cout << "全部按值: x=" << x << ", y=" << y << std::endl;
    };
    
    // 5. 捕获所有变量（按引用）
    auto lambda5 = [&]() {
        std::cout << "全部按引用: x=" << x << ", y=" << y << std::endl;
        x++; y++; // 可以修改
    };
    
    // 6. 混合默认捕获
    auto lambda6 = [=, &name]() {
        std::cout << "默认按值，name按引用: " << name << std::endl;
    };
    
    lambda1();
    lambda2();
    lambda3();
    lambda4();
    lambda5();
    lambda6();
}
```

#### 捕获的工作原理

Lambda表达式实际上是编译器生成的函数对象（仿函数）：

```cpp
// Lambda表达式
int x = 42;
auto lambda = [x](int y) { return x + y; };

// 编译器生成的等价代码（简化版）
class __lambda_unique_name {
private:
    int x; // 捕获的变量成为成员变量
    
public:
    __lambda_unique_name(int x_) : x(x_) {} // 构造函数初始化捕获的变量
    
    int operator()(int y) const { // 调用操作符
        return x + y;
    }
};

// 使用
__lambda_unique_name lambda(x);
```

#### mutable关键字

使用`mutable`关键字可以修改按值捕获的变量：

```cpp
void mutableExample() {
    int counter = 0;
    
    // 不使用mutable（错误）
    auto lambda1 = [counter]() {
        // counter++; // 编译错误：不能修改const成员
        return counter;
    };
    
    // 使用mutable
    auto lambda2 = [counter]() mutable {
        counter++; // 正确：可以修改
        return counter;
    };
    
    std::cout << "原始counter: " << counter << std::endl; // 0
    std::cout << "lambda2第一次调用: " << lambda2() << std::endl; // 1
    std::cout << "lambda2第二次调用: " << lambda2() << std::endl; // 2
    std::cout << "原始counter仍然是: " << counter << std::endl; // 0（未改变）
}
```

#### 初始化捕获（C++14）

C++14引入了初始化捕获，允许在捕获时进行初始化：

```cpp
#include <memory>
#include <iostream>

void initCaptureExample() {
    // 移动捕获
    auto ptr = std::make_unique<int>(42);
    auto lambda = [p = std::move(ptr)]() {
        return *p;
    };
    
    std::cout << "移动捕获的值: " << lambda() << std::endl;
    // ptr现在为空
    
    // 计算捕获
    int x = 10;
    auto lambda2 = [y = x * 2]() {
        return y;
    };
    
    std::cout << "计算捕获的值: " << lambda2() << std::endl; // 20
    
    // 复杂初始化
    auto lambda3 = [vec = std::vector<int>{1, 2, 3, 4, 5}]() {
        int sum = 0;
        for (int n : vec) sum += n;
        return sum;
    };
    
    std::cout << "向量求和: " << lambda3() << std::endl; // 15
}
```

### 3. Lambda表达式的类型和存储

#### auto关键字和类型推导

每个Lambda表达式都有唯一的类型：

```cpp
#include <functional>
#include <iostream>

void lambdaTypes() {
    // 每个Lambda都有唯一类型
    auto lambda1 = []() { return 42; };
    auto lambda2 = []() { return 42; }; // 与lambda1类型不同！
    
    // 使用std::function存储
    std::function<int()> func1 = lambda1;
    std::function<int()> func2 = lambda2;
    
    // 可以存储在同一个容器中
    std::vector<std::function<int()>> lambdas;
    lambdas.push_back(lambda1);
    lambdas.push_back(lambda2);
    
    for (auto& f : lambdas) {
        std::cout << f() << " ";
    }
    std::cout << std::endl;
}
```

#### 无捕获Lambda的特殊性质

无捕获的Lambda可以转换为函数指针：

```cpp
#include <iostream>

// 接受函数指针的函数
void processWithFunctionPointer(int (*func)(int)) {
    std::cout << "结果: " << func(5) << std::endl;
}

// 接受函数对象的模板函数
template<typename Func>
void processWithTemplate(Func func) {
    std::cout << "结果: " << func(5) << std::endl;
}

void lambdaConversion() {
    // 无捕获Lambda可以转换为函数指针
    auto lambda = [](int x) { return x * 2; };
    
    // 转换为函数指针
    int (*funcPtr)(int) = lambda;
    
    // 两种调用方式都可以
    processWithFunctionPointer(lambda);    // 直接传递
    processWithFunctionPointer(funcPtr);   // 通过函数指针
    
    // 模板函数可以接受任何可调用对象
    processWithTemplate(lambda);
    processWithTemplate(funcPtr);
    processWithTemplate([](int x) { return x * 3; }); // 直接传递Lambda
}
```

### 4. 函数式编程概念

#### 高阶函数

高阶函数是接受函数作为参数或返回函数的函数：

```cpp
#include <vector>
#include <algorithm>
#include <functional>
#include <iostream>

// 高阶函数示例：map
template<typename Container, typename Func>
auto map(const Container& container, Func func) {
    std::vector<decltype(func(*container.begin()))> result;
    result.reserve(container.size());
    
    for (const auto& item : container) {
        result.push_back(func(item));
    }
    
    return result;
}

// 高阶函数示例：filter
template<typename Container, typename Predicate>
auto filter(const Container& container, Predicate pred) {
    std::vector<typename Container::value_type> result;
    
    for (const auto& item : container) {
        if (pred(item)) {
            result.push_back(item);
        }
    }
    
    return result;
}

// 高阶函数示例：reduce
template<typename Container, typename Func, typename T>
T reduce(const Container& container, Func func, T initial) {
    T result = initial;
    for (const auto& item : container) {
        result = func(result, item);
    }
    return result;
}

void higherOrderFunctions() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Map：将每个元素平方
    auto squares = map(numbers, [](int x) { return x * x; });
    
    // Filter：筛选偶数
    auto evens = filter(numbers, [](int x) { return x % 2 == 0; });
    
    // Reduce：求和
    auto sum = reduce(numbers, [](int acc, int x) { return acc + x; }, 0);
    
    std::cout << "原数组: ";
    for (int n : numbers) std::cout << n << " ";
    std::cout << std::endl;
    
    std::cout << "平方: ";
    for (int n : squares) std::cout << n << " ";
    std::cout << std::endl;
    
    std::cout << "偶数: ";
    for (int n : evens) std::cout << n << " ";
    std::cout << std::endl;
    
    std::cout << "求和: " << sum << std::endl;
}
```

#### 函数组合

函数组合是函数式编程的核心概念：

```cpp
#include <functional>
#include <iostream>

// 函数组合工具
template<typename F, typename G>
auto compose(F f, G g) {
    return [f, g](auto x) {
        return f(g(x));
    };
}

// 管道操作符模拟
template<typename T, typename F>
auto operator|(T&& value, F func) {
    return func(std::forward<T>(value));
}

void functionComposition() {
    // 基本函数
    auto add1 = [](int x) { return x + 1; };
    auto multiply2 = [](int x) { return x * 2; };
    auto square = [](int x) { return x * x; };
    
    // 函数组合
    auto add1ThenMultiply2 = compose(multiply2, add1);
    auto complexOperation = compose(square, compose(multiply2, add1));
    
    int input = 5;
    std::cout << "输入: " << input << std::endl;
    std::cout << "add1: " << add1(input) << std::endl;
    std::cout << "add1 then multiply2: " << add1ThenMultiply2(input) << std::endl;
    std::cout << "复杂操作: " << complexOperation(input) << std::endl;
    
    // 使用管道操作符（模拟）
    auto result = input 
                | add1 
                | multiply2 
                | square;
    std::cout << "管道操作结果: " << result << std::endl;
}
```

#### 柯里化（Currying）

柯里化是将多参数函数转换为一系列单参数函数的技术：

```cpp
#include <functional>
#include <iostream>

// 手动柯里化
auto add = [](int a) {
    return [a](int b) {
        return a + b;
    };
};

// 通用柯里化工具
template<typename F>
auto curry(F f) {
    return [f](auto a) {
        return [f, a](auto b) {
            return f(a, b);
        };
    };
}

// 三参数函数的柯里化
auto add3 = [](int a) {
    return [a](int b) {
        return [a, b](int c) {
            return a + b + c;
        };
    };
};

void curryingExample() {
    // 使用柯里化的加法
    auto add5 = add(5);
    std::cout << "add(5)(3) = " << add5(3) << std::endl; // 8
    
    // 直接调用
    std::cout << "add(10)(20) = " << add(10)(20) << std::endl; // 30
    
    // 使用通用柯里化工具
    auto multiply = [](int a, int b) { return a * b; };
    auto curriedMultiply = curry(multiply);
    auto multiply3 = curriedMultiply(3);
    
    std::cout << "multiply(3)(4) = " << multiply3(4) << std::endl; // 12
    
    // 三参数柯里化
    std::cout << "add3(1)(2)(3) = " << add3(1)(2)(3) << std::endl; // 6
}
```

### 5. STL算法与Lambda

#### 常用STL算法的Lambda应用

```cpp
#include <vector>
#include <algorithm>
#include <numeric>
#include <iostream>

void stlWithLambda() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // std::for_each
    std::cout << "原数组: ";
    std::for_each(numbers.begin(), numbers.end(), 
                  [](int n) { std::cout << n << " "; });
    std::cout << std::endl;
    
    // std::transform
    std::vector<int> squares(numbers.size());
    std::transform(numbers.begin(), numbers.end(), squares.begin(),
                   [](int n) { return n * n; });
    
    std::cout << "平方: ";
    std::for_each(squares.begin(), squares.end(),
                  [](int n) { std::cout << n << " "; });
    std::cout << std::endl;
    
    // std::count_if
    auto evenCount = std::count_if(numbers.begin(), numbers.end(),
                                   [](int n) { return n % 2 == 0; });
    std::cout << "偶数个数: " << evenCount << std::endl;
    
    // std::find_if
    auto it = std::find_if(numbers.begin(), numbers.end(),
                           [](int n) { return n > 5; });
    if (it != numbers.end()) {
        std::cout << "第一个大于5的数: " << *it << std::endl;
    }
    
    // std::sort with custom comparator
    std::vector<std::string> words = {"apple", "banana", "cherry", "date"};
    std::sort(words.begin(), words.end(),
              [](const std::string& a, const std::string& b) {
                  return a.length() < b.length(); // 按长度排序
              });
    
    std::cout << "按长度排序: ";
    for (const auto& word : words) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
    
    // std::accumulate
    auto sum = std::accumulate(numbers.begin(), numbers.end(), 0,
                               [](int acc, int n) { return acc + n; });
    std::cout << "求和: " << sum << std::endl;
    
    // std::remove_if
    auto newEnd = std::remove_if(numbers.begin(), numbers.end(),
                                 [](int n) { return n % 2 == 0; });
    numbers.erase(newEnd, numbers.end());
    
    std::cout << "移除偶数后: ";
    for (int n : numbers) {
        std::cout << n << " ";
    }
    std::cout << std::endl;
}
```

#### 复杂的Lambda应用场景

```cpp
#include <vector>
#include <map>
#include <algorithm>
#include <iostream>

struct Person {
    std::string name;
    int age;
    double salary;
    
    Person(const std::string& n, int a, double s) 
        : name(n), age(a), salary(s) {}
};

void complexLambdaExamples() {
    std::vector<Person> people = {
        {"Alice", 30, 50000},
        {"Bob", 25, 45000},
        {"Charlie", 35, 60000},
        {"Diana", 28, 55000},
        {"Eve", 32, 52000}
    };
    
    // 复杂排序：先按年龄，再按薪水
    std::sort(people.begin(), people.end(),
              [](const Person& a, const Person& b) {
                  if (a.age != b.age) return a.age < b.age;
                  return a.salary > b.salary;
              });
    
    std::cout << "按年龄和薪水排序:" << std::endl;
    for (const auto& p : people) {
        std::cout << p.name << " (年龄: " << p.age 
                  << ", 薪水: " << p.salary << ")" << std::endl;
    }
    
    // 分组统计
    std::map<std::string, int> ageGroups;
    std::for_each(people.begin(), people.end(),
                  [&ageGroups](const Person& p) {
                      std::string group;
                      if (p.age < 30) group = "年轻";
                      else if (p.age < 35) group = "中年";
                      else group = "资深";
                      ageGroups[group]++;
                  });
    
    std::cout << "\n年龄组统计:" << std::endl;
    for (const auto& [group, count] : ageGroups) {
        std::cout << group << ": " << count << "人" << std::endl;
    }
    
    // 条件筛选和转换
    std::vector<std::string> highEarners;
    std::transform(people.begin(), people.end(),
                   std::back_inserter(highEarners),
                   [](const Person& p) -> std::string {
                       if (p.salary > 50000) {
                           return p.name + " (高收入)";
                       }
                       return "";
                   });
    
    // 移除空字符串
    highEarners.erase(
        std::remove_if(highEarners.begin(), highEarners.end(),
                       [](const std::string& s) { return s.empty(); }),
        highEarners.end()
    );
    
    std::cout << "\n高收入人员:" << std::endl;
    for (const auto& name : highEarners) {
        std::cout << name << std::endl;
    }
}
```

### 6. 性能考虑

#### Lambda vs 函数指针 vs 函数对象

```cpp
#include <chrono>
#include <vector>
#include <algorithm>
#include <iostream>

// 函数指针版本
bool isEvenFunction(int n) {
    return n % 2 == 0;
}

// 函数对象版本
struct IsEvenFunctor {
    bool operator()(int n) const {
        return n % 2 == 0;
    }
};

void performanceComparison() {
    const size_t SIZE = 10000000;
    std::vector<int> data(SIZE);
    std::iota(data.begin(), data.end(), 1);
    
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start;
    
    // Lambda版本
    start = std::chrono::high_resolution_clock::now();
    auto count1 = std::count_if(data.begin(), data.end(),
                                [](int n) { return n % 2 == 0; });
    end = std::chrono::high_resolution_clock::now();
    auto lambda_time = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // 函数指针版本
    start = std::chrono::high_resolution_clock::now();
    auto count2 = std::count_if(data.begin(), data.end(), isEvenFunction);
    end = std::chrono::high_resolution_clock::now();
    auto function_time = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // 函数对象版本
    start = std::chrono::high_resolution_clock::now();
    auto count3 = std::count_if(data.begin(), data.end(), IsEvenFunctor{});
    end = std::chrono::high_resolution_clock::now();
    auto functor_time = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    std::cout << "性能比较 (处理" << SIZE << "个元素):" << std::endl;
    std::cout << "Lambda: " << lambda_time.count() << " 微秒" << std::endl;
    std::cout << "函数指针: " << function_time.count() << " 微秒" << std::endl;
    std::cout << "函数对象: " << functor_time.count() << " 微秒" << std::endl;
    std::cout << "结果验证: " << count1 << ", " << count2 << ", " << count3 << std::endl;
}
```

#### 捕获的性能影响

```cpp
#include <vector>
#include <chrono>
#include <iostream>

void capturePerformance() {
    const size_t SIZE = 1000000;
    std::vector<int> data(SIZE, 1);
    
    // 大对象
    std::vector<int> largeVector(1000, 42);
    
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start;
    
    // 无捕获Lambda（最快）
    start = std::chrono::high_resolution_clock::now();
    std::for_each(data.begin(), data.end(),
                  [](int& n) { n *= 2; });
    end = std::chrono::high_resolution_clock::now();
    auto no_capture_time = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // 按值捕获小对象
    int multiplier = 3;
    start = std::chrono::high_resolution_clock::now();
    std::for_each(data.begin(), data.end(),
                  [multiplier](int& n) { n *= multiplier; });
    end = std::chrono::high_resolution_clock::now();
    auto small_capture_time = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // 按引用捕获
    start = std::chrono::high_resolution_clock::now();
    std::for_each(data.begin(), data.end(),
                  [&multiplier](int& n) { n *= multiplier; });
    end = std::chrono::high_resolution_clock::now();
    auto ref_capture_time = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // 按值捕获大对象（较慢）
    start = std::chrono::high_resolution_clock::now();
    std::for_each(data.begin(), data.end(),
                  [largeVector](int& n) { 
                      n *= largeVector.size(); 
                  });
    end = std::chrono::high_resolution_clock::now();
    auto large_capture_time = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    std::cout << "捕获性能比较:" << std::endl;
    std::cout << "无捕获: " << no_capture_time.count() << " 微秒" << std::endl;
    std::cout << "小对象按值捕获: " << small_capture_time.count() << " 微秒" << std::endl;
    std::cout << "按引用捕获: " << ref_capture_time.count() << " 微秒" << std::endl;
    std::cout << "大对象按值捕获: " << large_capture_time.count() << " 微秒" << std::endl;
}
```

### 7. 实际应用场景

#### 事件处理系统

```cpp
#include <functional>
#include <vector>
#include <iostream>
#include <string>

class EventSystem {
public:
    using EventHandler = std::function<void(const std::string&)>;
    
private:
    std::vector<EventHandler> handlers;
    
public:
    void subscribe(EventHandler handler) {
        handlers.push_back(handler);
    }
    
    void publish(const std::string& event) {
        for (auto& handler : handlers) {
            handler(event);
        }
    }
};

void eventSystemExample() {
    EventSystem eventSystem;
    
    // 订阅不同的事件处理器
    eventSystem.subscribe([](const std::string& event) {
        std::cout << "日志记录: " << event << std::endl;
    });
    
    eventSystem.subscribe([](const std::string& event) {
        if (event.find("错误") != std::string::npos) {
            std::cout << "错误处理: " << event << std::endl;
        }
    });
    
    // 带状态的处理器
    int eventCount = 0;
    eventSystem.subscribe([&eventCount](const std::string& event) {
        eventCount++;
        std::cout << "事件计数器: " << eventCount << " - " << event << std::endl;
    });
    
    // 发布事件
    eventSystem.publish("用户登录");
    eventSystem.publish("数据更新");
    eventSystem.publish("系统错误");
}
```

#### 配置和策略模式

```cpp
#include <functional>
#include <map>
#include <iostream>
#include <string>

class Calculator {
public:
    using Operation = std::function<double(double, double)>;
    
private:
    std::map<std::string, Operation> operations;
    
public:
    Calculator() {
        // 使用Lambda定义操作
        operations["add"] = [](double a, double b) { return a + b; };
        operations["subtract"] = [](double a, double b) { return a - b; };
        operations["multiply"] = [](double a, double b) { return a * b; };
        operations["divide"] = [](double a, double b) {
            if (b != 0) return a / b;
            throw std::runtime_error("除零错误");
        };
        operations["power"] = [](double a, double b) {
            return std::pow(a, b);
        };
    }
    
    void addOperation(const std::string& name, Operation op) {
        operations[name] = op;
    }
    
    double calculate(const std::string& operation, double a, double b) {
        auto it = operations.find(operation);
        if (it != operations.end()) {
            return it->second(a, b);
        }
        throw std::runtime_error("未知操作: " + operation);
    }
    
    void listOperations() const {
        std::cout << "可用操作: ";
        for (const auto& [name, op] : operations) {
            std::cout << name << " ";
        }
        std::cout << std::endl;
    }
};

void calculatorExample() {
    Calculator calc;
    
    calc.listOperations();
    
    // 使用内置操作
    std::cout << "10 + 5 = " << calc.calculate("add", 10, 5) << std::endl;
    std::cout << "10 * 5 = " << calc.calculate("multiply", 10, 5) << std::endl;
    
    // 添加自定义操作
    calc.addOperation("mod", [](double a, double b) {
        return std::fmod(a, b);
    });
    
    calc.addOperation("max", [](double a, double b) {
        return std::max(a, b);
    });
    
    std::cout << "10 mod 3 = " << calc.calculate("mod", 10, 3) << std::endl;
    std::cout << "max(10, 5) = " << calc.calculate("max", 10, 5) << std::endl;
}
```

#### 异步编程和回调

```cpp
#include <functional>
#include <thread>
#include <chrono>
#include <iostream>
#include <future>

class AsyncProcessor {
public:
    using Callback = std::function<void(const std::string&)>;
    using ErrorCallback = std::function<void(const std::string&)>;
    
    void processAsync(const std::string& data, 
                     Callback onSuccess, 
                     ErrorCallback onError) {
        std::thread([data, onSuccess, onError]() {
            try {
                // 模拟处理时间
                std::this_thread::sleep_for(std::chrono::milliseconds(1000));
                
                // 模拟处理逻辑
                if (data.empty()) {
                    onError("数据为空");
                } else {
                    std::string result = "处理完成: " + data;
                    onSuccess(result);
                }
            } catch (const std::exception& e) {
                onError(std::string("处理异常: ") + e.what());
            }
        }).detach();
    }
    
    // 使用Promise/Future的版本
    std::future<std::string> processAsyncFuture(const std::string& data) {
        auto promise = std::make_shared<std::promise<std::string>>();
        auto future = promise->get_future();
        
        std::thread([data, promise]() {
            try {
                std::this_thread::sleep_for(std::chrono::milliseconds(500));
                
                if (data.empty()) {
                    promise->set_exception(
                        std::make_exception_ptr(std::runtime_error("数据为空"))
                    );
                } else {
                    promise->set_value("处理完成: " + data);
                }
            } catch (...) {
                promise->set_exception(std::current_exception());
            }
        }).detach();
        
        return future;
    }
};

void asyncExample() {
    AsyncProcessor processor;
    
    std::cout << "开始异步处理..." << std::endl;
    
    // 使用回调方式
    processor.processAsync("测试数据",
        [](const std::string& result) {
            std::cout << "成功回调: " << result << std::endl;
        },
        [](const std::string& error) {
            std::cout << "错误回调: " << error << std::endl;
        }
    );
    
    // 使用Future方式
    auto future = processor.processAsyncFuture("Future数据");
    
    try {
        auto result = future.get();
        std::cout << "Future结果: " << result << std::endl;
    } catch (const std::exception& e) {
        std::cout << "Future异常: " << e.what() << std::endl;
    }
    
    // 等待异步操作完成
    std::this_thread::sleep_for(std::chrono::milliseconds(1500));
}
```

## 设计原则

### 1. 简洁性原则
- 优先使用Lambda而不是函数对象（当逻辑简单时）
- 避免过于复杂的Lambda表达式
- 将复杂逻辑提取为独立函数

### 2. 性能考虑
- 小对象优先按值捕获
- 大对象优先按引用捕获
- 避免不必要的捕获
- 考虑内联优化

### 3. 可读性原则
- 使用有意义的参数名
- 适当添加类型注解
- 避免过深的嵌套

## 常见陷阱

### 1. 悬空引用
```cpp
// 错误：返回的Lambda包含悬空引用
std::function<int()> createBadLambda() {
    int local = 42;
    return [&local]() { return local; }; // 危险！local已销毁
}

// 正确：按值捕获
std::function<int()> createGoodLambda() {
    int local = 42;
    return [local]() { return local; }; // 安全
}
```

### 2. 意外的拷贝
```cpp
// 可能导致意外拷贝
std::vector<std::string> words = {"hello", "world"};
auto lambda = [words](const std::string& word) { // 拷贝整个vector
    return std::find(words.begin(), words.end(), word) != words.end();
};

// 更好的方式：按引用捕获
auto betterLambda = [&words](const std::string& word) {
    return std::find(words.begin(), words.end(), word) != words.end();
};
```

### 3. 递归Lambda的问题
```cpp
// 错误：无法直接递归
auto factorial = [](int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1); // 编译错误
};

// 正确方式1：使用std::function
std::function<int(int)> factorial = [&factorial](int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
};

// 正确方式2：传递自身
auto factorial2 = [](auto& self, int n) -> int {
    if (n <= 1) return 1;
    return n * self(self, n - 1);
};
```

## 最佳实践

### 1. 选择合适的捕获方式
```cpp
// 指导原则
void bestPractices() {
    int small_value = 42;
    std::vector<int> large_container(1000);
    
    // 小对象：按值捕获
    auto lambda1 = [small_value](int x) {
        return x + small_value;
    };
    
    // 大对象：按引用捕获
    auto lambda2 = [&large_container](int value) {
        large_container.push_back(value);
    };
    
    // 只读访问：const引用
    auto lambda3 = [&large_container](int target) {
        return std::find(large_container.begin(), 
                        large_container.end(), target) != large_container.end();
    };
}
```

### 2. 使用泛型Lambda（C++14）
```cpp
// 泛型Lambda更灵活
auto genericLambda = [](auto a, auto b) {
    return a + b;
};

// 可以处理不同类型
std::cout << genericLambda(1, 2) << std::endl;           // int
std::cout << genericLambda(1.5, 2.5) << std::endl;      // double
std::cout << genericLambda(std::string("Hello"), std::string(" World")) << std::endl; // string
```

### 3. 合理使用std::function
```cpp
// 只在需要类型擦除时使用std::function
class EventHandler {
private:
    std::vector<std::function<void(int)>> handlers;
    
public:
    template<typename F>
    void addHandler(F&& handler) {
        handlers.emplace_back(std::forward<F>(handler));
    }
    
    void trigger(int value) {
        for (auto& handler : handlers) {
            handler(value);
        }
    }
};
```

## 学习建议

1. **从简单开始**：先掌握基本的Lambda语法和捕获机制
2. **理解原理**：了解Lambda表达式的编译器实现
3. **实践应用**：在STL算法中大量使用Lambda
4. **性能意识**：了解不同捕获方式的性能影响
5. **函数式思维**：逐步培养函数式编程的思维方式

## 实用价值

掌握Lambda表达式和函数式编程将帮助你：
- 编写更简洁、表达力强的代码
- 更好地使用STL算法
- 实现灵活的回调和事件处理
- 提高代码的可读性和可维护性
- 掌握现代C++的编程范式

Lambda表达式是现代C++最重要的特性之一，它不仅简化了代码编写，还为函数式编程提供了强大的支持。通过合理使用Lambda表达式，你可以编写出更优雅、更高效的C++代码。