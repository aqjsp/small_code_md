# C++异常处理与文件操作

## 1. 异常处理理论基础

### 1.1 异常处理的计算机科学基础

异常处理是一种结构化的错误处理机制，其理论基础源于计算机科学中的控制流理论和程序语义学。异常处理机制的核心在于提供一种非局部的控制转移机制，允许程序在遇到异常情况时跳出正常的执行流程。

**控制流分离原理**：异常处理实现了正常控制流和异常控制流的分离。正常控制流处理程序的主要业务逻辑，而异常控制流专门处理错误情况。这种分离提高了代码的可读性和可维护性，符合关注点分离的软件工程原则。

**非局部跳转机制**：异常处理提供了一种结构化的非局部跳转机制，与传统的goto语句不同，异常处理的跳转是类型安全的，并且会自动处理资源清理。这种机制基于栈展开（stack unwinding）技术，确保在跳转过程中正确调用析构函数。

**错误传播语义**：异常处理定义了清晰的错误传播语义。当函数无法处理某个错误时，可以将错误传播给调用者，直到找到能够处理该错误的代码。这种传播机制避免了传统错误码需要在每个函数层级检查和传递的问题。

### 1.2 异常处理的类型系统

C++的异常处理建立在强类型系统之上，异常对象本身就是类型化的数据结构。这种设计带来了多个优势：

**类型安全的错误信息**：异常对象可以携带丰富的类型化信息，包括错误类型、错误描述、错误上下文等。通过继承机制，可以建立层次化的异常类型体系，支持多态的异常处理。

**异常匹配机制**：catch块的匹配遵循C++的类型匹配规则，包括精确匹配、基类匹配和转换匹配。这种机制允许编写通用的异常处理代码，同时保持类型安全。

**异常规范系统**：现代C++提供了noexcept规范，允许在函数签名中声明异常行为。这种规范不仅是文档，也是编译器优化的重要信息，有助于生成更高效的代码。

### 1.3 异常处理的语义模型

异常处理的语义模型定义了异常从抛出到捕获的完整过程：

**异常抛出语义**：throw表达式创建异常对象并启动异常传播过程。异常对象通常通过复制构造函数创建，因此异常类应该具有高效的复制语义。

**异常传播语义**：异常传播遵循调用栈的结构，从内层函数向外层函数传播。在传播过程中，会依次检查每个函数的异常处理器，直到找到匹配的处理器或到达程序顶层。

**异常捕获语义**：catch块捕获异常后，异常传播停止，程序控制权转移到异常处理代码。处理完成后，程序从catch块之后继续执行，而不是返回到异常抛出点。

## 2. 异常传播机制与栈展开

### 2.1 栈展开的实现原理

栈展开是异常处理机制的核心技术，它确保在异常传播过程中正确清理资源和调用析构函数。

**栈帧管理**：每个函数调用都会在调用栈上创建一个栈帧，包含局部变量、参数和返回地址等信息。栈展开过程需要逐个销毁这些栈帧，并调用相应的析构函数。

**异常表机制**：编译器为每个函数生成异常表，记录异常处理器的位置和类型信息。运行时系统使用这些信息来查找合适的异常处理器。

**RAII集成**：栈展开过程与RAII机制完美集成。当栈帧被销毁时，其中的RAII对象会自动调用析构函数，确保资源得到正确释放。

### 2.2 异常传播的性能模型

异常处理的性能特征与正常控制流显著不同：

**零成本异常模型**：现代C++实现采用零成本异常模型，即在没有异常抛出时，异常处理机制不会产生运行时开销。这通过编译时生成异常表和运行时查表实现。

**异常路径开销**：当异常实际发生时，栈展开过程会产生显著的性能开销，包括查找异常处理器、调用析构函数、清理栈帧等。因此，异常应该只用于真正的异常情况。

**编译器优化**：编译器可以基于noexcept规范进行优化，包括消除不必要的异常处理代码、优化函数调用等。

### 2.3 异常安全的理论基础

异常安全是异常处理理论的重要组成部分，它定义了在异常环境下程序行为的正确性标准。

**不变量保持**：异常安全的核心是保持程序不变量。即使在异常发生时，对象和系统的重要不变量也应该得到维护。

**资源管理**：异常安全要求在任何情况下都不能泄露资源。这通过RAII机制和智能指针等技术实现。

**状态一致性**：异常安全要求对象在异常发生后仍然处于一致的状态，即使这个状态可能与异常发生前不同。

## 3. 异常安全编程理论

### 3.1 异常安全级别的理论分析

异常安全编程定义了四个层次的安全保证，每个层次都有其理论基础和适用场景：

**无异常保证的理论基础**：无异常保证基于确定性计算理论，要求函数的行为完全可预测。这种保证通常用于系统的关键部分，如析构函数、移动操作等。实现无异常保证需要仔细的设计和实现，确保所有可能的错误情况都能在函数内部处理。

**强异常安全保证的理论模型**：强异常安全保证基于事务处理理论，要求操作具有原子性。操作要么完全成功，要么完全失败，不存在中间状态。这种保证的实现通常采用"提交或回滚"模式，先在临时状态下进行操作，成功后再提交到最终状态。

### 3.2 异常处理的实践应用

**基础异常处理示例**

```cpp
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>
#include <memory>

// 自定义异常类层次结构
class ApplicationException : public std::exception {
protected:
    std::string message;
    std::string context;
    
public:
    ApplicationException(const std::string& msg, const std::string& ctx = "")
        : message(msg), context(ctx) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
    
    const std::string& getContext() const noexcept {
        return context;
    }
    
    virtual std::string getFullMessage() const {
        return context.empty() ? message : context + ": " + message;
    }
};

class ValidationException : public ApplicationException {
public:
    ValidationException(const std::string& field, const std::string& reason)
        : ApplicationException("验证失败: " + reason, "字段: " + field) {}
};

class ResourceException : public ApplicationException {
public:
    ResourceException(const std::string& resource, const std::string& operation)
        : ApplicationException("资源操作失败: " + operation, "资源: " + resource) {}
};

class NetworkException : public ApplicationException {
private:
    int errorCode;
    
public:
    NetworkException(const std::string& msg, int code)
        : ApplicationException(msg, "网络错误"), errorCode(code) {}
    
    int getErrorCode() const noexcept { return errorCode; }
    
    std::string getFullMessage() const override {
        return ApplicationException::getFullMessage() + " (错误码: " + std::to_string(errorCode) + ")";
    }
};

// 演示基础异常处理
class Calculator {
public:
    static double divide(double a, double b) {
        if (b == 0.0) {
            throw std::invalid_argument("除数不能为零");
        }
        return a / b;
    }
    
    static double sqrt(double x) {
        if (x < 0.0) {
            throw std::domain_error("负数不能开平方根");
        }
        return std::sqrt(x);
    }
    
    static std::vector<double> processArray(const std::vector<double>& input) {
        if (input.empty()) {
            throw std::invalid_argument("输入数组不能为空");
        }
        
        std::vector<double> result;
        result.reserve(input.size());
        
        try {
            for (size_t i = 0; i < input.size(); ++i) {
                if (input[i] < 0) {
                    throw ValidationException("数组元素[" + std::to_string(i) + "]", 
                                            "值不能为负数: " + std::to_string(input[i]));
                }
                result.push_back(sqrt(input[i]));
            }
        } catch (...) {
            // 清理已分配的资源
            result.clear();
            throw; // 重新抛出异常
        }
        
        return result;
    }
};

void demonstrateBasicExceptionHandling() {
    std::cout << "=== 基础异常处理演示 ===" << std::endl;
    
    // 1. 基本异常捕获
    try {
        double result = Calculator::divide(10.0, 0.0);
        std::cout << "结果: " << result << std::endl;
    } catch (const std::invalid_argument& e) {
        std::cout << "捕获到invalid_argument异常: " << e.what() << std::endl;
    }
    
    // 2. 多种异常类型处理
    std::vector<double> testData = {4.0, 9.0, -1.0, 16.0};
    
    try {
        auto results = Calculator::processArray(testData);
        std::cout << "处理结果: ";
        for (double val : results) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    } catch (const ValidationException& e) {
        std::cout << "验证异常: " << e.getFullMessage() << std::endl;
    } catch (const std::domain_error& e) {
        std::cout << "域错误: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cout << "标准异常: " << e.what() << std::endl;
    }
    
    // 3. 异常重新抛出
    try {
        try {
            throw NetworkException("连接超时", 408);
        } catch (const NetworkException& e) {
            std::cout << "内层捕获: " << e.getFullMessage() << std::endl;
            throw; // 重新抛出
        }
    } catch (const ApplicationException& e) {
        std::cout << "外层捕获: " << e.getFullMessage() << std::endl;
    }
}

// RAII和异常安全示例
class SafeResource {
private:
    std::string name;
    bool acquired;
    
public:
    explicit SafeResource(const std::string& resourceName) 
        : name(resourceName), acquired(false) {
        std::cout << "尝试获取资源: " << name << std::endl;
        
        // 模拟资源获取可能失败
        if (name == "invalid_resource") {
            throw ResourceException(name, "获取失败");
        }
        
        acquired = true;
        std::cout << "成功获取资源: " << name << std::endl;
    }
    
    ~SafeResource() {
        if (acquired) {
            std::cout << "释放资源: " << name << std::endl;
        }
    }
    
    // 禁止拷贝，只允许移动
    SafeResource(const SafeResource&) = delete;
    SafeResource& operator=(const SafeResource&) = delete;
    
    SafeResource(SafeResource&& other) noexcept 
        : name(std::move(other.name)), acquired(other.acquired) {
        other.acquired = false;
        std::cout << "移动资源: " << name << std::endl;
    }
    
    SafeResource& operator=(SafeResource&& other) noexcept {
        if (this != &other) {
            if (acquired) {
                std::cout << "释放旧资源: " << name << std::endl;
            }
            name = std::move(other.name);
            acquired = other.acquired;
            other.acquired = false;
        }
        return *this;
    }
    
    void use() const {
        if (!acquired) {
            throw std::runtime_error("资源未获取");
        }
        std::cout << "使用资源: " << name << std::endl;
    }
};

// 异常安全的容器操作
template<typename T>
class SafeVector {
private:
    std::vector<T> data;
    
public:
    // 强异常安全保证的添加操作
    void safeAdd(const T& item) {
        std::vector<T> temp = data; // 创建副本
        temp.push_back(item);       // 在副本上操作
        data = std::move(temp);     // 成功后移动赋值
        std::cout << "安全添加元素，当前大小: " << data.size() << std::endl;
    }
    
    // 基本异常安全保证的批量添加
    void addRange(const std::vector<T>& items) {
        size_t originalSize = data.size();
        try {
            for (const auto& item : items) {
                data.push_back(item);
                // 模拟可能的异常
                if (data.size() > 10) {
                    throw std::runtime_error("容器大小超限");
                }
            }
            std::cout << "成功添加 " << items.size() << " 个元素" << std::endl;
        } catch (...) {
            // 回滚到原始状态
            data.resize(originalSize);
            std::cout << "添加失败，已回滚到原始状态，大小: " << data.size() << std::endl;
            throw;
        }
    }
    
    size_t size() const noexcept { return data.size(); }
    
    const T& at(size_t index) const {
        if (index >= data.size()) {
            throw std::out_of_range("索引超出范围: " + std::to_string(index));
        }
        return data[index];
    }
};

void demonstrateExceptionSafety() {
    std::cout << "\n=== 异常安全编程演示 ===" << std::endl;
    
    // 1. RAII资源管理
    std::cout << "\n1. RAII资源管理:" << std::endl;
    try {
        SafeResource resource1("database_connection");
        resource1.use();
        
        SafeResource resource2("invalid_resource"); // 这会抛出异常
        resource2.use();
    } catch (const ResourceException& e) {
        std::cout << "资源异常: " << e.getFullMessage() << std::endl;
    }
    
    // 2. 异常安全的容器操作
    std::cout << "\n2. 异常安全的容器操作:" << std::endl;
    SafeVector<int> safeVec;
    
    // 安全添加
    for (int i = 1; i <= 5; ++i) {
        safeVec.safeAdd(i);
    }
    
    // 批量添加（会失败）
    try {
        std::vector<int> batch = {6, 7, 8, 9, 10, 11, 12}; // 超过限制
        safeVec.addRange(batch);
    } catch (const std::runtime_error& e) {
        std::cout << "批量添加异常: " << e.what() << std::endl;
        std::cout << "当前容器大小: " << safeVec.size() << std::endl;
    }
    
    // 3. 智能指针和异常安全
    std::cout << "\n3. 智能指针和异常安全:" << std::endl;
    try {
        auto ptr1 = std::make_unique<SafeResource>("memory_resource");
        auto ptr2 = std::make_unique<SafeResource>("network_resource");
        
        ptr1->use();
        ptr2->use();
        
        // 即使这里抛出异常，智能指针也会自动清理资源
        throw std::runtime_error("模拟异常");
        
    } catch (const std::exception& e) {
        std::cout << "捕获异常: " << e.what() << std::endl;
        std::cout << "智能指针已自动清理资源" << std::endl;
    }
}

int main() {
    try {
        demonstrateBasicExceptionHandling();
        demonstrateExceptionSafety();
    } catch (const std::exception& e) {
        std::cerr << "未处理的异常: " << e.what() << std::endl;
        return 1;
    } catch (...) {
        std::cerr << "未知异常" << std::endl;
        return 1;
    }
    
    return 0;
}
```

## 4. 文件操作的实践应用

**现代C++文件操作示例**

```cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <filesystem>
#include <chrono>
#include <iomanip>
#include <algorithm>

namespace fs = std::filesystem;

// 文件操作异常类
class FileException : public std::exception {
private:
    std::string message;
    std::string filename;
    
public:
    FileException(const std::string& msg, const std::string& file = "")
        : message(msg), filename(file) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
    
    const std::string& getFilename() const noexcept {
        return filename;
    }
};

// 安全的文件操作类
class SafeFileHandler {
private:
    std::string filepath;
    
public:
    explicit SafeFileHandler(const std::string& path) : filepath(path) {}
    
    // 安全读取文件内容
    std::string readFile() const {
        std::ifstream file(filepath);
        if (!file.is_open()) {
            throw FileException("无法打开文件进行读取", filepath);
        }
        
        // 检查文件大小
        file.seekg(0, std::ios::end);
        auto fileSize = file.tellg();
        file.seekg(0, std::ios::beg);
        
        if (fileSize > 100 * 1024 * 1024) { // 100MB限制
            throw FileException("文件过大，超过100MB限制", filepath);
        }
        
        std::ostringstream buffer;
        buffer << file.rdbuf();
        
        if (file.bad()) {
            throw FileException("读取文件时发生错误", filepath);
        }
        
        return buffer.str();
    }
    
    // 安全写入文件内容
    void writeFile(const std::string& content, bool append = false) const {
        std::ios::openmode mode = std::ios::out;
        if (append) {
            mode |= std::ios::app;
        }
        
        std::ofstream file(filepath, mode);
        if (!file.is_open()) {
            throw FileException("无法打开文件进行写入", filepath);
        }
        
        file << content;
        
        if (file.fail()) {
            throw FileException("写入文件时发生错误", filepath);
        }
        
        file.close();
        if (file.fail()) {
            throw FileException("关闭文件时发生错误", filepath);
        }
    }
    
    // 逐行读取文件
    std::vector<std::string> readLines() const {
        std::ifstream file(filepath);
        if (!file.is_open()) {
            throw FileException("无法打开文件进行读取", filepath);
        }
        
        std::vector<std::string> lines;
        std::string line;
        
        while (std::getline(file, line)) {
            lines.push_back(line);
        }
        
        if (file.bad()) {
            throw FileException("读取文件行时发生错误", filepath);
        }
        
        return lines;
    }
    
    // 写入多行内容
    void writeLines(const std::vector<std::string>& lines, bool append = false) const {
        std::ios::openmode mode = std::ios::out;
        if (append) {
            mode |= std::ios::app;
        }
        
        std::ofstream file(filepath, mode);
        if (!file.is_open()) {
            throw FileException("无法打开文件进行写入", filepath);
        }
        
        for (const auto& line : lines) {
            file << line << '\n';
            if (file.fail()) {
                throw FileException("写入文件行时发生错误", filepath);
            }
        }
    }
    
    // 获取文件信息
    struct FileInfo {
        std::uintmax_t size;
        std::filesystem::file_time_type lastModified;
        bool isRegularFile;
        bool isDirectory;
        std::string permissions;
    };
    
    FileInfo getFileInfo() const {
        if (!fs::exists(filepath)) {
            throw FileException("文件不存在", filepath);
        }
        
        FileInfo info;
        std::error_code ec;
        
        info.size = fs::file_size(filepath, ec);
        if (ec) {
            throw FileException("无法获取文件大小: " + ec.message(), filepath);
        }
        
        info.lastModified = fs::last_write_time(filepath, ec);
        if (ec) {
            throw FileException("无法获取文件修改时间: " + ec.message(), filepath);
        }
        
        info.isRegularFile = fs::is_regular_file(filepath);
        info.isDirectory = fs::is_directory(filepath);
        
        auto perms = fs::status(filepath).permissions();
        std::ostringstream permStr;
        permStr << ((perms & fs::perms::owner_read) != fs::perms::none ? "r" : "-");
        permStr << ((perms & fs::perms::owner_write) != fs::perms::none ? "w" : "-");
        permStr << ((perms & fs::perms::owner_exec) != fs::perms::none ? "x" : "-");
        info.permissions = permStr.str();
        
        return info;
    }
};

// 目录操作类
class DirectoryHandler {
private:
    fs::path dirPath;
    
public:
    explicit DirectoryHandler(const std::string& path) : dirPath(path) {}
    
    // 创建目录
    void createDirectory() const {
        std::error_code ec;
        if (!fs::create_directories(dirPath, ec)) {
            if (ec) {
                throw FileException("创建目录失败: " + ec.message(), dirPath.string());
            }
        }
        std::cout << "目录创建成功: " << dirPath << std::endl;
    }
    
    // 列出目录内容
    std::vector<std::string> listContents(bool recursive = false) const {
        if (!fs::exists(dirPath)) {
            throw FileException("目录不存在", dirPath.string());
        }
        
        if (!fs::is_directory(dirPath)) {
            throw FileException("路径不是目录", dirPath.string());
        }
        
        std::vector<std::string> contents;
        std::error_code ec;
        
        if (recursive) {
            for (const auto& entry : fs::recursive_directory_iterator(dirPath, ec)) {
                if (ec) {
                    std::cerr << "警告: 访问 " << entry.path() << " 时出错: " << ec.message() << std::endl;
                    continue;
                }
                contents.push_back(entry.path().string());
            }
        } else {
            for (const auto& entry : fs::directory_iterator(dirPath, ec)) {
                if (ec) {
                    std::cerr << "警告: 访问 " << entry.path() << " 时出错: " << ec.message() << std::endl;
                    continue;
                }
                contents.push_back(entry.path().filename().string());
            }
        }
        
        return contents;
    }
    
    // 删除目录
    void removeDirectory(bool recursive = false) const {
        std::error_code ec;
        std::uintmax_t removedCount;
        
        if (recursive) {
            removedCount = fs::remove_all(dirPath, ec);
        } else {
            removedCount = fs::remove(dirPath, ec) ? 1 : 0;
        }
        
        if (ec) {
            throw FileException("删除目录失败: " + ec.message(), dirPath.string());
        }
        
        std::cout << "成功删除 " << removedCount << " 个文件/目录" << std::endl;
    }
    
    // 复制目录
    void copyTo(const std::string& destination) const {
        std::error_code ec;
        fs::copy(dirPath, destination, 
                fs::copy_options::recursive | fs::copy_options::overwrite_existing, ec);
        
        if (ec) {
            throw FileException("复制目录失败: " + ec.message(), 
                              dirPath.string() + " -> " + destination);
        }
        
        std::cout << "目录复制成功: " << dirPath << " -> " << destination << std::endl;
    }
};

// CSV文件处理示例
class CSVHandler {
private:
    std::string filepath;
    char delimiter;
    
public:
    CSVHandler(const std::string& path, char delim = ',') 
        : filepath(path), delimiter(delim) {}
    
    // 读取CSV文件
    std::vector<std::vector<std::string>> readCSV() const {
        SafeFileHandler fileHandler(filepath);
        auto lines = fileHandler.readLines();
        
        std::vector<std::vector<std::string>> data;
        
        for (const auto& line : lines) {
            if (line.empty()) continue;
            
            std::vector<std::string> row;
            std::stringstream ss(line);
            std::string cell;
            
            while (std::getline(ss, cell, delimiter)) {
                // 去除首尾空格
                cell.erase(0, cell.find_first_not_of(" \t"));
                cell.erase(cell.find_last_not_of(" \t") + 1);
                row.push_back(cell);
            }
            
            data.push_back(row);
        }
        
        return data;
    }
    
    // 写入CSV文件
    void writeCSV(const std::vector<std::vector<std::string>>& data) const {
        std::ostringstream content;
        
        for (const auto& row : data) {
            for (size_t i = 0; i < row.size(); ++i) {
                if (i > 0) content << delimiter;
                
                // 如果包含分隔符或引号，需要用引号包围
                std::string cell = row[i];
                if (cell.find(delimiter) != std::string::npos || 
                    cell.find('"') != std::string::npos) {
                    // 转义引号
                    size_t pos = 0;
                    while ((pos = cell.find('"', pos)) != std::string::npos) {
                        cell.insert(pos, "\"");
                        pos += 2;
                    }
                    content << '"' << cell << '"';
                } else {
                    content << cell;
                }
            }
            content << '\n';
        }
        
        SafeFileHandler fileHandler(filepath);
        fileHandler.writeFile(content.str());
    }
};

void demonstrateFileOperations() {
    std::cout << "=== 文件操作演示 ===" << std::endl;
    
    try {
        // 1. 基本文件读写
        std::cout << "\n1. 基本文件读写:" << std::endl;
        
        SafeFileHandler fileHandler("test_file.txt");
        
        // 写入内容
        std::string content = "Hello, C++ File Operations!\n这是第二行内容。\n";
        fileHandler.writeFile(content);
        std::cout << "文件写入成功" << std::endl;
        
        // 读取内容
        std::string readContent = fileHandler.readFile();
        std::cout << "读取的内容:\n" << readContent << std::endl;
        
        // 获取文件信息
        auto info = fileHandler.getFileInfo();
        std::cout << "文件大小: " << info.size << " 字节" << std::endl;
        std::cout << "权限: " << info.permissions << std::endl;
        
        // 2. 逐行操作
        std::cout << "\n2. 逐行文件操作:" << std::endl;
        
        std::vector<std::string> lines = {
            "第一行数据",
            "第二行数据",
            "第三行数据"
        };
        
        fileHandler.writeLines(lines);
        auto readLines = fileHandler.readLines();
        
        std::cout << "读取的行数: " << readLines.size() << std::endl;
        for (size_t i = 0; i < readLines.size(); ++i) {
            std::cout << "行 " << (i + 1) << ": " << readLines[i] << std::endl;
        }
        
        // 3. 目录操作
        std::cout << "\n3. 目录操作:" << std::endl;
        
        DirectoryHandler dirHandler("test_directory");
        dirHandler.createDirectory();
        
        // 在目录中创建一些文件
        SafeFileHandler file1("test_directory/file1.txt");
        SafeFileHandler file2("test_directory/file2.txt");
        file1.writeFile("文件1的内容");
        file2.writeFile("文件2的内容");
        
        // 列出目录内容
        auto contents = dirHandler.listContents();
        std::cout << "目录内容:" << std::endl;
        for (const auto& item : contents) {
            std::cout << "  " << item << std::endl;
        }
        
        // 4. CSV文件处理
        std::cout << "\n4. CSV文件处理:" << std::endl;
        
        CSVHandler csvHandler("test_data.csv");
        
        // 创建CSV数据
        std::vector<std::vector<std::string>> csvData = {
            {"姓名", "年龄", "城市"},
            {"张三", "25", "北京"},
            {"李四", "30", "上海"},
            {"王五", "28", "广州"}
        };
        
        csvHandler.writeCSV(csvData);
        std::cout << "CSV文件写入成功" << std::endl;
        
        // 读取CSV数据
        auto readData = csvHandler.readCSV();
        std::cout << "CSV数据读取:" << std::endl;
        for (const auto& row : readData) {
            for (size_t i = 0; i < row.size(); ++i) {
                if (i > 0) std::cout << " | ";
                std::cout << row[i];
            }
            std::cout << std::endl;
        }
        
        // 清理测试文件
        std::cout << "\n清理测试文件..." << std::endl;
        fs::remove("test_file.txt");
        fs::remove("test_data.csv");
        dirHandler.removeDirectory(true);
        
    } catch (const FileException& e) {
        std::cerr << "文件操作异常: " << e.what();
        if (!e.getFilename().empty()) {
            std::cerr << " (文件: " << e.getFilename() << ")";
        }
        std::cerr << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "标准异常: " << e.what() << std::endl;
    }
}

int main() {
    try {
        demonstrateFileOperations();
    } catch (const std::exception& e) {
        std::cerr << "程序异常: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}