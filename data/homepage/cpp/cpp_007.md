# C++继承与多态概念指南：深度理解与实践指南

## 学习目标

通过本章学习，你将理解：

- 继承的基本概念和设计思想
- 单继承与多重继承的特点和应用
- 多态的实现原理和使用场景
- 虚函数的工作机制
- 抽象类与接口设计的理念
- 继承与多态的最佳实践

## 目标读者

- 已掌握C++基础语法的学习者
- 希望深入理解面向对象编程概念的开发者
- 需要设计类层次结构的程序员

## 前置知识

- C++基本语法
- 类与对象的基础概念
- 构造函数与析构函数
- 访问控制机制

## 继承的核心概念

### 什么是继承

继承是面向对象编程的基础特性之一，它允许一个类（派生类）获得另一个类（基类）的属性和行为。继承建立了"is-a"关系，表示派生类是基类的一种特殊形式。

继承的本质是代码重用和概念抽象。通过继承，我们可以：
- 避免重复编写相似的代码
- 建立清晰的概念层次
- 支持多态行为
- 提高代码的可维护性

### 继承的类型

**公有继承（public inheritance）**
- 最常用的继承方式
- 保持基类的访问控制级别
- 支持完整的"is-a"关系
- 允许派生类对象替代基类对象使用

**保护继承（protected inheritance）**
- 将基类的公有成员变为保护成员
- 主要用于受限的接口继承
- 使用场景相对有限

**私有继承（private inheritance）**
- 将基类的所有成员变为私有
- 表达"implemented-in-terms-of"关系
- 用于实现继承而非接口继承

### 单继承与多重继承

**单继承的特点**
- 每个类只有一个直接基类
- 形成简单的树状结构
- 内存布局相对简单
- 名称查找规则清晰

**多重继承的复杂性**
- 一个类可以从多个基类继承
- 可能导致菱形继承问题
- 名称查找可能产生歧义
- 需要虚继承来解决某些问题

## 多态的基本原理

### 多态的概念

多态（Polymorphism）意味着"多种形态"，它允许同一个接口表现出不同的行为。在C++中，多态主要通过虚函数实现，使得程序可以在运行时根据对象的实际类型调用相应的函数。

多态的核心价值在于：
- 提高代码的灵活性
- 支持开闭原则（对扩展开放，对修改关闭）
- 简化客户端代码
- 支持统一的接口处理不同类型的对象

### 虚函数的工作机制

**虚函数表（Virtual Function Table）**
- 每个包含虚函数的类都有一个虚函数表
- 表中存储指向虚函数的指针
- 对象包含指向虚函数表的指针
- 运行时通过查表确定调用哪个函数

**动态绑定过程**
1. 程序通过基类指针或引用调用虚函数
2. 系统查找对象的虚函数表指针
3. 在虚函数表中找到对应函数的地址
4. 调用实际的函数实现

这个过程确保了即使通过基类指针，也能调用到派生类的正确实现。

### 纯虚函数与抽象类

**抽象基类示例**

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <string>

// 抽象基类：图形
class Shape {
protected:
    std::string name;
    
public:
    Shape(const std::string& n) : name(n) {
        std::cout << "创建图形: " << name << std::endl;
    }
    
    virtual ~Shape() {
        std::cout << "销毁图形: " << name << std::endl;
    }
    
    // 纯虚函数 - 计算面积
    virtual double getArea() const = 0;
    
    // 纯虚函数 - 计算周长
    virtual double getPerimeter() const = 0;
    
    // 纯虚函数 - 绘制图形
    virtual void draw() const = 0;
    
    // 普通虚函数 - 显示信息
    virtual void displayInfo() const {
        std::cout << "图形名称: " << name << std::endl;
        std::cout << "面积: " << getArea() << std::endl;
        std::cout << "周长: " << getPerimeter() << std::endl;
    }
    
    std::string getName() const { return name; }
};

// 具体类：矩形
class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) 
        : Shape("矩形"), width(w), height(h) {
        std::cout << "创建矩形: " << width << "x" << height << std::endl;
    }
    
    ~Rectangle() {
        std::cout << "销毁矩形" << std::endl;
    }
    
    // 实现纯虚函数
    double getArea() const override {
        return width * height;
    }
    
    double getPerimeter() const override {
        return 2 * (width + height);
    }
    
    void draw() const override {
        std::cout << "绘制矩形 (" << width << "x" << height << ")" << std::endl;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 5; j++) {
                std::cout << "* ";
            }
            std::cout << std::endl;
        }
    }
    
    // 矩形特有的方法
    double getWidth() const { return width; }
    double getHeight() const { return height; }
    
    bool isSquare() const {
        return width == height;
    }
};

// 具体类：圆形
class Circle : public Shape {
private:
    double radius;
    static constexpr double PI = 3.14159265359;
    
public:
    Circle(double r) : Shape("圆形"), radius(r) {
        std::cout << "创建圆形: 半径 " << radius << std::endl;
    }
    
    ~Circle() {
        std::cout << "销毁圆形" << std::endl;
    }
    
    // 实现纯虚函数
    double getArea() const override {
        return PI * radius * radius;
    }
    
    double getPerimeter() const override {
        return 2 * PI * radius;
    }
    
    void draw() const override {
        std::cout << "绘制圆形 (半径: " << radius << ")" << std::endl;
        std::cout << "    ***    " << std::endl;
        std::cout << "  *     *  " << std::endl;
        std::cout << " *       * " << std::endl;
        std::cout << "  *     *  " << std::endl;
        std::cout << "    ***    " << std::endl;
    }
    
    // 圆形特有的方法
    double getRadius() const { return radius; }
    
    double getDiameter() const {
        return 2 * radius;
    }
};

// 具体类：三角形
class Triangle : public Shape {
private:
    double side1, side2, side3;
    
public:
    Triangle(double s1, double s2, double s3) 
        : Shape("三角形"), side1(s1), side2(s2), side3(s3) {
        if (!isValidTriangle()) {
            throw std::invalid_argument("无效的三角形边长");
        }
        std::cout << "创建三角形: " << side1 << ", " << side2 << ", " << side3 << std::endl;
    }
    
    ~Triangle() {
        std::cout << "销毁三角形" << std::endl;
    }
    
    // 实现纯虚函数
    double getArea() const override {
        // 使用海伦公式
        double s = getPerimeter() / 2;
        return sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }
    
    double getPerimeter() const override {
        return side1 + side2 + side3;
    }
    
    void draw() const override {
        std::cout << "绘制三角形 (" << side1 << ", " << side2 << ", " << side3 << ")" << std::endl;
        std::cout << "    *    " << std::endl;
        std::cout << "   * *   " << std::endl;
        std::cout << "  *   *  " << std::endl;
        std::cout << " *     * " << std::endl;
        std::cout << "********* " << std::endl;
    }
    
    // 三角形特有的方法
    bool isValidTriangle() const {
        return (side1 + side2 > side3) && 
               (side1 + side3 > side2) && 
               (side2 + side3 > side1);
    }
    
    bool isEquilateral() const {
        return side1 == side2 && side2 == side3;
    }
    
    bool isIsosceles() const {
        return side1 == side2 || side2 == side3 || side1 == side3;
    }
};

// 图形管理器类
class ShapeManager {
private:
    std::vector<std::unique_ptr<Shape>> shapes;
    
public:
    void addShape(std::unique_ptr<Shape> shape) {
        shapes.push_back(std::move(shape));
    }
    
    void displayAllShapes() const {
        std::cout << "\n=== 所有图形信息 ===" << std::endl;
        for (const auto& shape : shapes) {
            shape->displayInfo();
            shape->draw();
            std::cout << "---" << std::endl;
        }
    }
    
    double getTotalArea() const {
        double total = 0;
        for (const auto& shape : shapes) {
            total += shape->getArea();
        }
        return total;
    }
    
    void drawAllShapes() const {
        std::cout << "\n=== 绘制所有图形 ===" << std::endl;
        for (const auto& shape : shapes) {
            shape->draw();
            std::cout << std::endl;
        }
    }
    
    size_t getShapeCount() const {
        return shapes.size();
    }
};

int main() {
    try {
        std::cout << "=== 多态与抽象类演示 ===" << std::endl;
        
        // 创建图形管理器
        ShapeManager manager;
        
        // 添加不同类型的图形
        manager.addShape(std::make_unique<Rectangle>(4.0, 3.0));
        manager.addShape(std::make_unique<Circle>(2.5));
        manager.addShape(std::make_unique<Triangle>(3.0, 4.0, 5.0));
        manager.addShape(std::make_unique<Rectangle>(2.0, 2.0)); // 正方形
        
        // 显示所有图形信息
        manager.displayAllShapes();
        
        // 计算总面积
        std::cout << "\n总图形数量: " << manager.getShapeCount() << std::endl;
        std::cout << "总面积: " << manager.getTotalArea() << std::endl;
        
        // 绘制所有图形
        manager.drawAllShapes();
        
        std::cout << "\n=== 多态演示 ===" << std::endl;
        
        // 使用基类指针数组演示多态
        std::vector<std::unique_ptr<Shape>> polyShapes;
        polyShapes.push_back(std::make_unique<Rectangle>(1.0, 2.0));
        polyShapes.push_back(std::make_unique<Circle>(1.0));
        
        for (const auto& shape : polyShapes) {
            std::cout << "通过基类指针调用:" << std::endl;
            shape->displayInfo();
            std::cout << std::endl;
        }
        
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    return 0;
}
```

## 继承的核心概念

### 基本继承示例

**动物继承体系的完整实现**

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>

// 基类：动物
class Animal {
protected:
    std::string name;
    int age;
    double weight;
    
public:
    Animal(const std::string& n, int a, double w) 
        : name(n), age(a), weight(w) {
        std::cout << "创建动物: " << name << std::endl;
    }
    
    virtual ~Animal() {
        std::cout << "销毁动物: " << name << std::endl;
    }
    
    // 虚函数 - 可以被重写
    virtual void makeSound() const {
        std::cout << name << " 发出声音" << std::endl;
    }
    
    virtual void move() const {
        std::cout << name << " 在移动" << std::endl;
    }
    
    virtual void eat(const std::string& food) const {
        std::cout << name << " 正在吃 " << food << std::endl;
    }
    
    virtual void sleep() const {
        std::cout << name << " 正在睡觉" << std::endl;
    }
    
    // 非虚函数 - 通用行为
    void displayBasicInfo() const {
        std::cout << "动物信息:" << std::endl;
        std::cout << "  姓名: " << name << std::endl;
        std::cout << "  年龄: " << age << " 岁" << std::endl;
        std::cout << "  体重: " << weight << " kg" << std::endl;
    }
    
    // Getter方法
    std::string getName() const { return name; }
    int getAge() const { return age; }
    double getWeight() const { return weight; }
    
    // Setter方法
    void setAge(int newAge) {
        if (newAge >= 0) age = newAge;
    }
    
    void setWeight(double newWeight) {
        if (newWeight > 0) weight = newWeight;
    }
};

// 派生类：哺乳动物
class Mammal : public Animal {
protected:
    std::string furColor;
    bool isWarmBlooded;
    
public:
    Mammal(const std::string& n, int a, double w, const std::string& fur) 
        : Animal(n, a, w), furColor(fur), isWarmBlooded(true) {
        std::cout << "创建哺乳动物: " << name << std::endl;
    }
    
    virtual ~Mammal() {
        std::cout << "销毁哺乳动物: " << name << std::endl;
    }
    
    // 重写基类方法
    void eat(const std::string& food) const override {
        std::cout << name << " (哺乳动物) 正在咀嚼 " << food << std::endl;
    }
    
    // 哺乳动物特有的方法
    virtual void giveBirth() const {
        std::cout << name << " 正在生育幼崽" << std::endl;
    }
    
    virtual void produceMilk() const {
        std::cout << name << " 正在产奶" << std::endl;
    }
    
    void displayMammalInfo() const {
        displayBasicInfo();
        std::cout << "  毛色: " << furColor << std::endl;
        std::cout << "  恒温动物: " << (isWarmBlooded ? "是" : "否") << std::endl;
    }
    
    std::string getFurColor() const { return furColor; }
};

// 具体类：狗
class Dog : public Mammal {
private:
    std::string breed;
    bool isTrained;
    
public:
    Dog(const std::string& n, int a, double w, const std::string& fur, const std::string& b) 
        : Mammal(n, a, w, fur), breed(b), isTrained(false) {
        std::cout << "创建狗: " << name << " (" << breed << ")" << std::endl;
    }
    
    ~Dog() {
        std::cout << "销毁狗: " << name << std::endl;
    }
    
    // 重写虚函数
    void makeSound() const override {
        std::cout << name << " 汪汪叫" << std::endl;
    }
    
    void move() const override {
        std::cout << name << " 快乐地奔跑" << std::endl;
    }
    
    void sleep() const override {
        std::cout << name << " 蜷缩着睡觉" << std::endl;
    }
    
    // 狗特有的方法
    void bark() const {
        std::cout << name << " 大声吠叫: 汪汪汪!" << std::endl;
    }
    
    void wagTail() const {
        std::cout << name << " 摇尾巴表示高兴" << std::endl;
    }
    
    void fetch(const std::string& item) const {
        std::cout << name << " 去捡 " << item << std::endl;
    }
    
    void train(const std::string& command) {
        std::cout << name << " 正在学习指令: " << command << std::endl;
        isTrained = true;
    }
    
    void performTrick() const {
        if (isTrained) {
            std::cout << name << " 表演特技: 坐下、握手、转圈" << std::endl;
        } else {
            std::cout << name << " 还没有接受训练" << std::endl;
        }
    }
    
    void displayDogInfo() const {
        displayMammalInfo();
        std::cout << "  品种: " << breed << std::endl;
        std::cout << "  已训练: " << (isTrained ? "是" : "否") << std::endl;
    }
    
    std::string getBreed() const { return breed; }
    bool getIsTrained() const { return isTrained; }
};

// 具体类：猫
class Cat : public Mammal {
private:
    bool isIndoor;
    int livesRemaining;
    
public:
    Cat(const std::string& n, int a, double w, const std::string& fur, bool indoor = true) 
        : Mammal(n, a, w, fur), isIndoor(indoor), livesRemaining(9) {
        std::cout << "创建猫: " << name << std::endl;
    }
    
    ~Cat() {
        std::cout << "销毁猫: " << name << std::endl;
    }
    
    // 重写虚函数
    void makeSound() const override {
        std::cout << name << " 喵喵叫" << std::endl;
    }
    
    void move() const override {
        std::cout << name << " 优雅地踱步" << std::endl;
    }
    
    void sleep() const override {
        std::cout << name << " 蜷成一团睡觉" << std::endl;
    }
    
    // 猫特有的方法
    void purr() const {
        std::cout << name << " 发出满足的呼噜声" << std::endl;
    }
    
    void climb() const {
        std::cout << name << " 爬到高处" << std::endl;
    }
    
    void hunt() const {
        if (!isIndoor) {
            std::cout << name << " 正在狩猎小动物" << std::endl;
        } else {
            std::cout << name << " 在室内玩玩具老鼠" << std::endl;
        }
    }
    
    void scratch() const {
        std::cout << name << " 在抓挠爪子" << std::endl;
    }
    
    void useLitterBox() const {
        if (isIndoor) {
            std::cout << name << " 使用猫砂盆" << std::endl;
        }
    }
    
    void displayCatInfo() const {
        displayMammalInfo();
        std::cout << "  室内猫: " << (isIndoor ? "是" : "否") << std::endl;
        std::cout << "  剩余生命: " << livesRemaining << std::endl;
    }
    
    bool getIsIndoor() const { return isIndoor; }
    int getLivesRemaining() const { return livesRemaining; }
};

// 动物园管理类
class Zoo {
private:
    std::vector<std::unique_ptr<Animal>> animals;
    std::string zooName;
    
public:
    Zoo(const std::string& name) : zooName(name) {
        std::cout << "创建动物园: " << zooName << std::endl;
    }
    
    ~Zoo() {
        std::cout << "关闭动物园: " << zooName << std::endl;
    }
    
    void addAnimal(std::unique_ptr<Animal> animal) {
        std::cout << "动物 " << animal->getName() << " 加入动物园" << std::endl;
        animals.push_back(std::move(animal));
    }
    
    void feedAllAnimals(const std::string& food) const {
        std::cout << "\n=== 喂食时间 ===" << std::endl;
        for (const auto& animal : animals) {
            animal->eat(food);
        }
    }
    
    void makeAllAnimalsSound() const {
        std::cout << "\n=== 动物叫声 ===" << std::endl;
        for (const auto& animal : animals) {
            animal->makeSound();
        }
    }
    
    void exerciseAllAnimals() const {
        std::cout << "\n=== 运动时间 ===" << std::endl;
        for (const auto& animal : animals) {
            animal->move();
        }
    }
    
    void napTime() const {
        std::cout << "\n=== 午睡时间 ===" << std::endl;
        for (const auto& animal : animals) {
            animal->sleep();
        }
    }
    
    void displayZooInfo() const {
        std::cout << "\n=== " << zooName << " 信息 ===" << std::endl;
        std::cout << "动物总数: " << animals.size() << std::endl;
        
        for (const auto& animal : animals) {
            animal->displayBasicInfo();
            std::cout << "---" << std::endl;
        }
    }
    
    size_t getAnimalCount() const {
        return animals.size();
    }
};

int main() {
    std::cout << "=== 继承与多态演示 ===" << std::endl;
    
    // 创建动物园
    Zoo myZoo("快乐动物园");
    
    // 创建不同类型的动物
    auto dog1 = std::make_unique<Dog>("旺财", 3, 25.5, "金黄色", "金毛");
    auto dog2 = std::make_unique<Dog>("小黑", 2, 15.0, "黑色", "拉布拉多");
    auto cat1 = std::make_unique<Cat>("咪咪", 2, 4.5, "白色", true);
    auto cat2 = std::make_unique<Cat>("小花", 4, 5.2, "花色", false);
    
    // 训练狗
    dog1->train("坐下");
    dog2->train("握手");
    
    // 展示特有行为
    std::cout << "\n=== 动物特有行为 ===" << std::endl;
    dog1->bark();
    dog1->wagTail();
    dog1->performTrick();
    
    cat1->purr();
    cat1->climb();
    cat1->hunt();
    
    // 将动物添加到动物园
    myZoo.addAnimal(std::move(dog1));
    myZoo.addAnimal(std::move(dog2));
    myZoo.addAnimal(std::move(cat1));
    myZoo.addAnimal(std::move(cat2));
    
    // 动物园活动（多态演示）
    myZoo.displayZooInfo();
    myZoo.makeAllAnimalsSound();
    myZoo.feedAllAnimals("优质饲料");
    myZoo.exerciseAllAnimals();
    myZoo.napTime();
    
    return 0;
}
```

### 虚函数与多态机制

**虚函数表演示**

```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    Base() {
        std::cout << "Base构造函数" << std::endl;
    }
    
    virtual ~Base() {
        std::cout << "Base析构函数" << std::endl;
    }
    
    virtual void virtualFunc1() const {
        std::cout << "Base::virtualFunc1()" << std::endl;
    }
    
    virtual void virtualFunc2() const {
        std::cout << "Base::virtualFunc2()" << std::endl;
    }
    
    void nonVirtualFunc() const {
        std::cout << "Base::nonVirtualFunc()" << std::endl;
    }
    
    virtual void pureVirtualFunc() const = 0;
};

class Derived1 : public Base {
public:
    Derived1() {
        std::cout << "Derived1构造函数" << std::endl;
    }
    
    ~Derived1() override {
        std::cout << "Derived1析构函数" << std::endl;
    }
    
    void virtualFunc1() const override {
        std::cout << "Derived1::virtualFunc1()" << std::endl;
    }
    
    // virtualFunc2 不重写，使用基类版本
    
    void nonVirtualFunc() const {  // 隐藏基类函数
        std::cout << "Derived1::nonVirtualFunc()" << std::endl;
    }
    
    void pureVirtualFunc() const override {
        std::cout << "Derived1::pureVirtualFunc()" << std::endl;
    }
    
    void derived1SpecificFunc() const {
        std::cout << "Derived1特有函数" << std::endl;
    }
};

class Derived2 : public Base {
public:
    Derived2() {
        std::cout << "Derived2构造函数" << std::endl;
    }
    
    ~Derived2() override {
        std::cout << "Derived2析构函数" << std::endl;
    }
    
    void virtualFunc1() const override {
        std::cout << "Derived2::virtualFunc1()" << std::endl;
    }
    
    void virtualFunc2() const override {
        std::cout << "Derived2::virtualFunc2()" << std::endl;
    }
    
    void pureVirtualFunc() const override {
        std::cout << "Derived2::pureVirtualFunc()" << std::endl;
    }
    
    void derived2SpecificFunc() const {
        std::cout << "Derived2特有函数" << std::endl;
    }
};

// 演示多态的函数
void demonstratePolymorphism(const Base& obj) {
    std::cout << "\n--- 多态演示 (类型: " << typeid(obj).name() << ") ---" << std::endl;
    
    obj.virtualFunc1();      // 多态调用
    obj.virtualFunc2();      // 多态调用
    obj.nonVirtualFunc();    // 静态绑定，总是调用Base版本
    obj.pureVirtualFunc();   // 多态调用
}

void demonstrateVirtualTable() {
    std::cout << "=== 虚函数表演示 ===" << std::endl;
    
    std::cout << "\n创建Derived1对象:" << std::endl;
    Derived1 d1;
    
    std::cout << "\n创建Derived2对象:" << std::endl;
    Derived2 d2;
    
    std::cout << "\n通过基类引用调用虚函数:" << std::endl;
    demonstratePolymorphism(d1);
    demonstratePolymorphism(d2);
    
    std::cout << "\n直接调用演示:" << std::endl;
    Base* ptr1 = &d1;
    Base* ptr2 = &d2;
    
    std::cout << "通过基类指针调用:" << std::endl;
    ptr1->virtualFunc1();  // 调用Derived1版本
    ptr2->virtualFunc1();  // 调用Derived2版本
    
    std::cout << "\n非虚函数调用:" << std::endl;
    ptr1->nonVirtualFunc();  // 总是调用Base版本
    ptr2->nonVirtualFunc();  // 总是调用Base版本
    
    std::cout << "\n直接对象调用非虚函数:" << std::endl;
    d1.nonVirtualFunc();     // 调用Derived1版本（函数隐藏）
    d2.Base::nonVirtualFunc(); // 显式调用Base版本
}

int main() {
    try {
        demonstrateVirtualTable();
    } catch (const std::exception& e) {
        std::cerr << "异常: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 多重继承示例

**多重继承的实际应用**

```cpp
#include <iostream>
#include <string>

// 第一个基类：可飞行的
class Flyable {
protected:
    double maxAltitude;
    double currentAltitude;
    
public:
    Flyable(double maxAlt = 1000.0) 
        : maxAltitude(maxAlt), currentAltitude(0.0) {
        std::cout << "Flyable构造函数" << std::endl;
    }
    
    virtual ~Flyable() {
        std::cout << "Flyable析构函数" << std::endl;
    }
    
    virtual void takeOff() {
        std::cout << "起飞中..." << std::endl;
        currentAltitude = 100.0;
    }
    
    virtual void land() {
        std::cout << "降落中..." << std::endl;
        currentAltitude = 0.0;
    }
    
    virtual void fly(double altitude) {
        if (altitude <= maxAltitude) {
            currentAltitude = altitude;
            std::cout << "飞行高度: " << currentAltitude << "米" << std::endl;
        } else {
            std::cout << "超过最大飞行高度!" << std::endl;
        }
    }
    
    double getCurrentAltitude() const { return currentAltitude; }
    double getMaxAltitude() const { return maxAltitude; }
};

// 第二个基类：可游泳的
class Swimmable {
protected:
    double maxDepth;
    double currentDepth;
    
public:
    Swimmable(double maxDep = 100.0) 
        : maxDepth(maxDep), currentDepth(0.0) {
        std::cout << "Swimmable构造函数" << std::endl;
    }
    
    virtual ~Swimmable() {
        std::cout << "Swimmable析构函数" << std::endl;
    }
    
    virtual void dive() {
        std::cout << "潜水中..." << std::endl;
        currentDepth = 10.0;
    }
    
    virtual void surface() {
        std::cout << "浮出水面..." << std::endl;
        currentDepth = 0.0;
    }
    
    virtual void swim(double depth) {
        if (depth <= maxDepth) {
            currentDepth = depth;
            std::cout << "游泳深度: " << currentDepth << "米" << std::endl;
        } else {
            std::cout << "超过最大潜水深度!" << std::endl;
        }
    }
    
    double getCurrentDepth() const { return currentDepth; }
    double getMaxDepth() const { return maxDepth; }
};

// 第三个基类：动物
class Animal {
protected:
    std::string name;
    int age;
    
public:
    Animal(const std::string& n, int a) : name(n), age(a) {
        std::cout << "Animal构造函数: " << name << std::endl;
    }
    
    virtual ~Animal() {
        std::cout << "Animal析构函数: " << name << std::endl;
    }
    
    virtual void makeSound() const = 0;
    virtual void eat() const {
        std::cout << name << " 正在进食" << std::endl;
    }
    
    std::string getName() const { return name; }
    int getAge() const { return age; }
};

// 多重继承：鸭子（既能飞又能游泳的动物）
class Duck : public Animal, public Flyable, public Swimmable {
private:
    std::string species;
    
public:
    Duck(const std::string& n, int a, const std::string& spec) 
        : Animal(n, a), Flyable(500.0), Swimmable(5.0), species(spec) {
        std::cout << "Duck构造函数: " << name << " (" << species << ")" << std::endl;
    }
    
    ~Duck() override {
        std::cout << "Duck析构函数: " << name << std::endl;
    }
    
    // 实现Animal的纯虚函数
    void makeSound() const override {
        std::cout << name << " 嘎嘎叫" << std::endl;
    }
    
    // 重写飞行相关方法
    void takeOff() override {
        std::cout << name << " 拍打翅膀起飞" << std::endl;
        Flyable::takeOff();
    }
    
    void land() override {
        std::cout << name << " 降落到水面" << std::endl;
        Flyable::land();
    }
    
    // 重写游泳相关方法
    void dive() override {
        std::cout << name << " 头朝下潜水觅食" << std::endl;
        Swimmable::dive();
    }
    
    void surface() override {
        std::cout << name << " 浮出水面" << std::endl;
        Swimmable::surface();
    }
    
    // 鸭子特有的方法
    void waddle() const {
        std::cout << name << " 摇摆着走路" << std::endl;
    }
    
    void quack() const {
        std::cout << name << " 大声嘎嘎叫" << std::endl;
    }
    
    void preen() const {
        std::cout << name << " 整理羽毛" << std::endl;
    }
    
    // 综合行为
    void dailyRoutine() const {
        std::cout << "\n" << name << " 的日常活动:" << std::endl;
        makeSound();
        waddle();
        const_cast<Duck*>(this)->takeOff();
        const_cast<Duck*>(this)->fly(200.0);
        const_cast<Duck*>(this)->land();
        const_cast<Duck*>(this)->dive();
        const_cast<Duck*>(this)->swim(3.0);
        const_cast<Duck*>(this)->surface();
        eat();
        preen();
    }
    
    void displayInfo() const {
        std::cout << "\n鸭子信息:" << std::endl;
        std::cout << "  姓名: " << name << std::endl;
        std::cout << "  年龄: " << age << " 岁" << std::endl;
        std::cout << "  品种: " << species << std::endl;
        std::cout << "  最大飞行高度: " << getMaxAltitude() << "米" << std::endl;
        std::cout << "  最大潜水深度: " << getMaxDepth() << "米" << std::endl;
        std::cout << "  当前飞行高度: " << getCurrentAltitude() << "米" << std::endl;
        std::cout << "  当前潜水深度: " << getCurrentDepth() << "米" << std::endl;
    }
    
    std::string getSpecies() const { return species; }
};

// 企鹅：只能游泳的鸟类
class Penguin : public Animal, public Swimmable {
private:
    std::string habitat;
    
public:
    Penguin(const std::string& n, int a, const std::string& hab) 
        : Animal(n, a), Swimmable(200.0), habitat(hab) {
        std::cout << "Penguin构造函数: " << name << " (栖息地: " << habitat << ")" << std::endl;
    }
    
    ~Penguin() override {
        std::cout << "Penguin析构函数: " << name << std::endl;
    }
    
    void makeSound() const override {
        std::cout << name << " 发出企鹅叫声" << std::endl;
    }
    
    // 重写游泳方法
    void dive() override {
        std::cout << name << " 像鱼雷一样潜入水中" << std::endl;
        Swimmable::dive();
    }
    
    void swim(double depth) override {
        std::cout << name << " 在冰冷的海水中游泳" << std::endl;
        Swimmable::swim(depth);
    }
    
    // 企鹅特有方法
    void slide() const {
        std::cout << name << " 在冰面上滑行" << std::endl;
    }
    
    void huddle() const {
        std::cout << name << " 与其他企鹅抱团取暖" << std::endl;
    }
    
    void displayInfo() const {
        std::cout << "\n企鹅信息:" << std::endl;
        std::cout << "  姓名: " << name << std::endl;
        std::cout << "  年龄: " << age << " 岁" << std::endl;
        std::cout << "  栖息地: " << habitat << std::endl;
        std::cout << "  最大潜水深度: " << getMaxDepth() << "米" << std::endl;
        std::cout << "  当前潜水深度: " << getCurrentDepth() << "米" << std::endl;
    }
};

int main() {
    std::cout << "=== 多重继承演示 ===" << std::endl;
    
    // 创建鸭子
    std::cout << "\n创建鸭子:" << std::endl;
    Duck mallard("小绿", 2, "绿头鸭");
    
    // 创建企鹅
    std::cout << "\n创建企鹅:" << std::endl;
    Penguin emperor("帝帝", 5, "南极");
    
    // 展示鸭子的能力
    std::cout << "\n=== 鸭子的多重能力 ===" << std::endl;
    mallard.displayInfo();
    mallard.dailyRoutine();
    
    // 展示企鹅的能力
    std::cout << "\n=== 企鹅的游泳能力 ===" << std::endl;
    emperor.displayInfo();
    emperor.makeSound();
    emperor.slide();
    emperor.dive();
    emperor.swim(150.0);
    emperor.surface();
    emperor.huddle();
    
    // 多态演示
    std::cout << "\n=== 多态演示 ===" << std::endl;
    
    // 作为Animal使用
    Animal* animals[] = {&mallard, &emperor};
    for (int i = 0; i < 2; i++) {
        std::cout << "动物 " << (i+1) << ":" << std::endl;
        animals[i]->makeSound();
        animals[i]->eat();
        std::cout << std::endl;
    }
    
    // 作为Swimmable使用
    Swimmable* swimmers[] = {&mallard, &emperor};
    std::cout << "游泳比赛:" << std::endl;
    for (int i = 0; i < 2; i++) {
        swimmers[i]->dive();
        swimmers[i]->swim(50.0);
        swimmers[i]->surface();
        std::cout << std::endl;
    }
    
    return 0;
}